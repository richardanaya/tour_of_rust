{
  "common_words": {
    "chapter_en": "Chapter",
    "tor_en": "Tour of Rust",
    "next_en": "Next",
    "previous_en": "Previous",
    "toc_en": "Table of Contents",
    "lessons_en": "Lessons",
    "tor_de": "Tour zu Rust",
    "next_de": "Weiter",
    "previous_de": "Zur√ºck",
    "toc_de": "Inhaltsverzeichnis",
    "lessons_de": "Kapitel",
    "chapter_de": "Kapitel",
    "chapter_ru": "–ì–ª–∞–≤–∞",
    "tor_ru": "–¢—É—Ä –ø–æ Rust",
    "next_ru": "–î–∞–ª–µ–µ",
    "previous_ru": "–ù–∞–∑–∞–¥",
    "toc_ru": "–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ",
    "lessons_ru": "–ó–∞–Ω—è—Ç–∏—è"
  },
  "pages": [
    {
      "title_en": "Hello, <span class=\"emoji\">ü¶Ä</span>",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A",
      "content_en": "<p>Welcome to the <b>Tour of Rust</b>. This is meant to be a step by step guide through the features of the Rust programming language.  Rust is often considered a language with a steep learning curve, I hope I can convince you there's a lot to explore before we even get to complex parts.</p><p>You can find this guide in these languages:<ul><li><a href=\"index_de.html\">Deutsch</a></li><li><a href=\"index.html\">English</a></li><li><a href=\"index_ie.html\">Interlingue</a></li><li><a href=\"index_ru.html\">–†—É—Å—Å–∫–∏–π</a></li></ul></p><p>If you have suggestions on content or would like to contribute to translations, checkout out Tour of Rust's <a href=\"https://github.com/richardanaya/tour_of_rust\">github repository</a>.</p><p>In this classic example we show Rust's support for unicode strings.</p>",
      "title_ie": "Salute, <span class=\"emoji\">ü¶Ä</span>",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20println!(%22Salute%2C%20%F0%9F%A6%80%22)%3B%0A%7D",
      "content_ie": "<p>Benevenit al <b>Tur de Rust</b>. Li tur intente esser un guide explicat passu a passu al caracteristicas trovat in li lingue de programmation Rust. On considera Rust un lingue complex con un scarp curve de aprension, ma yo espera convicter te que hay multcos a explorar e aprender ante que veni li complexit√°.</p> <p>In ti-ci exemple on vide li exemple classic de programmation quel monstra li subtention de strings (catenes) unicode in Rust.</p><p>Translations:<ul><li><a href=\"index_de.html\">Deutsch</a></li><li><a href=\"index.html\">English</a></li><li><a href=\"index_ie.html\">Interlingue</a></li><li><a href=\"index_ru.html\">–†—É—Å—Å–∫–∏–π</a></li></ul></p><p>Si tu have suggestiones pri contenete o vole contribuer un traduction, ples visitar li <a href=\"https://github.com/richardanaya/tour_of_rust\">repositoria github</a> del Tur de Rust.</p>",

      "title_de": "Hallo, <span class=\"emoji\">ü¶Ä</span>",
      "content_de": "<p>Willkommen auf der <b>Tour zu Rust</b>. Hier werden die Features aus der Programmiersprache Rust Schritt f√ºr Schritt eingef√ºhrt. Rust wird oft mit einer steilen Lernkurve in Verbindung gebracht - allerdings gibt es schon zu Beginn viele spannende Besonderheiten zu entdecken, die hoffentlich dein Interesse wecken werden!</p> <p>In diesem klassischen Beispiel sehen wir Rust's Unterst√ºtzung von Unicode Strings.</p><p>Wenn du dieses Projekt mit Inhalten und √úbersetzungen (wie diese hier) unterst√ºtzen willst, wirf einen Blick auf die <a href=\"https://github.com/richardanaya/tour_of_rust\">GitHub Repository</a>.</p><p>Translations:<ul><li><a href=\"index_de.html\">Deutsche</a></li><li><a href=\"index.html\">English</a></li><li><a href=\"index_ie.html\">Interlingue</a></li><li><a href=\"index_ru.html\">–†—É—Å—Å–∫–∏–π</a></li></ul></p>",

      "title_ru": "–ü—Ä–∏–≤–µ—Ç, <span class=\"emoji\">ü¶Ä</span>",
      "content_ru": "<p>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ <b>–¢—É—Ä –ø–æ Rust</b>. –≠—Ç–æ –ø–æ—à–∞–≥–æ–≤–æ–µ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è Rust. Rust —á–∞—Å—Ç–æ –∞—Å—Å–æ—Ü–∏–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ —è–∑—ã–∫ –∫–æ—Ç–æ—Ä—ã–π —Å–ª–æ–∂–µ–Ω –≤ –æ–±—É—á–µ–Ω–∏–∏, —è –Ω–∞–¥–µ—é—Å—å —á—Ç–æ —Å–º–æ–≥—É –æ–±—ä—è—Å–Ω–∏—Ç—å –º–Ω–æ–≥–æ–µ –¥–æ —Ç–æ–≥–æ,  –∫–∞–∫ –º—ã –ø–µ—Ä–µ–π–¥—ë–º –∫ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–º —á–∞—Å—Ç—è–º.</p><p>–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–π—Ç–∏ —ç—Ç–æ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –≤ —Ç–∞–∫–∏—Ö —è–∑—ã–∫–∞—Ö:<ul><li><a href=\"index_de.html\">Deutsch</a></li><li><a href=\"index.html\">English</a></li><li><a href=\"index_ie.html\">Interlingue</a></li><li><a href=\"index_ru.html\">–†—É—Å—Å–∫–∏–π</a></li></ul></p><p>–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É –∏–ª–∏ –≤—ã –±—ã —Ö–æ—Ç–µ–ª–∏ –ø–æ–º–æ—á—å —Å –ø–µ—Ä–µ–≤–æ–¥–æ–º, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –¢—É—Ä –ø–æ Rust <a href=\"https://github.com/richardanaya/tour_of_rust\">github —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π</a>.</p><p>–í —ç—Ç–æ–º –∫–ª–∞—Å–∏—á–µ—Å–∫–æ–º –ø—Ä–∏–º–µ—Ä–µ –º—ã –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É —é–Ω–∏–∫–æ–¥ —Å—Ç—Ä–æ–∫ –≤ Rust.</p>"
    },
    {
      "title_en": "Chapter 1 - The Basics",
      "content_en": "<p>In this first chapter we're going to be exploring the very basics with functions, variables, and the most primitive types. Glad to have you on board!</p><p>Also! In case you are wondering who this adorable crab is speaking to you, I am <b>Ferris</b>, the unofficial mascot for the Rust programming language. Nice to meet you.</p>",
      "title_ie": "Capitul 1 - Coses Simplic",
      "content_ie": "<p>Ci in li unesim capitul, noi va explorar li max simplic coses in li lingue, includente functiones, variabiles, e li tipes max primitiv. Felici a haver te con noi!</p><p>Hay alquo in plu! Un brevi introduction por li casu in quel tu questiona te qui es ti-ci amabil crabe quel parla te: yo nomina me <b>Ferris</b>, li mascote √≠noficial por li lingue de programmation Rust. Felici a incontrar te.</p>",

      "title_de": "Kapitel 1 - Die Basics",
      "content_de": "<p>Im ersten Kapitel werden grundlegende Eigenschaften von Funktionen, Variablen und (fast) allen primitiven Datentypen pr√§sentiert. Willkommen an Board!</p><p>Ach ja! Falls du dich fragst, wer diese s√º√üe sprechende Krabbe ist, das ist <b>Ferris</b>, das inoffizielle Maskottchen der Programmiersprache Rust. Sag hallo!</p>",

      "title_ru": "–ì–ª–∞–≤–∞ 1 - –û—Å–Ω–æ–≤—ã",
      "content_ru": "<p>–í –ø–µ—Ä–≤–æ–π –≥–ª–∞–≤–µ –º—ã —É–∑–Ω–∞–µ–º –æ—Å–Ω–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π, –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –ø—Ä–∏–º–∏—Ç–∏–≤–Ω—ã—Ö —Ç–∏–ø–æ–≤. –†–∞–¥ –≤–∏–¥–µ—Ç—å –≤–∞—Å –Ω–∞ –±–æ—Ä—Ç—É!</p><p>–¢–∞–∫–∂–µ! –ï—Å–ª–∏ –≤–∞–º –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ, –∫—Ç–æ —ç—Ç–æ—Ç –≤–æ—Å—Ö–∏—Ç–∏—Ç–µ–ª—å–Ω—ã–π –∫—Ä–∞–±, –≥–æ–≤–æ—Ä—è—â–∏–π —Å –≤–∞–º–∏, –Ø <b>–§–µ—Ä—Ä–∏—Å</b> - –Ω–µ–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –º–∞—Å–∫–æ—Ç —è–∑—ã–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è Rust. –ü—Ä–∏—è—Ç–Ω–æ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è.</p>"
    },
    {
      "title_en": "The Rust Playground",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%20You%20can%20modify%20the%20code%20in%20here.%22)%3B%0A%7D%0A",
      "content_en": "<p>This tour uses an interactive coding tool at <a href=\"https://play.rust-lang.org/\">https://play.rust-lang.org</a></p><p>It's a great way to play around with Rust and show others your creativity and challenges!</p>",
      "title_ie": "Li Lud-terren Rust",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20println!(%22Benevenit%20al%20lude-terren!%20Tu%20posse%20modificar%20li%20code%20ci.%22)%3B%0A%7D",
      "content_ie": "<p>Ti-ci tur usa un instrument interactiv por codar quel trova se a <a href=\"https://play.rust-lang.org/\">https://play.rust-lang.org</a></p><p>It es un bonissim metode por luder con Rust e monstrar li altres tui creativit√° e def√≠s!</p>",

      "title_de": "The Rust Playground",
      "content_de": "<p>Diese Tour macht sich das interaktive Coding Tool von <a href=\"https://play.rust-lang.org/\">https://play.rust-lang.org</a> zu Nutze.</p><p>Beispiele in Rust lassen sich so spielend leicht testen. Hierbei sind deiner Kreativit√§t auch keine Grenzen gesetzt. √Ñndere Codeschnipsel, teste Funktionen, lass deiner Fantasie freien Lauf!</p>",

      "title_ru": "The Rust Playground",
      "content_ru": "<p>–≠—Ç–æ—Ç —Ç—É—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä <a href=\"https://play.rust-lang.org/\">https://play.rust-lang.org</a></p><p>–≠—Ç–æ —Ö–æ—Ä–æ—à–∏–π —Å–ø–æ—Å–æ–± –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å Rust, –ø–æ–∫–∞–∑–∞—Ç—å –¥—Ä—É–≥–∏–º –≤–∞—à—É –∫—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –∏ —Å–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏!</p>"
    },
    {
      "title_en": "Modules",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A",
      "content_en": "<p>Every Rust program or library is a <b>crate</b>.</p><p>Every crate is made of a heirarchy of <b>modules</b>.</p><p>Programs start running in the root module of a crate at the <highlight>main()</highlight> function in a file called \"main.rs\".<p></p><p>Libraries have a root module in the file \"lib.rs\" and export useful members.</p><p>To prevent typing out full paths like <highlight>std::f64::consts::PI</highlight>. The <b>use</b> keyword allows us to specify particular items from modules we want to use throughout our code without a full path. For instance <highlight>use std::f64::consts::PI</highlight> allows me to just use the identifier <highlight>PI</highlight> in my main function.</p><p><b>std</b> is the crate of the <b>standard library</b> of Rust which is full of useful data structures and functions for interacting with your operating system.</p><p>A searchable directory of crates created by the community can be found at <a href=\"https://crates.io/\">https://crates.io</a></p>",
      "title_ie": "Modules",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20println!(%22Benevenit%20al%20lud-terren!%22)%3B%0A%20%20println!(%22Yo%20tant%20desira%20un%20tranche%20de%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A",
      "content_ie": "<p>Chascun programma o biblioteca in Rust es un <b>crate</b> (significant un corbe o un chest).</p><p>Chascun crate es composit ex un hierarchie de <b>modules</b>.</p><p>Programmas comensa functionar in li module radical de un crate in li function <highlight>main()</highlight> in un archive nominat \"main.rs\".<p></p><p>Bibliotecas have un module radical in li archive \"lib.rs\" e exporta membres util.</p><p>Por prevenir li tipada de plen percurses quam <highlight>std::f64::consts::PI</highlight>, li clave-parol <b>use</b> fa it possibil por nos specificar li articules particulari in modules queles noi vole usar tra nor code sin un plen percurse. Por exemple, <highlight>use std::f64::consts::PI</highlight> possibilisa li sol usation de  <highlight>PI</highlight> in mi function main.</p><p><b>std</b> es li n√≥mine del biblioteca standard (<b>standard library</b>) de Rust quel es plen de util data-structuras e functiones por interacter con tui sistema de operation.</p><p>Un searchabil directoria de crates creat per li comunit√© trova se sur <a href=\"https://crates.io/\">https://crates.io</a></p>",

      "title_de": "Module",
      "content_de": "<p>Jedes Programm bzw. jede Bibliothek in Rust ist ein <b>crate</b> (Kiste).</p><p>Jedes crate besteht aus einer hierarchischen Ansammlung von <b>modules</b>.</p><p>Programme werden aus einem root module (Wurzelelement) eines crates gestartet, Startpunkt bildet hierbei die Funktion <highlight>main()</highlight> in einer Datei namens \"main.rs\".<p></p><p>Bibliotheken haben ein root module in der Datei \"lib.rs\" und exportieren n√ºtzliche Elemente.</p><p>Um komplette Namespaces wie <highlight>std::f64::consts::PI</highlight> nicht austippen zu m√ºssen, wurde das <b>use</b> Schl√ºsselwort eingef√ºhrt. Beispielsweise erlaubt <highlight>use std::f64::consts::PI</highlight> uns den Identifier <highlight>PI</highlight> in der main-Funktion einfach zu verwenden.</p><p><b>std</b> ist das crate der <b>Standardbibliothek</b> von Rust, das allerlei n√ºtzliche Datenstrukturen und Funktionen beinhalten, durch welche wir mit dem Betriebssystem kommunizieren k√∂nnen.</p><p>Die Fanbase von Rust h√§lt die Seite <a href=\"https://crates.io/\">https://crates.io</a> am Laufen, auf der es s√§mtliche crates im √úberblick zu finden gibt.</p>",

      "title_ru": "–ú–æ–¥—É–ª–∏",
      "content_ru": "<p>–ö–∞–∂–¥–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞ –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–∞ Rust —ç—Ç–æ <b>crate</b>.</p><p>–ö–∞–∂–¥—ã–π crate —Å–¥–µ–ª–∞–Ω –∏–∑ –∏–µ—Ä–∞—Ä—Ö–∏–∏ <b>–º–æ–¥—É–ª–µ–π</b>.</p><p>–ü—Ä–æ–≥—Ä–∞–º–º—ã –Ω–∞—á–∏–Ω–∞—é—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ –∫–æ—Ä–Ω–µ–≤–æ–º(root) –º–æ–¥—É–ª–µ –∫—Ä–µ–π—Ç–∞(crate) –≤ <highlight>main()</highlight> —Ñ—É–Ω–∫—Ü–∏–∏ —Å —Ñ–∞–π–ª–∞ \"main.rs\".<p></p><p>–ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–º–µ—é—Ç –∫–æ—Ä–Ω–µ–≤–æ–π –º–æ–¥—É–ª—å –≤ —Ñ–∞–π–ª–µ \"lib.rs\" –∏  —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É—é—Ç –ø–æ–ª–µ–∑–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã.</p><p>–î–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –Ω–µ –ø–∏—Å–∞—Ç—å –ø–æ–ª–Ω—ã–µ –ø—É—Ç–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä <highlight>std::f64::consts::PI</highlight>, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <b>use</b>. –û–Ω–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º —É–∫–∞–∑–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å –º–æ–¥—É–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ö–æ—Ç–∏–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –∫–æ–¥–µ –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è –ø–æ–ª–Ω–æ–≥–æ –ø—É—Ç–∏. –ù–∞–ø—Ä–∏–º–µ—Ä <highlight>use std::f64::consts::PI</highlight> –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–æ—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä <highlight>PI</highlight> –≤ –≥–ª–∞–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏.</p><p><b>std</b> —ç—Ç–æ –∫—Ä–µ–π—Ç <b>—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏</b> Rust(a), –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª–æ–Ω –ø–æ–ª–µ–∑–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö –∏ —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π.</p><p>–†–µ–≥–∏—Å—Ç—Ä –∫—Ä–µ–π—Ç–æ–≤, —Å–æ–∑–¥–∞–Ω–Ω—ã–π —Å–æ–æ–±—â–µ—Å—Ç–≤–æ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ <a href=\"https://crates.io/\">https://crates.io</a></p>"
    },
    {
      "title_en": "Exporting",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=mod%20my_sub_module%20%7B%0A%20%20%20%20fn%20do_something()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22doing%20something%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20do_something_else()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22doing%20something%20else%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20my_sub_module%3A%3Ado_something()%3B%0A%20%20%20%20my_sub_module%3A%3Ado_something_else()%3B%0A%7D%0A",
      "content_en": "<p>In Rust, we export members of a module using the <b>pub</b> keyword.</p><p>When using a module either within your own code or an external crate, you can only refer to members that have been marked public.</p><p>The code in this example is broken, add the <b>pub</b> keyword in the appropriate place to fix it.</p>",
      "title_ie": "Exportation",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=mod%20mi_sub_module%20%7B%0A%20%20fn%20far_alquo()%20%7B%0A%20%20%20%20println!(%22fant%20alquo%22)%0A%20%20%7D%0A%0A%20%20pub%20fn%20far_alquo_in_plu()%20%7B%0A%20%20%20%20println!(%22fant%20alquo%20in%20plu%22)%0A%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20mi_sub_module%3A%3Afar_alquo()%3B%0A%20%20mi_sub_module%3A%3Afar_alquo_in_plu()%3B%0A%7D%0A",
      "content_ie": "<p>In Rust, noi exporta membres de un module usante li clave-parol <b>pub</b>.</p><p>Quande on usa un module, sive in su propri code sive in un crate extern, on posse solmen aluder a membres possedent li marcation public.</p><p>Li code in ti-ci exemple es ruptet; ples adjunter li clave-parol <b>pub</b> in li loc necessi por reparar it.</p>",

      "title_de": "Export",
      "content_de": "<p>Auch wenn von Kisten (crates) in Rust gesprochen wird, werden nicht ganze Schiffscontainer an andere Developer exportiert, sondern lediglich Teile aus der Kiste. Diese Teile (oder members) sind mit dem Schl√ºsselwort <b>pub</b> (f√ºr 'public') versehen.</p><p>Wenn externe oder interne Module verwendet werden, k√∂nnen lediglich auf members zugegriffen werden, die mit <b>pub</b> exportiert wurden.</p><p>Folgendes Codebeispiel ist fehlerhaft. F√ºge ein <b>pub</b> an der richtigen Stelle ein, um es wieder zum Laufen zu bringen.</p>",

      "title_ru": "–ï–∫—Å–ø–æ—Ä—Ç",
      "content_ru": "<p>–í Rust –º—ã —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–¥—É–ª—è, –∏—Å–ø–æ–ª—å–∑—É—è –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <b>pub</b>.</p><p>–ò—Å–ø–æ–ª—å–∑—É—è –º–æ–¥—É–ª—å –≤–Ω—É—Ç—Ä–∏ –≤–∞—à–µ–≥–æ –∫–æ–¥–∞ –∏–ª–∏ –≤–æ –≤–Ω–µ—à–Ω–µ–º –∫—Ä–µ–π—Ç–µ, –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –∫ —ç–ª–µ–º–µ–Ω—Ç–∞–º, —á—Ç–æ –±—ã–ª–∏ –ø–æ–º–µ—á–µ–Ω—ã –ø—É–±–ª–∏—á–Ω—ã–º–∏.</p><p>–ö–æ–¥ –≤ —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –¥–æ–±–∞–≤—å—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <b>pub</b> –≤ –Ω—É–∂–Ω–æ–º –º–µ—Å—Ç–µ, —á—Ç–æ–±—ã –ø—Ä–∏–º–µ—Ä —É—Å–ø–µ—à–Ω–æ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–ª—Å—è.</p>"
    },
    {
      "title_en": "Functions",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A",
      "content_en": "<p>A function can take zero or more arguments.</p><p>In this example, add takes two parameters of type <highlight>i32</highlight> (integer of 32 bit length).</p><p>Function names are always in <highlight>snake_case</highlight></p>",
      "title_ie": "Functiones",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20adddir(x%3Ai32%2C%20y%3Ai32)%20-%3E%20i32%20%7B%0A%09return%20x%20%2B%20y%20%2F%2F%20Ci%20on%20utilisa%20return%20por%20monstrar%20que%20anc%20Rust%20possede%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20ti%20clave-parol%20comun%20in%20altri%20lingues%20de%20programmation%2C%20%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20ma%20li%20plu%20idiomatic%20metode%20por%20retornar%20un%20valore%20in%20Rust%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20es%20simplicmen%20scrir%20x%20%2B%20y%20sin%20un%20punctu-comma%20(%3B)%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Dunc%3A%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20return%20x%20%2B%20y%20%3C--%20retorna%20un%20valore%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20x%20%2B%20y%20%3C--%20retorna%20un%20valore%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20x%20%2B%20y%3B%20%3C--%20retorna%20null%20valore%20(nota%20li%20%3B%20pos%20x%20%2B%20y)%0A%7D%0A%0Afn%20main()%20%7B%0A%09println!(%22%7B%7D%22%2Cadddir(42%2C%2013))%3B%0A%7D",
      "content_ie": "<p>Un function posse prender null o plu argumentes.</p><p>In ti-ci exemple, adddir prende du parametres del tip <highlight>i32</highlight> (integer (n√∫mere integrale) del longore 32-bit).</p><p>N√≥mines de functiones es sempre in <highlight>snake_case</highlight> (minuscules con infra-strecs)</p>",

      "title_de": "Funktionen",
      "content_de": "<p>Eine Funktion kann eine beliebige (nicht-negative) Anzahl an Argumenten bzw. Parametern aufnehmen.</p><p>In diesem Beispiel verlangt die Funktion <highlight>add</highlight> zwei Parameter vom Typ <highlight>i32</highlight> (32 Bit Ganzzahl).</p><p>Funktionsnamen sollten im <highlight>snake_case</highlight> Format vergeben werden.</p>",

      "title_ru": "–§—É–Ω–∫—Ü–∏–∏",
      "content_ru": "<p>–§—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –Ω–æ–ª—å –∏–ª–∏ –±–æ–ª—å—à–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤.</p><p>–í —ç—Ç–æ–º –ø—Ä–∏–º–µ—Ä–µ, —Ñ—É–Ω–∫—Ü–∏—è <b>add</b> –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –¥–≤–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ —Ç–∏–ø–∞ <highlight>i32</highlight> (—Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ, –¥–ª–∏–Ω–æ–π –≤ 32 –±–∏—Ç–∞).</p><p>–ò–º–µ–Ω–∞ —Ñ—É–Ω–∫—Ü–∏–π –≤—Å–µ–≥–¥–∞ –ø–∏—à—É—Ç—Å—è –≤ <highlight>–∑–º–µ–∏–Ω–æ–º_—Ä–µ–≥–∏—Å—Ç—Ä–µ</highlight>(<highlight>snake_case</highlight>)</p>"
    },
    {
      "title_en": "Variables",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A",
      "content_en": " <p>Variables are declared using the <b>let</b> keyword.</p><p>When assigning a value, Rust will be able to infer the type of your variable 99% of the time. If it cannot you may add the type to your variable declaration.</p><p>Notice how we can assign to the same variable name multiple times. This is called variable shadowing and the type can be changed for subsequent references to that name.</b></p><p>Variable names are always in <highlight>snake_case</highlight></p>",
      "title_ie": "Variables",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%2F%2F%20rust%20infere%20li%20tip%20de%20x%0A%20%20let%20x%20%3D%2013%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%0A%20%20%2F%2F%20rust%20posse%20anc%20specificar%20li%20tip%20explicitmen%0A%20%20let%20x%3Af64%20%3D%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%0A%20%20%2F%2F%20rust%20posse%20anc%20declarar%20in%20prim%2C%20poy%20inicialisar%2C%20ma%20ti-ci%20metode%0A%20%20%2F%2F%20es%20rarmen%20usat%0A%20%20let%20x%3B%0A%20%20x%20%3D%200%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%7D",
      "content_ie": " <p>On declara variabiles con li clave-parol <b>let</b>.</p><p>Quande on assigna un valore, Rust va posser inferer li tip del variabile con un certit√° de 99%. Si it ne posse, tu posse adjunter li tip al declaration por li variabile.</p><p>A notar es qualmen noi posse assignar li sam n√≥mine por un variabile plu quam un vez. Ti-ci metode es nominat variable shadowing (\"variabil-ombration\") in quel li tip va posser changear se por referenties sequent por ti n√≥mine.</b></p><p>N√≥mines por variabiles sempre usa <highlight>snake_case</highlight> (minuscules con infra-strecs)</p>",

      "title_de": "Variablen",
      "content_de": "<p>Variablen werden mit dem Schl√ºsselwort <highlight>let</highlight> deklariert.</p><p>Im Regelfall sollte man Rust die Entscheidung √ºberlassen, um welchen Datentypen es sich handelt. In Sonderf√§llen kann der Typ explizit angegeben werden.</p><p>Huch, was ist denn bei dem Beispiel los? Die Variable <highlight>x</highlight> wird mehrmals deklariert?</p><p>Das ist kein Fehler - Rust erlaubt sogenanntes <b>variable shadowing</b> (Variable √ºberschatten). Bei Neudeklaration \"verf√§llt\" die vorige Deklaration und wir k√∂nnen mit der Variable arbeiten, als ob es sie davor noch nie gegeben h√§tte. Der Datentyp darf sich dabei auch √§ndern.</p><p>Variablennamen werden ebenfalls in <highlight>snake_case</highlight> geschrieben.</p>",

      "title_ru": "–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ",
      "content_ru": " <p>–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–±—ä—è–≤–ª—è—é—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <b>let</b>.</p><p>–ö–æ–≥–¥–∞ –µ–π –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ, Rust –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –≤—ã–≤–µ—Å—Ç–∏ —Ç–∏–ø –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤ 99% —Å–ª—É—á–∞—è—Ö. –ï—Å–ª–∏ –≤—ã–≤–æ–¥ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω, –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å —Ç–∏–ø –≤ –æ–±—ä—è–≤–ª–µ–Ω–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.</p><p>–ó–∞–º–µ—Ç—å—Ç–µ, –∫–∞–∫ –º—ã –º–æ–∂–µ–º –ø—Ä–∏—Å–≤–æ–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–π –∏ —Ç–æ–π –∂–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ä–∞–∑. –≠—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è —Å–æ–∫—Ä—ã—Ç–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π(variable shadowing), –µ—ë —Ç–∏–ø –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω –≤ –ø–æ—Å–ª–µ–¥—É—é—â–∏—Ö –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è—Ö.</b></p><p>–ù–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤—Å–µ–≥–¥–∞ <highlight>snake_case</highlight></p>"
    },
    {
      "title_en": "Changing values",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A",
      "content_en": " <p>Rust cares a great deal about what values are modified. Values fall into two types:</p><ul><li><b>mutable</b> - the location in memory can be written to and read</li><li><b>immutable</b> - the location in memory can only be read</li></ul><p>Mutable values are always denoted with a <b>mut</b> keyword in some manner</p><p>We will have a lot more to say on this concept, but for now just keep an eye out for this keyword for what things can be modified</p>",
      "title_ie": "Changear valores",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%20%20x%20%3D%2013%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%7D",
      "content_ie": " <p>Rust sucia se mult pri li valores queles es modificat. Valores possede du tipes:</p><ul><li><b>mutabil</b> - li loc in memorie posse esser inscrit e leet</li><li><b>√≠nmutabil</b> - li loc in memorie posse esser solmen leet</li></ul><p>On denota sempre li valores mutabil con li clave-parol <b>mut</b></p><p>Pri to noi va parlar plu con detallies, ma por li momente ples solmen atenter pri ti-ci parol-clave quel monstra que un cose es modificabil</p>",

      "title_de": "Variablenwerte √§ndern",
      "content_de": " <p>Rust sorgt sich sehr darum, welche Variablen ver√§ndert werden k√∂nnen und welche nicht. Daher gibt es die folgende Unterscheidung:</p><ul><li><b>mutable</b> - der Speicherort der Variable kann beschrieben und gelesen werden</li><li><b>immutable</b> - der Speicherort der Variable kann nur gelesen werden</li></ul><p>Variablen, die ver√§ndert werden k√∂nnen, werden mit einem extra <highlight>mut</highlight> Schl√ºsselwort gekennzeichnet.</p><p>Auf dieses Konzept wird im sp√§teren Verlauf noch mehr eingegangen, f√ºr jetzt ist es wichtig zu wissen, dass \"mutable\" Variablen beschrieben werden k√∂nnen.</p>",

      "title_ru": "–ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö",
      "content_ru": " <p>Rust —É–¥–µ–ª—è–µ—Ç –º–Ω–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è —Ç–æ–º—É, –∫–∞–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω—ã. –ó–Ω–∞—á–µ–Ω–∏—è (–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ) –¥–µ–ª—è—Ç—Å—è –Ω–∞ –¥–≤–∞ —Ç–∏–ø–∞:</p><ul><li><b>mutable</b> - –æ–±–ª–∞—Å—Ç—å –ø–∞–º—è—Ç–∏, –≤ –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –∑–∞–ø–∏—Å–∞—Ç—å –∏ —Å—á–∏—Ç–∞—Ç—å</li><li><b>immutable</b> - –æ–±–ª–∞—Å—Ç—å –ø–∞–º—è—Ç–∏, —Å –∫–æ—Ç–æ—Ä–æ–π –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ —Å—á–∏—Ç–∞—Ç—å</li></ul><p>Mutable –∑–Ω–∞—á–µ–Ω–∏—è –≤—Å–µ–≥–¥–∞ –∫–∞–∫–∏–º-—Ç–æ –æ–±—Ä–∞–∑–æ–º –æ–±–æ–∑–Ω–∞—á–µ–Ω—ã —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ <b>mut</b>.</p><p>–ú—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ–± —ç—Ç–æ–º –ø–æ–∑–∂–µ, —Å–µ–π—á–∞—Å –ø—Ä–æ—Å—Ç–æ —Å–ª–µ–¥–∏—Ç–µ –∑–∞ —ç—Ç–∏–º –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–æ–º –∏ —Ç–µ–º, –∫–∞–∫–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–≥—É—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω—ã.</p>"
    },
    {
      "title_en": "Multiple return variables",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A",
      "content_en": "<p>Functions can return multiple values by returning a <b>tuple</b> of values.</p><p>The values can be referenced by their position in the tuple.</p><p>Rust supports various kinds of destructuring that we will see in many forms. It allows us to extract sub-pieces of data structures in ergonomic ways. Be on the look out!</p>",
      "title_ie": "Multiplic retorn-valores",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20interchangear(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20retorna%20un%20tuple%20de%20retorn-valores%0A%20%20%20%20let%20resulta%20%3D%20interchangear(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20resulta.0%2C%20resulta.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructura%20li%20tuple%20in%20du%20n%C3%B3mines%20de%20variabiles%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20interchangear(resulta.0%2C%20resulta.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A",
      "content_ie": "<p>Functiones posse retornar multiplic valores per retornar un <b>tuple</b> de valores. (N.B. un tuple es parent con -tuplic in Interlingue-Occidental)</p><p>On posse referer al valores per lor position in li tuple.</p><p>Rust subtene varie tipes de destructuration quel noi va vider in pluri formes. To possibilisa li extraction de sub-pezzes de data ergonomicmen. Esse atentiv por it!</p>",

      "title_de": "Mehrere return-Variablen",
      "content_de": "<p>Funktionen k√∂nnen mehrere Variablen auf einmal zur√ºckgeben mittels eines <b>tuples</b>.</p><p>Die Werte k√∂nnen danach √ºber einen Index gelesen werden.</p><p>Rust unterst√ºtzt verschiedene Formen von \"destructuring\", wodurch sich Wertepaare auf einzelne Variablen aufteilen lassen. Halte Ausschau danach!</p>",

      "title_ru": "–í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π",
      "content_ru": "<p>–§—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é <b>–∫–æ—Ä—Ç–µ–∂–∞(tuple)</b> –∑–Ω–∞—á–µ–Ω–∏–π.</p><p>–î–æ—Å—Ç—É–ø –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è –ø–æ –∏—Ö –ø–æ–∑–∏—Ü–∏–∏ –≤ –∫–æ—Ä—Ç–µ–∂–µ.</p><p>Rust –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä–∞–∑–Ω—ã–µ –≤–∏–¥—ã –¥–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã —É–≤–∏–¥–∏—Ç–µ –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ö. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º –∏–∑–≤–ª–µ–∫–∞—Ç—å —á–∞—Å—Ç–∏—á–∫–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö —É–¥–æ–±–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º. –°–º–æ—Ç—Ä–∏—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ!</p>"
    },
    {
      "title_en": "Basic types",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20by%20default%20this%20is%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20by%20default%20this%20is%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A",
      "content_en": "<p>Rust has a variety of familiar types <ul><li>booleans - <highlight>bool</highlight> for representing true/false</li><li>unsigned integers - <highlight>u8</highlight><highlight>u32</highlight><highlight>u64</highlight><highlight>u128</highlight> for representing positive whole numbers</li><li>signed integers - <highlight>i8</highlight><highlight>i32</highlight><highlight>i64</highlight><highlight>i128</highlight> for representing positive/negative whole numbers</li><li>pointer sized integers - <highlight>usize</highlight><highlight>isize</highlight> for representing indexes and sizes of things in memory</li><li>floating point - <highlight>f32</highlight><highlight>f64</highlight></li><li>text related - <highlight>str</highlight><highlight>char</highlight></li><li>tuple - <highlight>(value,value,...)</highlight> for passing fixed sequences of values on the stack<li>slices - <highlight>&[T]</highlight> for referencing views into sequences of values in memory</ul></p><p>We will be talking about a few of these in detail later.</p><p>Fair warning: text might be more complex than you are used to in other languages, since Rust is a systems programming language, it's oriented toward caring about memory issues you might not be used to. We will be going into detail on text later.</p><p>Note how numeric types can be explicitly specified by appending the type to the end of the number (e.g. <highlight>13u32</highlight>)</p>",
      "title_ie": "Basic tipes",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%0A%20%20%20%20let%20c%20%3D%204.3f64%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20frase%20%3D%20%22salute%20munde!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20frase%0A%20%20%20%20)%3B%0A%7D%0A",
      "content_ie": "<p>Rust possede un variet√° de tipes familiari <ul><li>booleanes - <highlight>bool</highlight> por representar true/false (ver/fals)</li><li>unsigned integers (integrales √≠nsignat) - <highlight>u8</highlight><highlight>u32</highlight><highlight>u64</highlight><highlight>u128</highlight> por representar integrales positiv</li><li>signed integers (integrales signat) - <highlight>i8</highlight><highlight>i32</highlight><highlight>i64</highlight><highlight>i128</highlight> por representar integrales sive positiv sive negativ</li><li>pointer sized integers (integrales con puntator-mesurat grandore) - <highlight>usize</highlight><highlight>isize</highlight> por representar indexes e grandores de coses in memorie</li><li>floating point (punctu flottant) - <highlight>f32</highlight><highlight>f64</highlight></li><li>con relation a textu - <highlight>str</highlight><highlight>char</highlight></li><li>tuple - <highlight>(value, value,...)</highlight> por passar fixat sequenties de valore sur li stack (li cumul)<li>slices (tranches) - <highlight>&[T]</highlight> por referer visus ad-in sequenties de valores in memorie</ul></p><p>Noi va parlar pri alcunes ex ili plu detalliatmen plu tard.</p><p>Un avise in prim: textu va posser esser plu complicat quam tui experientie con altri lingues, pro que Rust es un lingue de programmation por sistemas quel orienta se pri problemas de memorie con quel f√≥rsan tu ne ha experientie. Noi va parlar plu detalliatmen pri textu plu tard.</p><p>Nota qualmen on posse explicitmen specificar tipes numeric per afixar li tip directmen pos li numer√≥ (p.e. <highlight>13u32</highlight>)</p>",

      "title_de": "Basistypen",
      "content_de": "<p>Rust besitzt eine vielzahl an bekannten Datentypen <ul><li>booleans - <highlight>bool</highlight> f√ºr true/false bzw. wahr/falsch Werte</li><li>unsigned integers - <highlight>u8</highlight><highlight>u32</highlight><highlight>u64</highlight> f√ºr positive Ganzzahlen (inkl. 0 f√ºr die Mathematiker)</li><li>signed integers - <highlight>i8</highlight><highlight>i32</highlight><highlight>i64</highlight> f√ºr vorzeichenbehaftete Ganzzahlen</li><li>pointer sized integers - <highlight>uint</highlight><highlight>isize</highlight> f√ºr Indizes und Gr√∂√üen im Speicher</li><li>floating point - <highlight>f32</highlight><highlight>f64</highlight> f√ºr Dezimalzahlen</li><li>text zeug - <highlight>str</highlight><highlight>char</highlight></li><li>tuple - <highlight>(value,value,...)</highlight> zum √úbergeben von Wertsequenzen auf dem Stack<li>slices - <highlight>&[T]</highlight> um Views in Sequenzen zu referenzieren (hier evt bessere √úbersetzung finden)</ul></p><p>Wir sehen schon, dass es einiges zum Anpacken geben wird!</p><p>Eine Warnung vorweg: text-Zeug wird etwas komplexer sein als du es vielleicht von anderen Programmiersprachen gewohnt bist, da Rust eine Systemprogrammiersprache ist und daher mehr auf effektives Speichermanagement fokussiert. Keine Panik auf der Titanic aber, wir werden unser Bestes geben, dich darauf vorzubereiten!</p><p>Noch ein Hinweis: Numerische Datentypen k√∂nnen auch nach dem Zahlenliteral spezifiziert werden (z.B. <highlight>13u32</highlight>)</p>",

      "title_ru": "–ë–∞–∑–æ–≤—ã–µ —Ç–∏–ø—ã",
      "content_ru": "<p>Rust –∏–º–µ–µ—Ç –º–Ω–æ–≥–æ –∑–Ω–∞–∫–æ–º—ã—Ö —Ç–∏–ø–æ–≤: <ul><li>–±—É–ª–µ–≤—ã–µ - <highlight>bool</highlight> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç true/false</li><li>–±–µ–∑–∑–Ω–∞–∫–æ–≤—ã–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ - <highlight>u8</highlight><highlight>u32</highlight><highlight>u64</highlight><highlight>u128</highlight> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞</li><li>–∑–Ω–∞–∫–æ–≤—ã–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ - <highlight>i8</highlight><highlight>i32</highlight><highlight>i64</highlight><highlight>i128</highlight> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ/–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞</li><li>—Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Ä–∞–∑–º–µ—Ä–æ–º —É–∫–∞–∑–∞—Ç–µ–ª—è - <highlight>usize</highlight><highlight>isize</highlight> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç –∏–Ω–¥–µ–∫—Å—ã –∏ —Ä–∞–∑–º–µ—Ä—ã</li><li>—á–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π - <highlight>f32</highlight><highlight>f64</highlight></li><li>–æ—Ç–Ω–æ—Å—è—Ç—Å—è –∫ —Ç–µ–∫—Å—Ç—É - <highlight>str</highlight><highlight>char</highlight></li><li>–∫–æ—Ä—Ç–µ–∂–∏ - <highlight>(–∑–Ω–∞—á–µ–Ω–∏–µ,–∑–Ω–∞—á–µ–Ω–∏–µ,...)</highlight> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–π, —Ä–∞–∑–º–µ—â–∞—é—Ç—Å—è –Ω–∞ —Å—Ç–µ–∫–µ<li>slices - <highlight>&[T]</highlight> –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø–∞–º—è—Ç–∏</ul></p><p>–ú—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –∏–∑ –ø—É–Ω–∫—Ç–æ–≤ –≤ –¥–µ—Ç–∞–ª—è—Ö —á—É—Ç—å –ø–æ–∑–∂–µ.</p><p>–°–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: —Ç–µ–∫—Å—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–º, —á–µ–º –≤—ã –ø—Ä–∏–≤—ã–∫–ª–∏ –Ω–∞ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö, –ø–æ—Å–∫–æ–ª—å–∫—É Rust —è–≤–ª—è–µ—Ç—Å—è —è–∑—ã–∫–æ–º —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è, –æ–Ω –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω –Ω–∞ —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º, —Å–≤—è—Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –ø–∞–º—è—Ç—å—é, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –≤—ã, –≤–æ–∑–º–æ–∂–Ω–æ, –Ω–µ —Å—Ç–∞–ª–∫–∏–≤–∞–ª–∏—Å—å. –ú—ã –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–∑–∂–µ.</p><p>–ó–∞–º–µ—Ç—å—Ç–µ, –∫–∞–∫ —á–∏—Å–ª–∞ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É —Ç–∏–ø—É, –µ—Å–ª–∏ —è–≤–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ç–∏–ø –≤ –∫–æ–Ω—Ü–µ —á–∏—Å–ª–∞ (–ø—Ä–∏–º–µ—Ä <highlight>13u32</highlight>)</p>"
    },
    {
      "title_en": "Basic type conversion",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A",
      "content_en": "<p>Rust requires explicitness when it comes to numeric types. One cannot use a <highlight>u8</highlight> for a <highlight>u32</highlight> casually without error.</p><p>Luckily rust makes numeric type conversions very easy with the <b>as</b> keyword.</p>",
      "title_ie": "Conversion de basic tipes",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20let%20a%20%3D%2013u8%3B%0A%20%20let%20b%20%3D%207u32%3B%0A%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20let%20t%20%3D%20true%3B%0A%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D",
      "content_ie": "<p>Rust exige explicit√° quande it acte se pri tipes numeric. On ne posse usar un <highlight>u8</highlight> hasardalmen por un <highlight>u32</highlight> sin un erra.</p><p>Felicimen, conversiones de tipes numeric es facil in Rust con li clave-parol <b>as</b>.</p>",

      "title_de": "Basistypen konvertieren",
      "content_de": "<p>Rust vordert explizite Konvertierungen, wenn es um Zahlentypen geht. Ein <highlight>u8</highlight> (8-bit unsigned integer) kann nicht mit einem <highlight>u32</highlight> locker aus dem Handgelenk zusammengerechnet werden ohne das Programm zum Absturz zu bringen.</p><p>Gl√ºcklicherweise ist auf die Konvertierung mit dem <highlight>as</highlight> Schl√ºsselwort Verlass.</p>",

      "title_ru": "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –±–∞–∑–æ–≤—ã—Ö —Ç–∏–ø–æ–≤",
      "content_ru": "<p>Rust —Ç—Ä–µ–±—É–µ—Ç —è–≤–Ω–æ—Å—Ç–∏, –∫–æ–≥–¥–∞ —Ä–µ—á—å –∏–¥–µ—Ç –æ —á–∏—Å–ª–æ–≤—ã—Ö —Ç–∏–ø–∞—Ö. –ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å <highlight>u8</highlight> –≤–º–µ—Å—Ç–æ <highlight>u32</highlight> —Å–ª—É—á–∞–π–Ω–æ, —ç—Ç–æ –æ—à–∏–±–∫–∞.</p><p>–ö —Å—á–∞—Å—Ç—å—é, Rust –∏–º–µ–µ—Ç –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ <b>as</b>, –∫–æ—Ç–æ—Ä–æ–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ—á–µ–Ω—å –ª–µ–≥–∫–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—Ç—å —Ç–∏–ø—ã.</p>"
    },
    {
      "title_en": "Constants",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A",
      "content_en": "<p>Constants allow us to specify a common value that's used through out our code many times efficiently.  Instead of copying values like variables where they are used, constants directly replace the text identifier where they are used with their value at compile time.</p><p>Unlike variables, constants must always have explicit types</p><p>Constant names are always in <highlight>SCREAMING_SNAKE_CASE</highlight></p>",
      "title_ie": "Constantes",
      "code_ie": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Por%20crear%20un%20%7B%7D%20de%20pom%20desde%20li%20comense%2C%20on%20deve%20in%20prim%20crear%20un%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A",
      "content_ie": "<p>Constantes possibilisa li specification de valores comun quel noi usa tra nor code con un eficientie mult vezes plu grand.  Vice copiar valores quam variabiles chascun vez √∫ ili es usat, constantes remplazza li textu-identificator directmen con lor valore in li locs √∫ on usa les.</p><p>In contraste a variabiles, constantes deve sempre posseder un tip explicit</p><p>N√≥mines de constantes es sempre in <highlight>SCREAMING_SNAKE_CASE</highlight> (majuscules con infra-strecs)</p>",

      "title_de": "Konstanten",
      "content_de": "<p>Konstanten (<highlight>const</highlight>) erlauben uns einen Wert in der Kompilierzeit zu setzen, die in unserem Code eingesetzt werden. Kompilierzeit ist hier das Stichwort: anstelle von Variablen sitzen dann an Orten, an denen Konstanten eingestetzt werden, die Werte selbst.</p><p>Anders als bei Variablen muss bei Konstanten der Datentyp explizit angeben werden.</p><p>Die Namensgebung erfolgt generell in <highlight>SCREAMING_SNAKE_CASE</highlight>.</p>",

      "title_ru": "–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã",
      "content_ru": "<p>–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã (<b>const</b>) –ø–æ–∑–≤–æ–ª—è—é—Ç –Ω–∞–º —É–∫–∞–∑–∞—Ç—å –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–Ω–æ–≥–æ —Ä–∞–∑. –í–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–∞–∫ –¥–µ–ª–∞—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∏–º—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∑–∞–º–µ–Ω—è–µ—Ç—Å—è –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.</p><p>–í –æ—Ç–ª–∏—á–∏–∏ –æ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞–º –Ω—É–∂–Ω–æ —è–≤–Ω–æ –æ–±–æ–∑–Ω–∞—á–∞—Ç—å –∏—Ö —Ç–∏–ø.</p><p>–ò–º–µ–Ω–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç –≤—Å–µ–≥–¥–∞ –ø–∏—à—É—Ç—Å—è –≤ –≤–µ—Ä—Ö–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ <highlight>SCREAMING_SNAKE_CASE</highlight></p>"
    },
    {
      "title_en": "Chapter 1 Conclusion",
      "content_en": "<p>Nice job so far! The basics of Rust aren't so bad, right?  We're getting a peek into how the Rust compiler thinks.  It cares a lot about the size of values in memory, whether things can be modified or not, and making sure your math is what you want it to be. These are small previews of a principle of <b>safety</b> that is prevalent through Rust. The compiler just wants to make sure your code does what it expects! Next up we'll be looking at some old friends <highlight>if</highlight> and <highlight>for</highlight> loops.</p>",
      "title_ie": "Capitul 1 - Conclusion",
      "content_ie": "<p>Bon labor til nu! Li coses basic in Rust ne es tam mal, ne ver? Vi til nu un curt regarde pri qualmen pensa li compilator Rust. It sucia se mult pri li grandore de valores in memorie, qualmen on posse modificar un cose o ne, e si tui matematica es vermen to quel tu intente scrir o ne. Tis-ci es micri previsiones del principie de <b>safety</b> (securit√°) quel prevale tra Rust. Li compilator solmen intente far cert que tui code fa to quo tu intente que it fa! A sequer noi va vider li old amics <highlight>if</highlight> (si) e cicles usant <highlight>for</highlight> (por).</p>",

      "title_de": "Kapitel 1 Fazit",
      "content_de": "<p>Puh! Das w√§re schon mal geschafft! War nicht so √ºbel, oder? Wir wissen schon ein wenig, wie der Compiler denkt. Er setzt viel Wert auf Speichermanagement, wie gro√ü Variablen sind, ob diese \"mutable\" sind oder nicht, und ob du garantiert wei√üt, welche Datentypen zusammenaddiert werden. Das sind erste kleine Einblicke in die <b>Sicherheit</b>, die sich durch die gesamte Rustsprache hindurchzieht - nicht unbedingt die Sicherheit des Systems, aber die Sicherheit, dass du wei√üt, was du tust.</p><p>Im n√§chsten Kapitel werden wir uns mit den altbekannten Datenkontrollstrukturen <highlight>if</highlight> und <highlight>for</highlight> Schleifen besch√§ftigen! Worauf wartest du noch!</p>",

      "title_ru": "–†–∞–∑–¥–µ–ª 1. –ó–∞–∫–ª—é—á–µ–Ω–∏–µ",
      "content_ru": "<p>–•–æ—Ä–æ—à–∞—è —Ä–∞–±–æ—Ç–∞! –û—Å–Ω–æ–≤—ã Rust –Ω–µ —Ç–∞–∫ —É–∂ –∏ –ø–ª–æ—Ö–∏, –ø—Ä–∞–≤–¥–∞?  –ú—ã –ø–æ–ª—É—á–∏–ª–∏ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ —Ç–æ–º, –∫–∞–∫ –¥—É–º–∞–µ—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä Rust. –ï–º—É –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ –∑–Ω–∞—Ç—å —Ä–∞–∑–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –≤ –ø–∞–º—è—Ç–∏, –º–æ–≥—É—Ç –ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑–º–µ–Ω—è—Ç—Å—è –∏–ª–∏ –Ω–µ—Ç, –∏ –¥–µ–ª–∞–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤–µ–ª–∏ —Å–µ–±—è —Ç–∞–∫, –∫–∞–∫ –≤—ã –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–ª–∏. –≠—Ç–æ –º–∞–ª–µ–Ω—å–∫–æ–µ –ø—Ä–µ–≤—å—é –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ <b>–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏</b>(safety), –∫–æ—Ç–æ—Ä—ã–µ —Ç–∞–∫ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω—ã –≤ Rust. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—Å–µ–≥–æ –ª–∏—à—å —Ö–æ—á–µ—Ç, —á—Ç–æ –±—ã –≤–∞—à –∫–æ–¥ –¥–µ–ª–∞–ª —Ç–æ, —á—Ç–æ –≤—ã –æ–∂–∏–¥–∞–µ—Ç–µ! –î–∞–ª–µ–µ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é <highlight>if</highlight> –∏ —Ü–∏–∫–ª <highlight>for</highlight>.</p>"
    },
    {
      "title_en": "Chapter 2 - Basic Control Flow",
      "content_en": "<p>In this chapter let's talk about basic control flow methods in Rust. If you are familiar with C based languages you'll feel right at home and maybe enjoy a surprise or two.</p>",

      "title_de": "Kapitel 2 - Ein bisschen Kontrollfluss",
      "content_de": "<p>In diesem Kapitel werden wir Kontrollflussmethoden in Rust angehen (engl. control flow methods). Wenn du ein bisschen Erfahrung in C-verwandten Sprachen hast, d√ºrftest du dich hier wie zu Hause f√ºhlen - die ein oder andere √úberraschung sei dennoch zu erwarten.</p>"
    },
    {
      "title_en": "if/else if/else",
      "content_en": "<p>Code branching in Rust is not surprising.</p><p>Conditions don't have parentheses! Did we ever really need them? Our logic now looks nice and clean.</p><p>All your usual logical operators still work: <highlight>!</highlight><highlight>!=</highlight><highlight>||</highlight><highlight>&&</highlight><highlight>&lt;</highlight><highlight>&gt;</highlight><highlight>&lt;=</highlight><highlight>&gt;=</highlight></p>",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=pub%20fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20return%20-1%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20return%200%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20return%201%3B%0A%20%20%20%20%7D%0A%7D%0A",

      "title_de": "if/else if/else",
      "content_de": "<p>Codeverzweigungen (branching) bieten viel bekanntes.</p><p>Au√üer den fehlenden Klammern! Wer braucht die schon? Logik war noch nie so sauber.</p><p>Die √ºblichen logischen Operatoren funktionieren noch: <highlight>!</highlight><highlight>!=</highlight><highlight>||</highlight><highlight>&&</highlight><highlight>&lt;</highlight><highlight>&gt;</highlight><highlight>&lt;=</highlight><highlight>&gt;=</highlight></p><p>Versuch ein paar von den Operatoren in dem Code einzubauen.</p>",
      "code_de": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=pub%20fn%20main()%20%7B%0A%20%20%20%20let%20age%20%3D%2017%3B%0A%20%20%20%20%0A%20%20%20%20if%20age%20%3C%2016%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Keine%20alkoholischen%20Getr%C3%A4nke%22)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%7D%20else%20if%20age%20%3E%3D%2016%20%26%26%20age%20%3C%2018%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20checking%20(age%20%3E%3D%2016)%20could%20have%20been%20omitted%20here%0A%20%20%20%20%20%20%20%20println!(%22Darf%20Bier%2C%20Wein%20und%20Sekt%20kaufen.%20Keine%20Spirituosen%22)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Darf%20alles%20kaufen%22)%3B%0A%20%20%20%20%7D%0A%7D%0A"
    },
    {
      "title_en": "loop",
      "content_en": "<p>Need an infinite loop?</p><p>Rust makes it easy.</p><p><highlight>break</highlight> will escape a loop when you are ready.</p><p><highlight>loop</highlight> has a secret we'll talk about soon.</p>",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A",

      "title_de": "loop",
      "content_de": "<p>Unendliche Schleifen gef√§llig? <highlight>loop</highlight> macht es m√∂glich!</p><p>Mit <highlight>break</highlight> kann diese Schleife unterbrochen werden.</p>",
      "code_de": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%20%22%2C%20x)%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A"
    },
    {
      "title_en": "while",
      "content_en": "<p><highlight>while</highlight> lets you easily add a condition to a loop.</p><p>If the condition evaluates to <highlight>false</highlight>, the loop will exit.</p>",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A",

      "title_de": "while",
      "content_de": "<p><highlight>while</highlight> Schleifen werden so lange ausgef√ºhrt, bis aus der angegeben Kondition <highlight>false</highlight> evaluiert wird.</p>"
    },
    {
      "title_en": "for",
      "content_en": "<p>Rust's <highlight>for</highlight> loop is a powerful upgrade. It iterates over values from any expression that evaluates into an iterator. What's an iterator? An iterator is an object that you can ask the question \"What's the next item you have?\" until there are no more items.</p><p>We'll explore this more in a future chapter, in the meantime just know Rust makes it easy to create iterators that generate a sequence of integer numbers.</p><p>The <highlight>..</highlight> operator creates an iterator that generates numbers from a start number up to but not including an end number.</p><p>The <highlight>..=</highlight> operator creates an iterator that generates numbers from a start number up to and including an end number.</p>",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A",

      "title_de": "for",
      "content_de": "<p><highlight>for</highlight>-Schleifen in Rust sind ein gro√ües Upgrade. Wird ein Ausdruck (expression) in einen Iterator evaluiert, kann dieser in eine for-Schleife eingebaut werden.</p><p>Was ist ein Iterator? Ein Iterator ist ein Objekt, dem die Frage \"Was kommt als n√§chstes?\" gestellt werden kann. Sind keine Elemente mehr vorhanden, wird die Schleife abgebrochen.</p><p>In diesem Beispiel sehen wir, wie in Rust eine Zahlensequenz erstellt wird, √ºber die wir iterieren k√∂nnen. Hierbei gibt es zwei unterschiedliche Notationen:</p><p><ul><li><highlight>x..y</highlight> erstellt einen Iterator, der bei <highlight>x</highlight> anf√§ngt und <b>vor</b> <highlight>y</highlight> aufh√∂rt (exklusives <highlight>y</highlight> also)</li><li><highlight>x..=y</highlight> erstellt einen Iterator, der bei <highlight>x</highlight> anf√§ngt und <b>mit</b> <highlight>y</highlight> aufh√∂rt (inklusives <highlight>y</highlight>)</li></ul></p>",
      "code_de": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20print!(%220..5%20%3A%22)%3B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%20%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20print!(%22%5Cn0..5%3D%3A%22)%3B%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%20%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A"
    },
    {
      "title_en": "match",
      "content_en": "<p>Miss your switch statement? Rust has an incredibly useful keyword for matching all possible conditions of a value and executing a code path if the match is true. Let's see how this works for numbers. We will have more to say in future chapters on pattern matching more complex data, I promise you it will be worth the wait.</p><p><highlight>match</highlight> is exhaustive so all cases must be handled.</p><p>Matching combined with destructuring is by far one of the most common patterns you will see in all of Rust.</p>",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20multiple%20values%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%201%20or%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20iterators%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20a%20number%203%20to%209%20inclusively%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20bind%20the%20matched%20number%20to%20a%20variable%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20%7B%7D%20number%20between%2010%20to%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20this%20is%20the%20default%20match%20that%20must%20exist%20if%20not%20all%20cases%20are%20handled%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20something%20else!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A",

      "title_de": "match",
      "content_de": "<p>Du vermisst dein Switch Statement? Rust l√§sst dich nicht im Stich!</p><p>Mittels <highlight>match</highlight> k√∂nnen Werte mit allen m√∂glichen Konditionen und Werten verglichen werden. Konditionen ist hier vielleicht das interessanteste. Kein stupides Vergleichen, ob zwei Werte eins zu eins √ºbereinstimmen.</p><p>Hier sehen wir das \"matching\" auf die Zahl <highlight>x</highlight> angewandt.</p><p><highlight>match</highlight> in Rust ist <b>exhaustive</b> (ersch√∂pfend). Das bedeuted, dass jeder m√∂gliche Wert getested werden muss, den die Variable annehmen kann. Was in manchen Programmiersprachen als <b>default</b> bekannt ist, ist hier durch ein einfaches Unterstrich gegeben.</p><p>Hier sei schon mal erw√§hnt, dass ein destructuring in Kombination mit match unglaublich viel Anwendung in der Sprache findet. Zu viel f√ºr ein Einf√ºhrungskapitel leider, weshalb wir uns daf√ºr etwas gedulden m√ºssen.</p>"
    },
    {
      "title_en": "Returning values from block expressions",
      "content_en": "<p><highlight>if</highlight>,<highlight>loop</highlight>,<highlight>match</highlight>,functions, and scope blocks all have a unique way of returning values in Rust.</p><p><highlight>loop</highlight> can break to return a value.</p><p>If the last statement in an <highlight>if</highlight>,<highlight>loop</highlight>, <highlight>match</highlight>, function, or scope block is an expression without a <highlight>;</highlight>, Rust will return it as a value from the block. This is a great way to create concise logic that returns a value that can be put into a new variable.</p><p>Notice that is also allows an <highlight>if</highlight> statement to operate like a concise ternary expression.</a>",
      "code": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22found%20the%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22from%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20let%20food%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22is%20hotdog%22%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22is%20not%20hotdog%22%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifying%20food%3A%20%7B%7D%22%2C%20%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22from%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A",

      "title_de": "R√ºckgabewerte aus Blockausdr√ºcken",
      "content_de": "<p>Als <b>Block</b> wird in Rust ein Codest√ºck zwischen zwei geschweiften Klammern bezeichnet (<highlight>{ /* code block */ }</highlight>).</p><p>Hier ist eine Besonderheit in Rust: Blockausdr√ºcke, die in <highlight>if</highlight>,<highlight>loop</highlight>, Funktionen etc. zu finden sind, k√∂nnen Werte zur√ºckgeben (return).</p><p><highlight>loop</highlight> kann mittels <highlight>break</highlight> den Wert returnen.</p><p>Noch etwas idiomatisches in Rust: wenn die letzte Zeile in einem solchen Codeblock ein Ausdruck (expression) ohne <highlight>;</highlight> am Ende ist, interpretiert Rust dies als den R√ºckgabewert.</p><p>F√ºr Leute, die ein Fan von ternary Operatoren sind und das Fragezeichensymbol in Rust vermissen, <highlight>if</highlight> Statements bilden dazu die Alternative.</p>",
      "code_de": "https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%2213%20gefunden!%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22aus%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22aus%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20let%20food%20%3D%20%22nutella%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22nutella%22%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%22ist%20nutella%22%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22nein%2C%20das%20ist%20keine%20nutella%22%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Essen%20identifizieren%3A%20%7B%7D%22%2C%20%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22aus%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22aus%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A"
    },
    {
      "title_en": "Chapter 2 Conclusion",
      "content_en": "<p>And that's it for now! Hopefully I've shown a glimpse of Rust's power even in the most basic statements. We'll be talking about <highlight>for</highlight> and <highlight>match</highlight> even more in depth as we gain more knowledge that can utilize their capabilities. Next time we'll get into Rust's foundational data structures.</p>",

      "title_de": "Kapitel 2 Fazit",
      "content_de": "<p>Was? Das war's schon?</p><p>Keine Bange, es gibt noch viel zu erforschen! Insbesondere <highlight>match</highlight> wurde hier au√üer Acht gelassen, das viele m√§chtige Features beinhaltet, dementsprechend aber auch etwas mehr Hintergrundwissen erfordert.</p><p>Im n√§chsten Kapitel werden wir uns daf√ºr ein bisschen in die Datenstrukturen (data structures) von Rust einarbeiten. Worauf warten wir noch?</p><p>(eine √úbersetzung? ok, die Ausrede ist legitim...)</p>"
    }
  ]
}
