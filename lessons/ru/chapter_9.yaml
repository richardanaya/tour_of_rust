- title: Глава 9 - Организация и структура проекта (Project Organization and Structure)
  content_markdown: >
    До этого момента все наши примеры кода находились в единственном файле.
    Давайте обсудим, как можно лучше оорганизовать и делиться кодом с другими!
- title: Модули (Modules)
  content_markdown: |
    Каждая Rust программа или библиотека является *crate* (крейтом).

    Каждый крейт (crate) сделан из иерархии *модулей* (modules), которые могут быть программами или библиотекой.

    Каждый крейт имеет корневой модуль (root module).

    Модуль содержит глобальные переменные, функции, структуры, типажи и даже другие модули!

    В Rust нет "1 в 1" отображения файлов на древовидную, иерархическую структуру модуля. Мы сами должны
    создать дерево модулей явным образом "в ручную" в вашем коде.
- title: Написание программы (Writing a Program)
  content_markdown: |
    Программа имеет корневой модуль в файле, с названием `main.rs`.
- title: Написание библиотеки (Writing a Library)
  content_markdown: |
    Библиотека имеет корневой модуль в файле, с названием `lib.rs`.
- title: Подключение других модулей и крейтов (Referencing Other Modules and Crates)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
  content_markdown: >
    На элементы из модуля можно ссылаться, подключая их в коде с помощью полного, модульного пути,
    например `std::f64::consts::PI`.


    Использование ключевого слова **use** является более простым способом.
    Он позволяет указать определенные элементы модуля, которые мы хотим использовать
    в коде без указания полного пути. Например `use std::f64::consts::PI`
    позволяет использовать короткий идентификатор `PI` в функции main.


    **std** является крейтом **standard library** (стандартной библиотеки) Rust, которая
    полна полезных структур данных для взаимодействия с вашей операционной системой.


    Каталог для поиска множества полезных крейтов, созданных сообществом, можно найти по адресу
    [https://crates.io](https://crates.io/).
- title: Подключение нескольких элементов (Referencing Multiple Items)
  content_markdown: |
    Можно подключить несколько элементов из одного модульного пути так:

    ```rust
    use std::f64::consts::{PI,TAU}
    ```

    Феррис не кушает TAU, от кушает только PI.
- title: Создание модулей (Creating Modules)
  content_markdown: |
    Когда мы думаем о коде, мы обычно представляем себе иерархию файлов огранизованную
    в директориях. Rust позволяет создавать модули близко похожие на файловую структуру.

    В Rust есть два способа для объявления модуля. Например, модуль `foo` может быть
    представлен как:
      * файл с именем `foo.rs`
      * каталог с именем `foo` с файлом `mod.rs` внутри
- title: Иерархия модуля (Module Hierarchy)
  content_markdown: >
    Модуль может зависеть от другог модуля. Для установки отношений между модулем и
    его под-модулем, вы должны написать в родительском модуле:


    ```rust

    mod foo;

    ```


    Объявление выше будет искать файл с именем `foo.rs` или `foo/mod.rs`
    и вставит содержимое внутрь модуля с именем `foo` в текущей области видимости.
- title: Встроенный модуль (Inline Module)
  content_markdown: >
    Подмодуль может быть напрямую встроен внутрь кода модуля.


    Одно очень частое использование модулей это создание юнит тестов. Мы создаем
    встроенный модуль, который существует только когда Rust используется для тестирования!


    ```

    // Данный макрос удаляет этот встроенный модуль,

    // когда Rust не в режиме тестирования.

    #[cfg(test)]

    mod tests {
        // Заметьте, что мы не можем сразу получить доступ к
        // родительскому модулю. Его нужно указывать явно.
        use super::*;

        ... tests go here ...
    }

    ```
- title: Ссылка на встроенный модуль (Internal Module Referencing)
  content_markdown: >
    Rust имеет несколько ключевых слов, которые можно использовать для
    `use` (использования) пути в случае быстрого получения доступа к нужному
    модулю:

    * `crate` - корневой модуль вашего крейта

    * `super` - родительсвкий модуль вашего текущего модуля

    * `self` - текущий модуль
- title: Экспорт (Exporting)
  content_markdown: >
    По умолчанию элементы *module* (модуля) недоступны вне этого модуля
    (даже для модулей наследников!). Элементы модуля можно сделать "видимыми" или
    доступными, используя ключевое слово `pub`.


    Также элементы *crate* (крейта) недоступны по умолчанию вне этого крейта. Их
    можно сделать доступными с помощью ключевого слова `pub` в *root module* (корневом модуле)
    крейта (`lib.rs` или `main.rs`).
- title: Область видимости структур (Structure Visibility)
  content_markdown: >
    Подобно функциям, структуры можно объявить так, что они будут видны снаружи своих
    модулей с помощью `pub`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20SeaCreature%20struct%20will%20be%20usable%20outside%20of%20our%20module%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20let's%20keep%20our%20weapon%20private%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
- title: Автоимпорт (Prelude)
  content_markdown: |
    Вам может быть интересно, как везде в коде мы получили доступ к типам `Vec` или `Box`
    без использования `use` для их подключения?
    Это по причине использования модуля `prelude` (автоимпорт) из стандартной библиотеки.


    Знайте, что в стандартной библиотеке Rust все типы, которые экспортируются с помощью
    `std::prelude::*` являются автоматически доступными в каждой части Rust.
    В данном случае типы `Vec` и `Box`, но и другие (Option, Copy, etc.).
- title: Ваш собственный автоимпорт (Your Own Prelude)
  content_markdown: >
    Из-за наличия автоимпорта в стандартной библиотеке, ваша библиотека обычно имеет
    собственный автоимпорт в качестве начальной точки, где пользователи должны импортировать
    все наиболее общие структуры данных для использования вашей библиотеки
    (например `use my_library::prelude::*`).

    Автоимпорт не используется автоматически в программах/библиотеках, которые используют ваш крейт,
    но это является хорошим соглашением, чтобы люди знали, с чего начать.


    Феррис говорит: "Будь хорошим разработчиком и помоги другим удобным автоимпортом!"
- title: Глава 9 - Заключение
  content_markdown: >
    Теперь вы знаете несколько хитростей к моменту, когда дело дойдет до создания приложений и библиотек
    Rust, готовых для всего мира.

    Не беспокойтесь о том, чтобы их все запомнить. По мере роста вашей библиотеки и использования ее
    другими пользователями, вы найдете то что лучше всего работает на каждом этапе.


    Ресурсы:

    - [Руководство по написанию Rust API - англ.](https://rust-lang.github.io/api-guidelines/)
