- title: Глава 6 - Текст
  content_markdown: >
    Теперь, когда мы немного понимаем то, как Rust думает о памяти, мы готовы
    поговорить более подробно о тексте.

    Rust серьезно заботится о поддержке международных текстов, и поддрежке на уровне байтов,
    с которыми вы, возможно, не знакомы на других языках.

    Что говорит, что в Rust есть много отличных инструментов для управления
    этими проблемами.
- title: Тип строковые литералы (String Literals)
  content_markdown: >
    Строковые литералы Rust всегда в кодировке Unicode.


    Типом строковых литералов всегда является описание `&'static str`:


    * `&` означает это ссылка на место в памяти, у нее нет
    `&mut` и это означает, что компилятор не позволит делать изменения

    * `'static` означает, что строковые данные будут доступны с начала и
    до конца нашей программы (они никогда не удаляются)

    * тип `str` означает, что он указывает на последовательность байтов, которые
    являются всегда действительный текст в **utf-8** кодировке


    Тонкости памяти:

    * Компилятор Rust скорее всего разместит эту строку в памяти сегмента данных
     вашей программы
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
- title: Что такое utf-8
  content_markdown: "Поскольку на компьютерах использовалось все больше языков, то миру нужно было представлять больше текстовых символов,\nчем допускала кодировка ASCII (где 1 байт допускал хранение только 256 символов).\n\n**utf-8** кодировка была введена с переменной длиной в 1-4 байта, значительно увеличивая диапазон возможных символов.\n\nПреимуществом символов переменного размера является то, что текст не имеет ненужных байт для очень распространенной кодировки ASCII (для нее все также требуется только 1 байт в **utf-8**).\n\nНедостатком символов переменного размера является то, что поиск символов больше не может быть выполнен быстро \n(За постоянное время **O(1)**) простой индексацией (например, `my_text[3]` для получения 4-го символа). Вполне возможно, что \nпредшествующие символы могли иметь переменную ширину, влияя на место где 4-й символ фактически начинается в последовательности байт.\n\nВместо этого нам нужно пройти последовательность **utf-8** байт, чтобы понять, где на самом деле Unicode символы начинаются (за линейное время **O(n)**).\n\nFerris: \"Я в основном счастлив иметь **utf-8** для представления смайликов моих подводных друзей.\"\n\n<span class=\"emoji\">\U0001F420\U0001F419\U0001F41F\U0001F42C\U0001F40B</span>\n"
- title: Экранирующие символы (Escaping Characters)
  content_markdown: >
    Некоторые символы сложно представлять визуально, поэтому
    **экранирующие коды** (escape codes) позволяют размещать
    такие символы на их месте


    Rust поддерживает общие экранирующие коды взятые из Cи-подобных яызков:

    * `\n` - новая строка

    * `\r` - возврат каретки

    * `\t` - табуляция

    * `\\` - обратный слэш

    * `\0` - null

    * `\'` - одна кавычка


    Полный список смотрите по ссылке
    [здесь](https://doc.rust-lang.org/reference/tokens.html).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22Ferris%20says%3A%5Ct%5C%22hello%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
- title: Многострочные строковые литералы (Multi-line)
  content_markdown: |
    Строки в Rust являются по умолчанию многострочными.

    Используйте символ `\` в конце строки, если не хотите разрыва строки.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26'static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20I%20write%2C%20erase%2C%20rewrite%0A%20%20%20%20%20%20%20%20Erase%20again%2C%20and%20then%0A%20%20%20%20%20%20%20%20A%20poppy%20blooms.%0A%20%20%20%20%20%20%20%20-%20Katsushika%20Hokusai%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22hello%20%5C%0A%20%20%20%20world%22)%20%2F%2F%20notice%20that%20the%20spacing%20before%20w%20is%20ignored%0A%7D%0A
- title: Сырые (необработанные) строковые литералы (Raw String Literals)
  content_markdown: >
    Необработанные строки позволяют написать дословно последовательность символов,
    начиная ее символом `r#" `и заканчивая` символом "#`. Это позволяет вставлять символы,

    которые в противном случае могли бы сбивать с толку обычные литеральные
    строки (например, двойные кавычки и обратная косая черта).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Raw%20strings%20are%20useful%20for%20some%20situations.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A
- title: Строковые литераты из файлов
  content_markdown: >
    Если у вас есть очень большой, попробуйте использовать макрос `include_str!`
    для включения текста из локальных файлов в вашу программу:


    ```rust

    let 00_html = include_str!("00_en.html");

    ```
- title: Строковые срезы (String Slice)
  content_markdown: >
    Строковым срезом является ссылка на последовательность байт в памяти,
    которые всегда должны быть действительными символами в кодировке utf-8.


    Строковый срез (саб-срез) от среза `str`, также должен быть действительным в utf-8.


    Общие методы типа `&str`:

    * `len` возвращает длину строкового литерала в байтах (а не количества символов)

    *  `starts_with`/`ends_with` для базового тестирования (начинается с, заканчивается на).

    * `is_empty` возвращает true, если строка имеет нулевую длину.

    * `find` возвращает тип `Option<usize>` первой позиции некоторого текста.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20first_word%20%3D%20%26a%5B0..2%5D%3B%0A%20%20%20%20let%20second_word%20%3D%20%26a%5B3..7%5D%3B%0A%20%20%20%20%2F%2F%20let%20half_crab%20%3D%20%26a%5B3..5%5D%3B%20FAILS%0A%20%20%20%20%2F%2F%20Rust%20does%20not%20accept%20slices%20of%20invalid%20unicode%20characters%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20first_word%2C%20second_word)%3B%0A%7D%0A
- title: Символы (Chars)
  content_markdown: >
    Несмотря на большие трудности при работе с Unicode, Rust предлагает способ
    получить последовательность utf-8 байт как вектор символов типа `char`.


    Длина `char` всегда 4 байта (для эффективного поиска отдельных символов).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20collect%20the%20characters%20as%20a%20vector%20of%20char%0A%20%20%20%20let%20chars%20%3D%20%22hi%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20should%20be%204%0A%20%20%20%20%2F%2F%20since%20chars%20are%204%20bytes%20we%20can%20convert%20to%20u32%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A
- title: Строковый тип (String)
  content_markdown: >
    Тип **String** является структурой, которая владеет последовательностью utf-8 байтов в куче.


    Так как эта память в куче, то ее можно расширять, изменять и т.д. способами,
    которые не доступны для типа строковых литералов.


    Общие методы:


    * `push_str` добавить больше utf-8 байт к концу строки.

    * `replace` заменить последовательности utf-8 байт на другие.

    * `to_lowercase`/`to_uppercase` изменение регистра.

    * `trim` для уменьшения места


    Когда String удаляется, ее память в куче также удаляется.


    Тип `String` имеет оператор `+`, увеличивающий строку другой `&str` и
    возвращающий саму себя, но это может быть не так эргономично, как вы надеетесь.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20helloworld%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%20%20%20%20helloworld.push_str(%22%20world%22)%3B%0A%20%20%20%20helloworld%20%3D%20helloworld%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%7D%0A
- title: Текст как параметр функции (Function Parameter)
  content_markdown: >
    Строковые литералы и строки обычно передаются в функции в виде среза строк.
    Это обеспечивает большую гибкость в большинстве сценариев,

    когда вам фактически не нужно передавать параметр во владение.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20borrow%20%26%27static%20str%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%22hello%22)%3B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20also%20borrow%20String%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22goodbye%22))%3B%0A%7D%0A
- title: Создание строк
  content_markdown: |
    Методы `concat` и `join` являются двумя простыми, но мощными способами для создания строк.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22hello%22%2C%20%22%20%22%2C%20%22world%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A
- title: Форматирование строк (Formatting)
  content_markdown: >
    Макрос `format!` позволяет создать строку, с помощью определения параметризованной
    строки с заполнителями, указывающими где и как нужно разместить фактические значения
    (например заполнитель `{}`).


    `format!` использует такие же параметризованные строки как и макрос `println!`


    Возможности данного макроса являются слишком обширными для *Tour of Rust*;
    проверьте документацию [здесь](https://doc.rust-lang.org/std/fmt/).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22secret%20to%20life%3A%20%7B%7D%22%2Ca)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cf)%3B%0A%7D%0A
- title: Преобразование строк (Converting Strings)
  content_markdown: |
    Многие типы могут быть преобразованы в тип строки используя метод `to_string`.

    Обобщеную функцию `parse` можно использовать для преобразования строк
    или строковых литералов в типизированное значение. Данная фунция
    возвращает тип `Result`, потому что преобразование может завершится ошибкой.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
- title: Глава 6 - Заключение
  content_markdown: >
    Теперь у вас есть базовые знания про текст! Как вы увидели, Unicode делает
    работу с текстом немного каверзной, но стандартная библиотека

    обладает множеством функциональных возможностей, которыми легко управлять.


    До сих пор мы в основном смотрели на Rust с точки зрения процедурной
    парадигмы (т.е. только функции и данные),

    но теперь пришло время поговорить о типажах и возможностях,
    раскрытых объектно-ориентированной парадигмой Rust.
