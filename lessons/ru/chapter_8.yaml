- title: Chapter 8 - Smart Pointers
  content_markdown: >
    В этой главе мы проясним "умные указатели". Давайте изучим эти структуры
    данных, позволяющие взаимодействовать с самыми нижними уровнями памяти.


    Феррис говорит: "Не смущайтесь этой главы, если вы чувствуете, что не можете
    писать свой код для низко-уровневого управления памятью после короткого чтения.
    Данная глава это в основном введение в некоторые полезные инструменты и чтобы
    дать представление о том, как они работают!"
- title: Ссылки снова (References Revisited)
  content_markdown: >
    Ссылка является по сути только числом, которое указывает на начальную
    позицию некоторых байт в памяти. Единственная их цель представить концепцию
    того, где находятся данные указанного типа.
    Ссылка отличается от простого числа в Rust только тем, что компилятор будет проверять
    время жизни ссылки, что она не живет дольше, чем то, на что она ссылается
    (иначе мы получим ошибку при использовании такой ссылки!).
- title: Сырые указатели (Raw Pointers)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20memory_location%20%3D%20%26a%20as%20*const%20i32%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20is%20here%20%7B%7D%22%2C%20memory_location)%3B%0A%7D%0A
  content_markdown: >
    Ссылки можно сконвертировать в более примитивные типы, называемые
    *raw pointer* (сырой указатель). Почти как с числом, его можно копировать и
    передавать с небольшими ограничениями.

    Rust не дает никаких гарантий относительно того места памяти, на которое он указывает.


    Существует два типа сырых указателей:


    * `*const T` - сырой указатель на данные типа T, которые никогда не должны меняться.

    * `*mut T` - сырой указатель на данные типа T, которые могут меняться.


    Сырые указатели могут быть сконвертированы "из" или "в" числа (например, `usize`).


    Сырые указатели могут обращаться к данным с помощью *unsafe* кода (детальнее позже).


    Детали для запоминания:

    * Ссылка в Rust очень похожа на указатель в Cи с точки зрения использования,
    но имеет гораздо большие ограничения во время компиляции относительно того,
    как она может храниться и перемещаться в другие функции.

    * Сырой указатель в Rust похож на указатель в Cи в том смысле, что он
    представляет число, которое можно скопировать, передать и даже превратить в числовые типы,
    где его можно изменить как число для выполнения вычислений над указателем.
- title: Разыменование (Dereferencing)
  content_markdown: |
    Процесс доступа/изменения данных на которые ссылается *ссылка* (reference)
    (например `&i32`) называется *разыменованием* (dereferencing).

    Ссылки используются для доступа/изменения данных двумя способами:
    * Доступ к данным по ссылке при назначении данных переменным.
    * Доступ к полям и методам ссылочных данных (доступных по ссылке).

    В Rust есть несколько мощных операторов, которые позволяют это делать.
- title: Оператор * (звездочка)
  content_markdown: >
    Оператор `*` является явным способом разыменовать ссылку.


    ```rust

    let a: i32 = 42;

    let ref_ref_ref_a: &&&i32 = &&&a;

    let ref_a: &i32 = **ref_ref_ref_a;

    let b: i32 = *ref_a;

    ```


    Детали для запоминания:

    - Так как i32 является примитивным типом, который реализует типаж `Copy`,
    байты из переменной `a` в стеке копируются в байты переменной `b`.
- title: Оператор . (точка)
  content_markdown: >
    Оператор `.` используется для доступа к полям и методам ссылки. Он работает
    более тонко.


    ```rust

    let f = Foo { value: 42 };

    let ref_ref_ref_f = &&&f;

    println!("{}", ref_ref_ref_f.value);

    ```

    Опа, почему нам не нужно добавлять `***` (три звездочки) перед `ref_ref_ref_f`? Это потому, что
    оператор `.` автоматически разыменовывает последовательность ссылок.
    Последняя строка превращена компилятром в следующий код автоматически.


    ```rust

    println!("{}", (***ref_ref_ref_f).value);

    ```
- title: Умные указатели (Smart Pointers)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aops%3A%3ADeref%3B%0Astruct%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0Aimpl%3CT%3E%20Deref%20for%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20was%20used!%22%2C%20std%3A%3Aany%3A%3Atype_name%3A%3A%3CT%3E())%3B%0A%20%20%20%20%20%20%20%20%26self.value%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20TattleTell%20%7B%0A%20%20%20%20%20%20%20%20value%3A%20%22secret%20message%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%2F%2F%20dereference%20occurs%20here%20immediately%20%0A%20%20%20%20%2F%2F%20after%20foo%20is%20auto-referenced%20for%20the%0A%20%20%20%20%2F%2F%20function%20%60len%60%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.len())%3B%0A%7D%0A
  content_markdown: >
    В дополнение к возможности создания ссылок к известным типам данных используя оператор
    `&`, Rust предоставляет возможность создания *структур похожих на ссылки* (reference-like)
    называемых **умные указатели** (smart pointers).


    Можно думать об этих ссылках на более высоком уровне, как о типах, которые предоставляют доступ
    к другим типам. Умные указатели по своему поведению отличаются от обычных ссылок тем, что
    они работают на основе внутренней логики, описываемой разработчиком. Вы как разработчик -
    это *умная* часть этих указателей.


    Обычный умный указатель реализует типажи `Deref`, `DerefMut` и `Drop` для определения
    логики того, что должно происходить, когда структура разыменована с помощью операторов `*` и `.`
- title: Умный небезопасный код (Smart Unsafe Code)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%5Bu8%3B%204%5D%20%3D%20%5B86%2C%2014%2C%2073%2C%2064%5D%3B%0A%20%20%20%20%2F%2F%20this%20is%20a%20raw%20pointer.%20Getting%20the%20memory%20address%0A%20%20%20%20%2F%2F%20of%20something%20as%20a%20number%20is%20totally%20safe%0A%20%20%20%20let%20pointer_a%20%3D%20%26a%20as%20*const%20u8%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20memory%20location%3A%20%7B%7D%22%2C%20pointer_a)%3B%0A%20%20%20%20%2F%2F%20Turning%20our%20number%20into%20a%20raw%20pointer%20to%20a%20f32%20is%0A%20%20%20%20%2F%2F%20also%20safe%20to%20do.%0A%20%20%20%20let%20pointer_b%20%3D%20pointer_a%20as%20*const%20f32%3B%0A%20%20%20%20let%20b%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20unsafe%20because%20we%20are%20telling%20the%20compiler%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20assume%20our%20pointer%20is%20a%20valid%20f32%20and%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it's%20value%20into%20the%20variable%20b.%0A%20%20%20%20%20%20%20%20%2F%2F%20Rust%20has%20no%20way%20to%20verify%20this%20assumption%20is%20true.%0A%20%20%20%20%20%20%20%20*pointer_b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22I%20swear%20this%20is%20a%20pie!%20%7B%7D%22%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Умные указатели часто используют *небезопасный* (unsafe) код. Как говорилось ранее,
    они являются общими инструментами для взаимодействия с самыми низкими уровнями памяти в
    Rust.


    Что такое небезопасный (unsafe) код? Небезопасный ведет себя точно как обычный Rust код
    с исключением нескольких возможностей, о которых компилятор не может предоставить гарантии.


    Основной возможностью небезопасного кода является *разыменование сырого указателя*
    (dereferencing a raw pointer). Это означает взятие *сырого указателя* на позицию памяти,
    объявление "здесь существует структура данных" и превращение ее в представления другого типа данных,
    которые можно использовать (например, `*const u8` в `u8`).

    В Rust нет способа следить за каждым из байтов, записываемым в память. Так как
    Rust не может дать гарантии, что именно существует за произвольным числом, использованным
    как *сырой указатель* (raw pointer), то необходимо поместить данное разыменование в
    `unsafe { ... }` блок.


    Умные указатели *разыменовывают сырые указатели* экстенсивно, но они хорошо зарекомендовали
    себя в том, что они делают
- title: Знакомые друзья (Familiar Friends)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20let's%20ask%20for%204%20bytes%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20allocate%20and%20save%20the%20memory%20location%20as%20a%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20use%20pointer%20math%20and%20write%20a%20few%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20u8%20values%20to%20memory%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20interpret%20secret_recipe%20pointer%20as%20a%20f32%20raw%20pointer%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it%20into%20a%20return%20value%20%26f32%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20%22make%20a%20pie%22%20by%20dereferencing%20our%20%0A%20%20%20%20%2F%2F%20Pie%20struct%20smart%20pointer%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A
  content_markdown: >
    Рассмотрим некоторые умные указатели, которые мы уже видели, вроде `Vec<T>` и `String`.


    `Vec<T>` является умным указателем, который владеет некоторым регионом байт памяти. Компилятор
    Rust не имеет понятия, что находится в этих байтах.
    Умный указатель интерпретирует их, что означает захват элементов из этой управляемой памяти,
    отслеживание где начинаются и заканчиваются структуры данных в этих байтах и затем,
    наконец, разыменовывание сырого указателя на структуры данных в виде красивого, чистого, эргономичного
    интерфейса, который можно использовать (например `my_vec[3]`).


    Аналогично `String` отслеживает область байт памяти, программно ограничивает записанное в её
    содержимое так, чтобы оно было всегда допустимым `utf-8` символом и помогает разыменовать
    эту область памяти в тип `&str`.


    Обе эти структуры используют небезопасное разыменование сырых указателей для выполнения своей работы.


    Детали для запоминания:

    * В Rust есть эквивалент Cи функции `malloc`, можно использовать
    [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) и
    [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html) для
    владения и управления собственными областями памяти.
- title: Память, выделяемая в куче (Heap Allocated Memory)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A
  content_markdown: >
    Тип `Box` является умным указателем, позволяющим переместить данные из стека в кучу.


    Его разыменование позволяет использовать выделенную память эргономически, как будто
    это сам оригинальный тип, который в данном случае размещен внутри Box.
- title: Сигнатура ошибки в функции main(). Cнова (Failable Main Revisited)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20core%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C'_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22This%20pie%20is%20not%20fresh!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A
  content_markdown: >
    В коде Rust может быть множество представлений ошибок, но в стандартной библиотеке есть универсальный типаж
    `std::error::Error` для описания любых ошибок.


    С помощью умного указателя `Box`, можно использовать тип `Box<dyn std::error::Error>` в качестве
    общего типа для возвращения ошибки, потому что он позволяет распространять вверх (propagate up)
    ошибку, хранящуюся в куче, по стеку вызова и взаимодействовать с ней на более высоких уровнях кода,
    без необходимости знать конкретный тип ошибки.


    Ранее в Tour of Rust мы изучили, что функция `main` может возвращать ошибку. Теперь можно
    возвращать тип, имеющий возможность описать почти любой вид ошибки, которая могла бы произойти
    в программе, при условии что представляющая нашу ошибку структура реализует общий
    типаж `std::error::Error` из Rust.


    ```rust

    fn main() -> Result<(), Box<dyn std::error::Error>>

    ```
- title: Подсчет ссылок (Referencing Counting)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Rc%3A%3Anew(Pie)%3B%0A%20%20%20%20let%20heap_pie2%20%3D%20heap_pie.clone()%3B%0A%20%20%20%20let%20heap_pie3%20%3D%20heap_pie2.clone()%3B%0A%0A%20%20%20%20heap_pie3.eat()%3B%0A%20%20%20%20heap_pie2.eat()%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%0A%20%20%20%20%2F%2F%20all%20reference%20count%20smart%20pointers%20are%20dropped%20now%0A%20%20%20%20%2F%2F%20the%20heap%20data%20Pie%20finally%20deallocates%0A%7D%0A
  content_markdown: >
    Тип `Rc` является умным указателем, который перемещает данные из стека в кучу. Он также
    позволяет клонировать другие умные указатели `Rc`, которые имеют возможность
    неизменного заимствования данных, помещенных в кучу.


    Как только последний умный указатель удален, данные внутри умного указателя освобождаются в куче.
- title: Разделяемый доступ (Sharing Access)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20RefCell%20validates%20memory%20safety%20at%20runtime%0A%20%20%20%20%2F%2F%20notice%3A%20pie_cell%20is%20not%20mut!%0A%20%20%20%20let%20pie_cell%20%3D%20RefCell%3A%3Anew(Pie%7Bslices%3A8%7D)%3B%0A%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20we%20can%20borrow%20mutable%20references!%0A%20%20%20%20%20%20%20%20let%20mut%20mut_ref_pie%20%3D%20pie_cell.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20mut_ref_pie%20is%20dropped%20at%20end%20of%20scope%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20now%20we%20can%20borrow%20immutably%20once%20our%20mutable%20reference%20drops%0A%20%20%20%20%20let%20ref_pie%20%3D%20pie_cell.borrow()%3B%0A%20%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2Cref_pie.slices)%3B%0A%7D%0A
  content_markdown: >
    Тип `RefCell` является контейнерной структурой данных, которая обычно поддерживает другие умные указатели.
    Она принимает данные и позволяет заимствовать изменяемые и неизменяемые ссылки на то, что находится внутри неё.
    Это предотвращает злоупотребление заимствованиями, обеспечивая соблюдение Rust правил безопасности памяти
    во время выполнения, когда вы просите заимствовать данные в случае:


    **только одна изменяемая ссылка ИЛИ несколько неизменяемых ссылок, но не обе одновременно!**


    При нарушении данного правила `RefCell` тип вызывает панику.
- title: Разделение данных между потоками (Sharing Across Threads)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22only%20I%20eat%20the%20pie%20right%20now!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%2F%2F%20let's%20borrow%20a%20locked%20immutable%20reference%20of%20pie%0A%20%20%20%20%2F%2F%20we%20have%20to%20unwrap%20the%20result%20of%20a%20lock%0A%20%20%20%20%2F%2F%20because%20it%20might%20fail%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%2F%2F%20locked%20reference%20drops%20here%2C%20and%20mutex%20protected%20value%20can%20be%20used%20by%20someone%20else%0A%7D%0A
  content_markdown: >
    `Mutex` является контейнерной структурой данных, которая обычно содержится в других умных указателях, которые
    уже внутри содержат данные и позволяет создавать изменяемые и неизменяемые ссылки на данные внутри.
    Это предотвращает злоупотребление заимствованием, поскольку операционная система ограничивает
    одновременный доступ к данным только одному потоку ЦП, блокируя другие потоки до тех пор,
    пока исходный поток не завершит работу с заблокированным заимствованием.


    Многопоточное программирование выходит за рамки Tour of Rust, но тип `Mutex` является
    фундаментальной частью управления несколькими потоками ЦП, обращающихся к одним и тем же данным.


    Существует специальный, умный указатель `Arc`, который идентичен `Rc`, за исключением того,
    что использует потоко-безопасное увеличение количества ссылок.

    Часто используется много ссылок на один и тот же `Mutex` объект.
- title: Комбинирование умных указателей (Combining Smart Pointers)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20took%20a%20slice!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20use%20smart%20pointer%20to%20pie%20for%20a%20mutable%20borrow%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20take%20a%20bite!%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%2F%2F%20ferris%20and%20sarah%20are%20given%20clones%20of%20smart%20pointer%20to%20pie%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22sarah%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2C%20p.slices)%3B%0A%7D%0A
  content_markdown: >
    Умные указатели могут показаться довольно ограниченными по функционалности, но главное то,
    что они могут создавать очень мощные комбинации для использования в коде.


    `Rc<Vec<Foo>>` - позволяет клонирование нескольких умных указателей, которые
    могут заимствовать из кучи один и тот же вектор неизменяемых структур данных.


    `Rc<RefCell<Foo>>` - дает возможность нескольким умных указателям заимствовать
    одну и туже структуру `Foo` как неизменяемую или изменяемую.


    `Arc<Mutex<Foo>>` - дает возможность нескольким умным указателям временно блокировать
    в процессорном потоке изменяемые или неизменяемые заимствования.


    Детали для запоминания:

    * Вы обнаружите умные указатели во множестве комбинаций. Использование неизменяемого
    типа данных (возможно, принадлежащего нескольким умным указателям) для изменения внутренних данных указателя.
    Это случай в Rust называется шаблоном "внутренняя изменчивость".
      Этот шаблон позволяет  изменять правила использования памяти во время выполнения с тем же уровнем безопасности,
    что и проверки во время компиляции в Rust.

- title: Глава 8 - Заключение
  content_markdown: >
    Умные указатели являются идиомами программирования в Rust и нам не нужно заново создавать
    очень распространенные шаблоны использования памяти.
    С ними вы можете быть готовыми решать самые сложные задачи.

    Теперь, когда у нас есть основы Rust, давайте немного поговорим о том, как создаются большие проекты.

    В главе 9 мы освобождаемся от примеров кода в одну страницу.
