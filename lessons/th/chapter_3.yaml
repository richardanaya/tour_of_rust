- title: บทที่ 3 - ประเภทโครงสร้างข้อมูลพื้นฐาน
  content_markdown: >
    ได้เวลาแล้ว ที่เราจะไปสำรวจเรื่องอื่นนอกเหนือจาก ประเภทตัวแปรพื้นฐาน!

    ซึ่งในบทนี้ เราจะไปดูกันที่ โครงสร้างข้อมูลแบบพื้นฐานที่สุดใน Rust กัน

    โดยจะให้ความสำคัญไปที่ การใช้หน่วยความจำเป็นหลัก

    ฉันแอบคิดว่าคุณจะต้องสนุกแน่ ที่ได้เห็นว่า Rust แอบซ่อนอะไรไว้

    ในขณะที่สิ่งนั้นมันทำงานอยู่
- title: Structures
  content_markdown: >
    `struct` คือกลุ่มของฟิลด์


    *ฟิลด์* ก็คือข้อมูลธรรมดานี่แหล่ะ ที่รวมอยู่ในโครงสร้าง ซึ่งมันเป็นได้ตั้งแต่ ชนิดตัวแปรขึ้นพื้นฐานที่สุด

    หรืออาจจะเป็นโครงสร้างอีกตัวซ้อนกันก็ได้


    การนิยามสิ่งนี้ ก็เหมือนกับพิมพ์เขียวให้คอมไฟเลอร์รู้ว่าฟิล์ดพวกนี้จะวางอยู่ติดกันในหน่วยความจำ
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20String%20is%20a%20struct%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D
- title: การเรียกเมธอด
  content_markdown: >
    ข้อที่แตกต่างจากฟังก์ชันก็คือ เมธอดนั้นเป็นฟังก์ชันที่ เป็นส่วนหนึ่งของ ชนิดตัวแปรสักตัวแบบเฉพาะเจาะจง


    **static methods** — คือเมธอดที่เป็นของชนิดตัวแปรเองเลย เรียกใช้ด้วยตัวดำเนินการ `::`


    **instance methods** — คือเมธอดที่เป็นของตัวแปร เรียกใช้ด้วยตัวดำเนินการ `.`


    แล้วเราจะมาพูดเรื่องการสร้างเมธอดด้วยตัวเองกันอีกครั้งเร็วๆนี้
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Using%20a%20static%20method%20to%20create%20an%20instance%20of%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20Using%20a%20method%20on%20the%20instance%0A%20%20%20%20println!(%22%7B%7D%20is%20%7B%7D%20characters%20long.%22%2C%20s%2C%20s.len())%3B%0A%7D%0A
- title: หน่วยความจำ
  content_markdown: >
    โปรแกรมที่เขียนจาก Rust จะมีหน่วยความจำที่ใช้งานอยู่ 3 ส่วน:

    * **data memory** - สำหรับเก็บข้อมูลที่ถูกกำหนดไว้ชัดเจน ทั้งในแง่ ขนาด และค่าคงที่ (เช่นอะไรก็ตามที่ใช้ได้ตลอดเวลาที่รันโปรแกรม)
      ยกตัวอย่างข้อความในโปรแกรมของคุณ (เช่น "Hello World!"): ข้อมูลไบต์ของข้อความนี้ ถูกอ่านมาใช้แค่ครั้งเดียวเท่านั้น
      ดังนั้นมันจึงถูกเก็บไว้ที่นี่ ซึ่งคอมไพเลอร์จะพยายามอย่างหนักเพื่อเพิ่มประสิทธิภาพให้ข้อมูลจำพวกนี้
      ทำให้มันถูกนำมาใช้งานได้เร็วมาก เพราะตำแหน่งที่มันอยู่จะแน่นอนและรู้โดยทั่วกัน
    * **stack memory** - สำหรับเก็บข้อมูลตัวแปรที่ประกาศไว้ในฟังก์ชัน
      โดยตำแหน่งของข้อมูลนี้จะไม่เปลี่ยนแปลงเลยตลอดการทำงานของฟังก์ชัน;
      และด้วยความสามารถของคอมไพเลอร์ จึงสามารถเพิ่มประสิทธิภาพให้การเข้าถึง stack นี้ทำได้เร็วมาก
    * **heap memory** - สำหรับข้อมูลที่สร้างขึ้นในขณะที่แอปพลิเคชันกำลังทำงาน
      ข้อมูลในส่วนนี้อาจถูกเพิ่มย้ายลบปรับขนาด ฯลฯ ได้ตลอดเวลา
      เนื่องจากโดยธรรมชาติข้อมูลส่วนนี้จะมีความยืดหยุ่นในการทำงาน ซึ่งก็รับรู้กันว่าต้องแลกมาด้วย
      การทำงานที่ช้าลง แต่ก็นั่นแหล่ะ มันทำให้การทำงานมีความแพรวพราวเพิ่มขึ้นด้วย
      เมื่อใดที่มีการเพิ่มข้อมูลลงมาในส่วนนี้ เราเรียกว่าการ **allocation**
      และ เมื่อใดที่มีการลบข้อมูลออกไปจากส่วนนี้ เราจะเรียกมันว่า **deallocation**
- title: การสร้างข้อมูลในหน่วยความจำ
  content_markdown: >
    เมื่อเราสร้าง **อินสแตนซ์** จาก **struct** สักตัวในโค้ดของเรา โปรแกรมของเราจะสร้าง
    ข้อมูลจากโครงสร้างฟิลด์ไว้เคียงข้างกันในหน่วยความจำ


    เราสร้างอินสแตนซ์จากฟิลด์ทั้งหมดภายใน


    `StructName { ... }`.


    การเข้าถึงฟิลด์ใน Struct ทำได้ด้วยการใช้ตัวดำเนินการ `.`


    รายละเอียดหน่วยความจำจากตัวอย่างนี้:

    * ข้อความในเครื่องหมายคำพูด เป็นข้อมูลที่ใช้อ่านอย่างเดียว (เช่น "Ferris"),
      พวกนี้จะไปอยู่ใน *data memory region*
    * มีการเรียกฟังก์ชัน `String::from` เพื่อสร้าง struct ของ `String` เพื่อนำไปวางเคียงข้างกัน
      กับฟิลด์ใน SeaCreature ใน *stack* โดยที่ String คือข้อความที่สามารถเปลี่ยนได้และทำได้โดย:
      1. ไปสร้างหน่วยความจำใน *heap* สำหรับข้อความที่ต้องการแก้ไข
      2. จัดเก็บสิ่งที่จะอ้างถึงหน่วยความจำนั้นไว้ใน *heap* แล้วค่อยเอาสิ่งนี้ ไปไว้ใน struct ของ `String`
      (มีเพิ่มเติมเรื่องนี้ในบทเรียนต่อๆไป)
    * ในที่สุดเพื่อนของเราทั้งสอง *Ferris* และ *Sarah* จึงมีโครงสร้างข้อมูลของตัวเอง แถมยังมีตำแหน่งที่ชัดเจน
      และคงที่ด้วย อยู่ในโปรแกรมของเรา และแน่นอนว่านั่นอยู่ใน *stack*
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crab%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22none%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20%7B%7D%20legs%2C%20and%20a%20%7B%7D%20weapon%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20and%20%7B%7D%20legs.%20They%20have%20no%20weapon..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
- title: Tuple-like Structs
  content_markdown: |
    เพื่อความสะดวกคุณสามารถสร้างโครงสร้างที่หน้าตาเหมือนทูเพิลได้เลยด้วย
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20This%20is%20still%20a%20struct%20on%20a%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
- title: Unit-like Structs
  content_markdown: >
    Structs ที่มีมีฟิลด์อะไรเลยข้างใน


    ที่เคยกล่าวไว้ในบทที่ 1 ว่า *unit* ก็คือชื่อเล่นของ ทูเพิลที่ว่างเปล่า `()`
    และนี่ก็คือเห็นผลที่เราเรียกเจ้า struct แบบนี้ว่า *Unit-like*


    struct แบบนี้ถูกใช้น้อยมากๆเลย ขอบอก
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A
- title: Enumerations
  content_markdown: >
    Enumerations ช่วยให้คุณสามารถสร้าง type ใหม่ ที่สามารถมีค่าขององค์ประกอบที่ติดแท็กหลายรายการโดยใช้คีย์เวิร์ด enum


    `match` จะเป็นตัวช่วยให้มั่นใจได้ว่าจะจัดการ enum ทุกตัวได้ครบ ว้าว สุดยอดเครื่องมือ
    ที่ทำให้เราได้โค้ดที่มีคุณภาพ เยี่ยมไปเลย
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20is%20a%20crab%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20is%20a%20octopus%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20is%20a%20fish%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20is%20a%20clam%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
- title: Enumerations With Data
  content_markdown: >
    ในองค์ประกอบ `enum` ยังอนุญาตให้สามารถมีประเภทข้อมูล ได้อย่างน้อยหนึ่งชนิดอีกด้วย
    ซึ่งจะมีพฤติกรรมคล้ายกับ *union* ในภาษาซี


    เมื่อใช้ `match` มาจับคู่ของใน `enum` คุณสามารถผูกชื่อตัวแปรให้แต่ละค่านั้นได้เลย


    รายละเอียดหน่วยความจำของ `enum`:

    * ค่าข้อมูลของ enum จะมีขนาดในหน่วยความจำ เท่ากับขนาดขององค์ประกอบสมาชิกตัวที่ใหญ่ที่สุด
    นั่นทำให้ไม่ว่าจะเป็นค่าใดก็จะสามารถวางลงบนพื้นที่ในหน่วยความจำได้แน่นอน

    * นอกจากนี้แล้ว ประเภทข้อมูลของสมาชิก (ถ้ามี) แต่ละตัวจะมีเลขประจำตัวแทนแต่ละแท็กด้วย


    รายละเอียดอื่นๆ:

    * `enum` ใน Rust ก็คือสิ่งที่หลายๆคนรู้จักกันในชื่อ *tagged union*

    * เวลาที่ใครๆพูดกันว่า Rust มี *algebraic types* เขากำลังหมายถึงการเอา type หลายๆตัวมารวมกันสร้างเป็น type ใหม่นั่นเอง
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20some%20other%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D
- title: บทที่ 3 - สรุป
  content_markdown: >
    น่าตื่นเต้นไหม! ตอนนี้เครื่องมือขั้นพื้นฐานที่สุด ก็พร้อมให้เราเปลี่ยนไอเดียลงไปเป็นโค้ดได้แล้ว
    หวังว่าตอนนี้เราจะเห็นแสงรำไรหน่อยๆแล้ว สิ่งจำเป็นพื้นฐานของ Rust ทำงานสอดประสานและใกล้ชิดกับประเภทตัวแปรมากขนาดไหน
    ต่อจากนี้ เดี๋ยวเราจะพูดกันถึงเรื่อง แนวคิดที่จะทำให้ประเภทของข้อมูลมีความยืดหยุ่นมากขึ้น ผ่านการแทนด้วย: *generics*
