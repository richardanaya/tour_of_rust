- title: Розділ 8 - Розумні покажчики (Smart Pointers)
  content_markdown: >
    У цьому розділі ми демістифікуємо розумні покажчики. Давайте 
    
    досліджувати ці структури даних, які дозволяють нам взаємодіяти 
    
    з найнижчим рівнем пам'яті.


    Ферріс каже: «Не бентежтеся через цей розділ, якщо ви не відчуваєте, що

    здатні написати власний низькорівневий код для керування пам’яттю за 
    одне коротке читання. Цей розділ 

     здебільшого познайомити вас із деякими корисними інструментами та дати 
     уявлення про те, як вони працюють!"
- title: Про посилання
  content_markdown: >
    По суті, посилання - це просто число, яке є стартовою позицією певних

    байтів у пам'яті. Його єдина мета - дати уявлення, де знаходиться данні  

    конкретного типу. Посилання відрізняється від звичайного числа тим, що Rust
    перевіряє, чи час життя посилання

    відповідає часу життя того, на що воно посилається (інакше ми отримали

    б повідомлення про помилку, під час використання!).
- title: Необробленні покажчики (Raw Pointers)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20memory_location%20%3D%20%26a%20as%20*const%20i32%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20is%20here%20%7B%7D%22%2C%20memory_location)%3B%0A%7D%0A
  content_markdown: >
    Посилання можна перетворити у більш примітивний тип, який називається
    *необробленні покажчики*. Так само, як і числа їх

    можна копіювати і переміщувати з невеликими обмеженнями. Rust не

    гарантує існування місця у пам'яті на які вони вказують.


    Існує 2 види необроблених покажчиків:


    * `*const T` - необроблений покажчик на дані типу T, які ніколи не зміняться.

    * `*mut T` - необроблений покажчик на дані типу T, які можуть змінюватися.


    Необроблені покажчики можна перетворювати на числа та з них (наприклад, `usize`).

    Необроблені покажчики можуть отримати доступ до даних за допомогою *небезпечного* 
    коду (детальніше про це пізніше).

    Деталі про роботу з пам'яттю:

    * Посилання в Rust дуже схоже на покажчик у C з точки зору використання, 
    але з набагато більшими обмеженнями часу компіляції по тому, 
      як його можна зберігати та переміщувати до інших функцій.
    * Необроблений вказівник у Rust схожий на вказівник у C, оскільки він представляє число,
      яке можна копіювати або передавати, і навіть перетворювати на числові типи, де його 
      можна модифікувати як число для виконання математики вказівника.
- title: Розіменування
  content_markdown: |
    Процес доступу/управління даними, на які посилаються
    за *посиланням* (тобто `&i32`) називається *розіменуванням*.

    Посилання використовуються для доступу/управління даними двома способами:
    * Доступ до зазначених даних під час призначення змінних.
    * Доступ до полів або методів зазначених даних.
    
    У Rust є кілька потужних операторів, які дозволяють нам це робити.
- title: Оператор *
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20i32%20%3D%2042%3B%0A%20%20%20%20let%20ref_ref_ref_a%3A%20%26%26%26i32%20%3D%20%26%26%26a%3B%0A%20%20%20%20let%20ref_a%3A%20%26i32%20%3D%20**ref_ref_ref_a%3B%0A%20%20%20%20let%20b%3A%20i32%20%3D%20*ref_a%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20b)%0A%7D
  content_markdown: >
    Оператор * є явним способом для розіменування посилання.

    ```rust

    let a: i32 = 42;

    let ref_ref_ref_a: &&&i32 = &&&a;

    let ref_a: &i32 = **ref_ref_ref_a;

    let b: i32 = *ref_a;

    ```


    Деталі про роботу з пам'яттю:

    - Оскільки i32 є примітивним типом, який реалізує властивість `Copy`,

    байти змінної `a` у стеку копіюються в байти змінної
    `b`.
- title: Оператор .
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20value%3A%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20f%20%3D%20Foo%20%7B%20value%3A%2042%20%7D%3B%0A%20%20%20%20let%20ref_ref_ref_f%20%3D%20%26%26%26f%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20ref_ref_ref_f.value)%3B%0A%7D
  content_markdown: >
    Оператор `.` використовується для доступу до полів і методів посилання. Це
    працює дещо тонше.


    ```rust

    let f = Foo { value: 42 };

    let ref_ref_ref_f = &&&f;

    println!("{}", ref_ref_ref_f.value);

    ```

    Ого, а чому ми не додали `***` перед `ref_ref_ref_f`? Це тому, що
    оператор `.` автоматично роздиференціює 

    послідовність посилань. Останній рядок автоматично перетворюється 
    компілятором.


    ```rust

    println!("{}", (***ref_ref_ref_f).value);

    ```
- title: Розумні вказівники (Smart Pointers)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aops%3A%3ADeref%3B%0Astruct%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0Aimpl%3CT%3E%20Deref%20for%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20was%20used!%22%2C%20std%3A%3Aany%3A%3Atype_name%3A%3A%3CT%3E())%3B%0A%20%20%20%20%20%20%20%20%26self.value%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20TattleTell%20%7B%0A%20%20%20%20%20%20%20%20value%3A%20%22secret%20message%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%2F%2F%20dereference%20occurs%20here%20immediately%20%0A%20%20%20%20%2F%2F%20after%20foo%20is%20auto-referenced%20for%20the%0A%20%20%20%20%2F%2F%20function%20%60len%60%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.len())%3B%0A%7D%0A
  content_markdown: >
    На додаток до можливості створювати посилання на існуючі типізовані дані за допомогою
    оператора `&`, Rust надає нам можливість

    створювати *посилання-подібні* структури, які називаються **розумні вказівники**. 


    Ми можемо думати про посилання на високому рівні як про тип, який надає нам доступ до
    іншого типу. Розумні покажчики відрізняються за своєю 

    поведінкою від звичайних посилань тим, що вони працюють на основі внутрішньої логіки
    яку пише програміст. Ви - програміст -

    є *розумною* частиною.


    Зазвичай, розумні покажчики реалізують ознаки `Deref`, `DerefMut` та `Drop` для
    визначення логіки того, що має відбуватись, коли

    структуру розіменовують операторами `*` та `.`.
- title: Розумний небезпечний код (Smart Unsafe Code)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%5Bu8%3B%204%5D%20%3D%20%5B86%2C%2014%2C%2073%2C%2064%5D%3B%0A%20%20%20%20%2F%2F%20this%20is%20a%20raw%20pointer.%20Getting%20the%20memory%20address%0A%20%20%20%20%2F%2F%20of%20something%20as%20a%20number%20is%20totally%20safe%0A%20%20%20%20let%20pointer_a%20%3D%20%26a%20as%20*const%20u8%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20memory%20location%3A%20%7B%7D%22%2C%20pointer_a)%3B%0A%20%20%20%20%2F%2F%20Turning%20our%20number%20into%20a%20raw%20pointer%20to%20a%20f32%20is%0A%20%20%20%20%2F%2F%20also%20safe%20to%20do.%0A%20%20%20%20let%20pointer_b%20%3D%20pointer_a%20as%20*const%20f32%3B%0A%20%20%20%20let%20b%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20unsafe%20because%20we%20are%20telling%20the%20compiler%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20assume%20our%20pointer%20is%20a%20valid%20f32%20and%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it's%20value%20into%20the%20variable%20b.%0A%20%20%20%20%20%20%20%20%2F%2F%20Rust%20has%20no%20way%20to%20verify%20this%20assumption%20is%20true.%0A%20%20%20%20%20%20%20%20*pointer_b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22I%20swear%20this%20is%20a%20pie!%20%7B%7D%22%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Розумні вказівники досить часто використовують *небезпечний* код. Як згадувалося
    раніше, 

    вони є поширеним інструментом для взаємодії з найнижчими рівнями пам'яті у
    Rust.


    Що таке небезпечний код? Небезпечний код поводиться так само, як і звичайний код у Rust, за
    за винятком декількох можливостей,

    щодо яких компілятор Rust не може надати гарантій.


    Основною можливістю небезпечного коду є *розіменування необроблених вказівник*. Це
    означає розміщення *необробленого вказівника* 

    в пам'яті та оголошення "тут існує структура даних!" і перетворення її на 
    дані, яке ви можете використовувати (наприклад, `*const u8` на
    `u8`). 

    Rust не має можливості відстежувати значення кожного байта, який записується
    до пам'яті. Оскільки, Rust не може надати 

    гарантій щодо того, чи існує щось за довільним номером, який використовується як *неороблений вказівник*,
    він поміщає розіменування у `unsafe { ... }` блок. 


    Розумні вказівники широко використовуються для *розіменування сирі вказівники*, і вони добре
    зарекомендували себе у тому, що вони роблять.
- title: Наші старі друзі
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20let's%20ask%20for%204%20bytes%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20allocate%20and%20save%20the%20memory%20location%20as%20a%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20use%20pointer%20math%20and%20write%20a%20few%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20u8%20values%20to%20memory%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20interpret%20secret_recipe%20pointer%20as%20a%20f32%20raw%20pointer%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it%20into%20a%20return%20value%20%26f32%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20%22make%20a%20pie%22%20by%20dereferencing%20our%20%0A%20%20%20%20%2F%2F%20Pie%20struct%20smart%20pointer%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A
  content_markdown: >
    Розглянемо деякі розумні покажчики, які ми вже бачили, такі як `Vec<T>` та `String`.


    `Vec<T>` - це розумний покажчик, який просто володіє деякою областю пам'яті у байтах.
    Компілятор Rust не має жодного уявлення про те, що 

    знаходиться у цих байтах. Розумний вказівник інтерпретує, тобто захоплює
    елементи з області пам'яті, якою він керує,

    відстежує, де починаються і де закінчуються структури даних у цих байтах, і
    потім нарешті розіменовує необроблений вказівник

    на структури даних з гарним чистим і лаконічним інтерфейсом, якими ми можемо користуватися
    (наприклад, `my_vec[3]`).


    Аналогічно, `String` відстежує область пам'яті у байтах, і
    програмно обмежує вміст, що записується до неї, щоб завжди

    бути коректною у кодуванні `utf-8` і допомагає розіменовувати цю ділянку пам'яті до типу
    `&str`.


    Обидві ці структури даних використовують небезпечне розіменування необроблених вказівників для виконання
    вказівників для виконання своєї роботи.


    Подробиці про роботу з пам'ятю:

    * У Rust є еквівалент функції `malloc` у C за допомогою
    [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) та
    [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html ) для
    отримання доступу до ваших власних областей пам'яті для подальшого керування.
- title: Heap Allocated Memory
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A
  content_markdown: >
    `Box` is a smart pointer that lets us move data from the stack to the heap.


    Dereferencing it lets us use the heap allocated data ergonomically as if it
    were the original type.
- title: Failable Main Revisited
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C%27_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22This%20pie%20is%20not%20fresh!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A
  content_markdown: >
    Rust code may have a plethora of representations of errors, but the standard
    library has

    a universal trait `std::error::Error` for describing errors.


    Using a smart pointer `Box` we can use the type `Box<dyn std::error::Error>`
    as a common type for returning errors because it allows us to

    propagate up an error on the heap and interact with it at a high level
    without having to know a specific type.


    Early in Tour of Rust we learned that `main` can return an error. We can now
    return

    a type capable of describing almost any kind of error that might occur in
    our program 

    so long as the error's data structure implements Rust's common `Error`
    trait.


    ```rust

    fn main() -> Result<(), Box<dyn std::error:Error>>

    ```
- title: Referencing Counting
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Rc%3A%3Anew(Pie)%3B%0A%20%20%20%20let%20heap_pie2%20%3D%20heap_pie.clone()%3B%0A%20%20%20%20let%20heap_pie3%20%3D%20heap_pie2.clone()%3B%0A%0A%20%20%20%20heap_pie3.eat()%3B%0A%20%20%20%20heap_pie2.eat()%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%0A%20%20%20%20%2F%2F%20all%20reference%20count%20smart%20pointers%20are%20dropped%20now%0A%20%20%20%20%2F%2F%20the%20heap%20data%20Pie%20finally%20deallocates%0A%7D%0A
  content_markdown: >
    `Rc` is a smart pointer that moves data from the stack onto the heap. It
    allows us to 

    clone other `Rc` smart pointers that all have the ability to immutably
    borrow the data 

    that was put on the heap.


    Only when the last smart pointer is dropped does the data on the heap become
    deallocated.
- title: Sharing Access
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20RefCell%20validates%20memory%20safety%20at%20runtime%0A%20%20%20%20%2F%2F%20notice%3A%20pie_cell%20is%20not%20mut!%0A%20%20%20%20let%20pie_cell%20%3D%20RefCell%3A%3Anew(Pie%7Bslices%3A8%7D)%3B%0A%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20we%20can%20borrow%20mutable%20references!%0A%20%20%20%20%20%20%20%20let%20mut%20mut_ref_pie%20%3D%20pie_cell.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20mut_ref_pie%20is%20dropped%20at%20end%20of%20scope%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20now%20we%20can%20borrow%20immutably%20once%20our%20mutable%20reference%20drops%0A%20%20%20%20%20let%20ref_pie%20%3D%20pie_cell.borrow()%3B%0A%20%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2Cref_pie.slices)%3B%0A%7D%0A
  content_markdown: >
    `RefCell` is a container data structure commonly held by smart pointers that
    takes in data and lets us

    borrow mutable and immutable references to what's inside. It prevents
    borrowing from

    being abused by enforcing Rust's memory safety rules at runtime when you ask
    to borrow

    the data within:


    **Only one mutable reference OR multiple immutable references, but not
    both!**


    If you violate these rules `RefCell` will panic.
- title: Sharing Across Threads
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22only%20I%20eat%20the%20pie%20right%20now!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%2F%2F%20let's%20borrow%20a%20locked%20immutable%20reference%20of%20pie%0A%20%20%20%20%2F%2F%20we%20have%20to%20unwrap%20the%20result%20of%20a%20lock%0A%20%20%20%20%2F%2F%20because%20it%20might%20fail%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%2F%2F%20locked%20reference%20drops%20here%2C%20and%20mutex%20protected%20value%20can%20be%20used%20by%20someone%20else%0A%7D%0A
  content_markdown: >
    `Mutex` is a container data structure commonly held by smart pointers that
    takes in data and lets us borrow mutable

    and immutable references to the data within. This prevents borrowing from
    being abused by 

    having the operating system restrict only one CPU thread at time to have
    access to the data, 

    blocking other threads until that original thread is done with its locked
    borrow.


    Multithreading is beyond the scope of Tour of Rust, but `Mutex` is a
    fundamental part of orchestrating

    multiple CPU threads accessing the same data.


    There is a special smart pointer `Arc` which is identical to `Rc` except
    uses thread-safe incrementing of reference counts. 

    It's often used to have many references to the same `Mutex`.
- title: Поєднання розумних покажчиків
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20took%20a%20slice!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20use%20smart%20pointer%20to%20pie%20for%20a%20mutable%20borrow%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20take%20a%20bite!%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%2F%2F%20ferris%20and%20sarah%20are%20given%20clones%20of%20smart%20pointer%20to%20pie%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22sarah%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2C%20p.slices)%3B%0A%7D%0A
  content_markdown: >
    Розумні покажчики можуть здатися обмеженими, але вони можуть створювати дуже потужні
    комбінації.


    `Rc<Vec<Foo>>` - Дозволяє клонування декількох смарт-покажчиків, які можуть
    позичати один і той самий вектор незмінних структур даних на купі.


    `Rc<RefCell<Foo>>` - Дозволити декільком смарт-покажчикам запозичувати
    взаємно/незмінно одну й ту саму структуру `Foo`.


    `Arc<Mutex<Foo>>` - Дозволяє декільком смарт-покажчикам блокувати
    тимчасові змінювані/незмінні запозичення виключно для потоку процесора.


    Деталі роботи за памяттю:

    * Використання незмінного типу даних (який може належати декільком смарт-покажчикам) для модифікації
    внутрішніх даних у Rust називається патерном "внутрішня змінюваність". Це патерн, який дозволяє нам змінювати правила використання пам'яті під час виконання з тим же рівнем безпеки, що і перевірки Rust під час компіляції.

- title: Розділ 8 - Висновок
  content_markdown: >
    Розумні покажчики - це ідіома програмування на Rust, і нам не доведеться
    повторно створювати дуже поширені патерни використання пам'яті.

    Тепер, коли ми ознайомилися з основами Rust, давайте трохи поговоримо про те
    як створювати більші проекти. У главі 9 ми перестанемо писати код у одному файлі.
