- title: 6. Fejezet - Sz√∂vegek
  content_markdown: |
    Most, hogy √©rtj√ºk, hogyan kezeli a Rust a mem√≥ri√°t, k√©szen √°llunk arra, hogy a nyelv
    sz√∂vegkezel√©s√©r≈ël is r√©szletesen besz√©lhess√ºnk.

    A Rust nagy figyelmet ford√≠t a byte szinten el≈ëfordul√≥ √©s a nemzetk√∂zi sz√∂vegek √°ltal okozott
    probl√©m√°k elker√ºl√©s√©re, melyek sokszor figyelmen k√≠v√ºl vannak hagyva m√°s programoz√°si
    nyelvekben. Ezek korrig√°l√°s√°ra a Rust robusztus eszk√∂z√∂kkel rendelkezik.
- title: Sz√∂veg √©rt√©kek
  content_markdown: |
    A sz√∂veg √©rt√©kek mindig Unicode k√≥dol√°s√∫ak.

    A t√≠pusuk `&'static str`:

    * A `&` azt jel√∂li, hogy egy mem√≥ri√°ban tal√°lhat√≥ helyre mutatunk, a `mut` hi√°nya pedig, hogy ez
      egy megv√°ltoztathatatlan √©rt√©k.
    * A `'static` √©lettartam azt mondja meg, hogy a sz√∂veg a program fut√°s√°nak eg√©sze alatt el√©rhet≈ë
      sz√°munkra (sose drop-ol).
    * Az `str` pedig azt jelenti, hogy ez az √©rt√©k egy olyan b√°jtsorozat, ami mindig √©rv√©nyes
      **utf-8** b√°jtokat tartalmaz.

    Hogyan √©rinti ez a mem√≥ri√°t:

    * A ford√≠t√≥ az ilyen sz√∂vegeket majdnem mindig az adatmem√≥ri√°ba fogja helyezni.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
- title: Mi is az az utf-8?
  content_markdown: |
    Ahogy egyre t√∂bb nyelvet kezdt√ºnk haszn√°lni a sz√°m√≠t√≥g√©peken, hirtelen sz√ºks√©gess√© v√°lt, hogy
    t√∂bb karaktert tudjunk reprezent√°lni, mint arra az ASCII k√©pes volt (mely 1 byteon t√°rolt a
    karaktereket, √≠gy √∂sszesen 256 k√ºl√∂nb√∂z≈ë karaktert megengedve).

    Az **utf-8** egy olyan form√°tum, ami 1-4 b√°jt k√∂z√∂tti hosszal rendelkezik karakterenk√©nt, ezzel
    l√©nyegesen megn√∂velve, h√°ny karaktert is k√©pes reprezent√°lni. Mivel a gyakori, ASCII-ban is
    el≈ëfordul√≥ karakterek itt is egy b√°jton vannak reprezent√°lva, ez√©rt a k√≥dol√°s nem pazarolja a
    helyet f√∂l√∂slegesen. Ugyanakkor, a v√°ltoz√≥ hossz iatt √≠gy m√°r nem lehet egyszer≈±en lek√©rni a
    sz√∂veg egyes karaktereit (**O(1)** id≈ëben) azzal, hogy a sz√∂vegbe indexel√ºnk (pl.:
    `sz√∂vegem[3]`), hisz k√∂nnyen meglehet, hogy mindegyik karakter m√°s hossz√∫s√°g√∫, √≠gy az indexelt
    karakter lehet nem is ott van, ahol a program keresn√©. Ehelyett a megold√°s az, hogy
    v√©gigiter√°lunk a sz√∂vegen, am√≠g a keresett karaktert el nem √©rj√ºk (**O(n)** id≈ëben).

    Ferris: "Csak √∂r√ºlni tudok, hogy az **utf-8** seg√≠ts√©g√©vel a v√≠z alatti bar√°taim k√©pei
    megjelenhetnek!"

    <span class="emoji">üê†üêôüêüüê¨üêã</span>
- title: Escape-elt karakterek
  content_markdown: |
    Van p√°r karakter, amit neh√©z vizu√°lisan reprezent√°lni, ez√©rt ezekre √∫gynevezett **escape
    code**-okat (kiker√ºl√©si k√≥dokat) alkalmazunk, amikkel szimb√≥lumokra cser√©lhetj√ºk ezeket a
    karaktereket.

    A Rust a m√°r C-ben is megszokott escape code-okat t√°mogatja:

    * `\n` - soremel√©s / √∫jsor
    * `\r` - kocsivissza / kurzor a sor elej√©re
    * `\t` - tab
    * `\\` - rep-jel / visszaper
    * `\0` - null karakter
    * `\'` - aposztr√≥f

    Az ilyen szimb√≥lumok teljes list√°j√°t [itt](https://doc.rust-lang.org/reference/tokens.html) tal√°lod angolul.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22Ferris%20says%3A%5Ct%5C%22hello%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
- title: T√∂bbsoros sz√∂veg √©rt√©kek
  content_markdown: |
    A Rust nyelv sz√∂vegei alapb√≥l t√∂bbsorosak.

    Ha sz√ºks√©ges egy `\` jelet tehetsz a sor v√©g√©re, mely eset√©n nem ker√ºl sort√∂r√©s a sz√∂vegbe.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26'static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20I%20write%2C%20erase%2C%20rewrite%0A%20%20%20%20%20%20%20%20Erase%20again%2C%20and%20then%0A%20%20%20%20%20%20%20%20A%20poppy%20blooms.%0A%20%20%20%20%20%20%20%20-%20Katsushika%20Hokusai%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22hello%20%5C%0A%20%20%20%20world%22)%20%2F%2F%20notice%20that%20the%20spacing%20before%20w%20is%20ignored%0A%7D%0A
- title: Nyers sz√∂veg √©rt√©kek
  content_markdown: |
    Az √∫gynevezett raw string-ek (nyers sz√∂vegek) lehet≈ëv√© teszik sz√°munkra, hogy a ford√≠t√≥
    b√°rmif√©le √°talak√≠t√°s n√©lk√ºl √©rtelmezze a sz√∂veg√ºnk. Egy ilyet a k√∂vetkez≈ë m√≥don tudunk
    k√©sz√≠teni:

    `r#"Ide j√∂n a sz√∂veg"#`

    Ezt haszn√°lva b√°tran √≠rhatunk olyan karaktereket √©s szimb√≥lumokat, amiknek egy√©b esetben m√°s
    jelent√©se vagy hat√°sa volna, mint p√©ld√°ul az id√©z≈ëjelek vagy az el≈ëbb eml√≠tett escape code-ok.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Raw%20strings%20are%20useful%20for%20some%20situations.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A
- title: F√°jlokb√≥l bet√∂lt√∂tt sz√∂veg √©rt√©kek
  content_markdown: |
    Ha egy nagyon nagy sz√∂veget szeretn√©l a programodban elhelyezni, az `include_str!` makr√≥val
    egy f√°jl sz√∂veg√©t egy-az-egyben be tudod m√°solni egy v√°ltoz√≥ba.

    ```rust
    let 00_html = include_str!("00_en.html");
    ```
- title: Sz√∂veg szeletek
  content_markdown: |
    A string slice (sz√∂veg szelet) egy mem√≥ri√°ban l√©v≈ë, csak √©rv√©nyes utf-8 √©rt√©keket tartalmaz√≥
    b√°jtszekvenci√°ra mutat√≥ referencia.

    Egy `str`-b≈ël k√©sz√ºlt slice-n√°l is teljes√ºlnie kell ezeknek a felt√©teleknek.

    A `&str` gyakran haszn√°lt met√≥dusai:

    * `len` - A sz√∂veg hossz√°t adja meg b√°jtokban (**nem** azt, hogy h√°ny karakterb≈ël √°ll!)
    * `starts_with`/`ends_with` - Ellen≈ërizni lehet vel√ºk, hogy a sz√∂veg egy bizonyos m√≥don kezd≈ëdik
      vagy v√©gz≈ëdik-e.
    * `is_empty` - Igaz, ha `len` == 0.

    * `find` - Megpr√≥b√°lja megkeresni az els≈ë param√©ter els≈ë el≈ëfordul√°s√°t a sz√∂vegben, majd ennek
      index√©vel t√©r vissza egy `Option<usize>` k√©p√©ben. Ha nem tal√°l ilyet, a visszat√©r√©si √©rt√©k
      None.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20first_word%20%3D%20%26a%5B0..2%5D%3B%0A%20%20%20%20let%20second_word%20%3D%20%26a%5B3..7%5D%3B%0A%20%20%20%20%2F%2F%20let%20half_crab%20%3D%20%26a%5B3..5%5D%3B%20FAILS%0A%20%20%20%20%2F%2F%20Rust%20does%20not%20accept%20slices%20of%20invalid%20unicode%20characters%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20first_word%2C%20second_word)%3B%0A%7D%0A
- title: Char-ok
  content_markdown: |
    Mivel az Unicode haszn√°lata igencsak neh√©zkes, a Rust lehet≈ës√©get ad arra, hogy egy utf-8
    b√°jtszekvenci√°t `char` t√≠pus√∫ vektork√©nt k√©rj√ºnk le.

    Az ilyen `char`-ok mindig 4 b√°jtosak, √≠gy a bel≈ël√ºk √∂ssze√°ll√≠tott vektorba k√∂nny≈± indexelni.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20collect%20the%20characters%20as%20a%20vector%20of%20char%0A%20%20%20%20let%20chars%20%3D%20%22hi%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20should%20be%204%0A%20%20%20%20%2F%2F%20since%20chars%20are%204%20bytes%20we%20can%20convert%20to%20u32%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A
- title: String-ek
  content_markdown: |

    A **String** egy olyan struct, ami egy kupacmem√≥ri√°n t√°rolt utf-8 b√°jtszekvenci√°t birtokol.
    Mivel a kupacon van t√°rolva, √≠gy a be√°gyazott sz√∂vegekkel ellent√©tben meg lehet hosszabb√≠tani,
    m√≥dos√≠tani lehet, stb.

    Gyakran haszn√°lt met√≥dusok:

    * `push_str` - A sz√∂veg v√©g√©hez illeszti a param√©terk√©nt √°tadott utf-8 b√°jtokat.
    * `replace` - Kicser√©l egy megadott utf-8 szekvenci√°t egy m√°sikra.
    * `to_lowercase`/`to_uppercase` - Kisbet≈±ss√© vagy nagybet≈±ss√© alak√≠tja a sz√∂veget.
    * `trim` - A sz√∂veg v√©gi helykihagy√°sokat (space, tab) v√°gja le.

    Amikor a String drop-ol, az √°ltala birtokolt mem√≥ria is felszabad√≠t√°sra ker√ºl.

    B√°r a String rendelkezik a `+` oper√°torral, ami egy `&str`-t illeszt a v√©g√©re majd visszaadja az
    √∫jonnan meghosszabbodott sz√∂veget, de ez sajnos sokkal kev√©sb√© ergonomikus, mint az els≈ëre
    t≈±nhet.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20helloworld%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%20%20%20%20helloworld.push_str(%22%20world%22)%3B%0A%20%20%20%20helloworld%20%3D%20helloworld%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%7D%0A
- title: Sz√∂veg mint funkci√≥-param√©ter
  content_markdown: |
    A sz√∂vegek √°ltal√°ban szeletek form√°j√°ban ker√ºlnek √°tad√°sra a f√ºggv√©nyeknek. Ez nagy
    rugalmass√°got biztos√≠t an√©lk√ºl, hogy a sz√∂veg birtokl√°s√°t √°t k√©ne adni.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20borrow%20%26%27static%20str%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%22hello%22)%3B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20also%20borrow%20String%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22goodbye%22))%3B%0A%7D%0A
- title: Sz√∂vegek √©p√≠t√©se
  content_markdown: |
    A `concat` √©s `join` k√©t egyszer≈±, de er≈ëteljes m√≥dszer arra, hogy sz√∂vegeket √©p√≠ts√ºnk.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22hello%22%2C%20%22%20%22%2C%20%22world%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A
- title: Sz√∂vegek form√°z√°sa
  content_markdown: |
    A `format!` makr√≥ haszn√°lat√°val egy param√©terezett sz√∂veget hozhatunk l√©tre, amiben meg vannak
    har√°rozva, hogy hova √©s milyen m√≥don kell √©rt√©keknek ker√ºlnie. Az ilyen "lyukak" elhelyez√©s√©re a
    `{}`-t haszn√°ljuk a sz√∂vegben.

    A `format!` ugyan√∫gy haszn√°lja a param√©terezett sz√∂vegeket, mint a m√°r megszokott `println!`.

    Ez a f√ºggv√©ny t√∫ls√°gosan sokat tud ahhoz, hogy a *Rust-t√∫ra* keretei k√∂z√∂tt enn√©l jobban
    √°tn√©zz√ºk, de √©rdemes √°tolvasni az [angol nyelv≈± dokument√°ci√≥t](https://doc.rust-lang.org/std/fmt/)
    a t√©m√°val kapcsolatban.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22secret%20to%20life%3A%20%7B%7D%22%2Ca)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cf)%3B%0A%7D%0A
- title: Sz√∂vegek √°talak√≠t√°sa
  content_markdown: |
    Sokf√©le t√≠pus alak√≠that√≥ sz√∂vegg√© a `to_string` met√≥dus seg√≠ts√©g√©vel.

    A generikus `parse` f√ºggv√©ny pedig a sz√∂vegeket alak√≠tja m√°s t√≠pus√∫ √©rt√©kekk√© (pl. sz√°mokk√°).
    Ennek a visszat√©r√©si √©rt√©ke egy `Result`, mivel ha √°talak√≠thatatlan √©rt√©kre h√≠vjuk meg, hib√°t
    dob.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
- title: 6. Fejezet - Konkl√∫zi√≥
  content_markdown: |
    Most m√°r ismered a sz√∂vegek alapjait! A Unicode miatt kicsit neh√©zkes a vel√ºk val√≥ munka, de az
    alapk√∂nyvt√°r √©pp ez√©rt sok olyan funkci√≥val rendelkezik, ami megk√∂nny√≠ti ezt.

    Eg√©szen eddig a Rust nyelv a proced√∫r√°lis paradigm√°hoz relev√°ns r√©szeivel foglalkoztunk csak
    (teh√°t, hogy mit tudnak a f√ºggv√©nyek meg az adatok), de √©pp ideje, hogy besz√©lj√ºnk a trait-ekr≈ël
    (tulajdons√°gokr√≥l) √©s a Rust objektum-orient√°lt paradigm√°ja √°ltal ny√∫jtott lehet≈ës√©gekr≈ël.