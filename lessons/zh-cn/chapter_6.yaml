- title: ç¬¬å…­ç«  - æ–‡æœ¬
  content_markdown: >
    ç°åœ¨æˆ‘ä»¬äº†è§£åˆ°äº† Rust å¦‚ä½•è¿›è¡Œå†…å­˜ç®¡ç†ï¼Œæˆ‘ä»¬å°†æ›´ä¸ºè¯¦å°½çš„ä»‹ç»æ–‡æœ¬ã€‚
    Now that we understand a bit how Rust thinks of memory, we are prepared to
    talk about text in more detail.

    Rust éå¸¸å…³æ³¨æ–‡æœ¬å›½é™…åŒ–ä¸å­—èŠ‚å±‚çº§çš„é—®é¢˜ï¼Œè¿™æ„å‘³ç€ Rust æœ‰è®¸å¤šå®ç”¨çš„å·¥å…·æ¥è§£å†³è¿™äº›é—®é¢˜ã€‚è™½ç„¶ä½ å¯èƒ½å¯¹å…¶å®ƒè¯­è¨€çš„è¿™äº›é—®é¢˜å¹¶ä¸ç†Ÿæ‚‰ã€‚
    Rust cares a great deal about international text and byte level concerns you
    might not be familiar with from other languages. That said, Rust has many great 
    tools for managing those concerns.
- title: å­—ç¬¦ä¸²å¸¸é‡ï¼ˆString Literalsï¼‰
  content_markdown: >
    å­—ç¬¦ä¸²å¸¸é‡ï¼ˆString Literalsï¼‰åªé‡‡ç”¨ Unicode ç¼–ç ï¼ˆæ³¨ï¼šä¸‹æ–‡æåŠçš„ **utf-8** ä¸º Unicode çš„ä¸€éƒ¨åˆ†ï¼‰ã€‚
    String literals are always Unicode.

    å­—ç¬¦ä¸²å¸¸é‡çš„ç±»å‹ä¸º `&'static str`ï¼š
    String literals type are `&'static str`:

    * `&` ä»£è¡¨è¯¥å˜é‡ä¸ºå¼•ç”¨äº†å†…å­˜ä¸­çš„æ•°æ®ï¼Œæ²¡æœ‰ä½¿ç”¨ `&mut` ä»£è¡¨ç¼–è¯‘å™¨å°†ä¸ä¼šå…è®¸å¯¹è¯¥å˜é‡çš„ä¿®æ”¹
    * `&` meaning that it's referring to a place in memory, and it lacks a
    `&mut` meaning that the compiler will not allow modification

    * `'static` ä»£è¡¨å­—ç¬¦ä¸²æ•°æ®å°†ä¼šä¸€ç›´ä¿å­˜åˆ°ç¨‹åºç»“æŸï¼ˆå®ƒåœ¨ç¨‹åºè¿è¡ŒæœŸé—´ä¸ä¼šè¢«ææ„å’Œé‡Šæ”¾ï¼ˆ**drop**ï¼‰ï¼‰
    * `'static` meaning the string data will be available till the end of our
    program (it never drops)

    * `str` ä»£è¡¨è¯¥å˜é‡æŒ‡å‘ä¸€è¿ä¸²æ€»æ˜¯æœ‰æ•ˆ **utf-8** çš„å­—èŠ‚ã€‚
    * `str` means that it points to a sequence of bytes that are always valid
    **utf-8**

    å†…å­˜ç»†èŠ‚ï¼š
    Memory details:

    * Rust ç¼–è¯‘å™¨å¯èƒ½ä¼šå°†å­—ç¬¦ä¸²å‚¨å­˜åœ¨ç¨‹åºå†…å­˜çš„æ•°æ®æ®µä¸­ã€‚
    * The Rust compiler will likely put your string in the data segment of your
    program memory
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22%E4%BD%A0%E5%A5%BD%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
- title: ä»€ä¹ˆæ˜¯ utf-8
  #"As more languages were used on computers, the world needed to represent more text characters
  #than ASCII allowed (1 byte only allowed 256 characters). 

  #**utf-8** was introduced with a variable byte length of 1-4 bytes greatly increasing the range of possible characters.
  
  #An advantage of variable sized characters is text did not have unnecessary bytes for very common ASCII (only requiring 1 byte still in **utf-8**).
  
  #A downside of variable sized characters is that character lookup can no longer be done quickly 
  #(**O(1)** constant time) with a simple indexing (e.g. `my_text[3]` to get the 4th character). It's possible that the 
  #preceding characters could have variable widths, altering where the 4th character actually begins in the sequence of bytes.
  
  #Instead we must iterate through a **utf-8** byte sequence to understand where the Unicode characters actually begin (**O(n)** linear time).
  
  #Ferris: \"I'm mostly just happy to have **utf-8** for representing emojis of my underwater friends.\"
  
  #<span class=\"emoji\">\U0001F420\U0001F419\U0001F41F\U0001F42C\U0001F40B</span>\n"
  content_markdown: >
    éšç€åœ¨è®¡ç®—æœºä¸Šä½¿ç”¨çš„è¯­è¨€çš„å¢åŠ ï¼Œä¸–ç•Œéœ€è¦å¯ä»¥æ¯” ASCII ç¼–ç ï¼ˆ1 å­—èŠ‚è¡¨ç¤º 1 ä¸ªå­—ç¬¦ï¼Œæ€»å…±å¯è¡¨ç¤º 256 ä¸ªå­—ç¬¦ï¼‰æ”¯æŒæ›´å¤šå­—ç¬¦çš„ç¼–ç ã€‚
    
    
    **utf-8** ç¼–ç è¿™æ—¶è¢«å¼•å…¥æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå®ƒç”¨ 1-4 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º 1 ä¸ªå­—ç¬¦ï¼Œè¿™ä½¿å¾—å¯ä»¥è¡¨ç¤ºçš„å­—ç¬¦æ•°å¤§å¤§å¢åŠ ã€‚
  
  
    ä½¿ç”¨å¯å˜é•¿åº¦çš„å­—èŠ‚æ¥è¡¨ç¤ºå­—ç¬¦æœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œå°±æ˜¯å¸¸è§çš„ ASCII ç¼–ç å­—ç¬¦åœ¨ **utf-8** ç¼–ç ä¸­æ— éœ€ä½¿ç”¨æ›´å¤šçš„å­—èŠ‚ï¼ˆä¹Ÿæ˜¯ 1 å­—èŠ‚è¡¨ç¤º 1 ä¸ªå­—ç¬¦ï¼‰ã€‚
  
  
    ä½†æ˜¯è¿™æ ·åšä¹Ÿæœ‰ç¼ºç‚¹ï¼Œåœ¨ **utf-8** ä¸­é€šè¿‡ç´¢å¼•æ¥åŒ¹é…å­—ç¬¦ï¼ˆä¾‹ï¼š`my_text[3]` è·å– my_text çš„ç¬¬ 4 ä¸ªå­—ç¬¦ï¼‰å°†ä¸èƒ½åƒä»¥å‰çš„ç¼–ç æ ‡å‡†é‚£ä¹ˆå¿«ï¼ˆä»¥å‰ç¼–ç æ ‡å‡†èŠ±è´¹ **O(1)** å¸¸æ•°æ—¶é—´ï¼‰ã€‚
    è¿™æ˜¯å› ä¸ºå‰é¢çš„å­—ç¬¦å…·æœ‰å¯å˜çš„å¯¹åº”å­—èŠ‚ï¼Œä»è€Œæ— æ³•ç›´æ¥ç¡®å®šç¬¬ 4 ä¸ªå­—ç¬¦åœ¨å­—èŠ‚åºåˆ—ä¸­çš„èµ·å§‹å­—èŠ‚ã€‚
  
  
    æˆ‘ä»¬éœ€è¦éå† **utf-8** çš„å­—èŠ‚åºåˆ—æ‰å¯ä»¥å¾—åˆ°å¯¹åº” Unicode å­—ç¬¦çš„èµ·å§‹ä½ç½®ï¼ˆè¿™å°†èŠ±è´¹ **O(n)** çº¿æ€§æ—¶é—´ï¼‰ã€‚
  
  
    Ferrisï¼š"æˆ‘åªæ˜¯å› ä¸º **utf-8** æœ‰è¡¨ç¤ºæˆ‘æ°´ä¸­å¥½å‹çš„è¡¨æƒ…ç¬¦å·è€Œé«˜å…´ã€‚"
  
  
    ğŸ ğŸ™ğŸŸğŸ¬ğŸ‹ 
- title: è½¬ä¹‰å­—ç¬¦
  content_markdown: >
    æœ‰äº›å­—ç¬¦éš¾ä»¥ä½¿ç”¨å¯è§†å­—ç¬¦è¡¨ç¤ºï¼Œè¿™æ˜¯å¯é€šè¿‡ä½¿ç”¨ç‰¹æ®Šç¬¦å·**è½¬ä¹‰**æ¥è¡¨è¾¾è¿™äº›ä¸æ˜“è¡¨è¾¾çš„å­—ç¬¦ã€‚
    It's challenging to visually represent certain characters, so **escape
    codes** allow us to put a symbol in their place.

    Rust æ”¯æŒç±» C è¯­è¨€ä¸­çš„å¸¸è§è½¬ä¹‰å­—ç¬¦ï¼›
    Rust supports the common escape codes from C-based languages:

    * `\n` - æ¢è¡Œç¬¦

    * `\r` - å›è½¦ç¬¦ï¼ˆå›åˆ°æœ¬è¡Œèµ·å§‹ä½ç½®ï¼‰

    * `\t` - æ°´å¹³åˆ¶è¡¨ç¬¦ï¼ˆå³é”®ç›˜ Tab é”®ï¼‰

    * `\\` - ä»£è¡¨å•ä¸ªåæ–œæ  \

    * `\0` - ç©ºå­—ç¬¦ï¼ˆnullï¼‰

    * `\'` - ä»£è¡¨å•å¼•å· '


    å®Œæ•´çš„è½¬ä¹‰å­—ç¬¦è¡¨
    [åœ¨è¿™](https://doc.rust-lang.org/reference/tokens.html)ã€‚
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22Ferris%20%E8%AF%B4%EF%BC%9A%5Ct%5C%22%E4%BD%A0%E5%A5%BD%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D
- title: å¤šè¡Œå­—ç¬¦ä¸²å¸¸é‡
  content_markdown: |
    Rust ä¸­å­—ç¬¦ä¸²é»˜è®¤æ”¯æŒåˆ†è¡Œã€‚
    Rust strings are multiline by default.

    ä½¿ç”¨ `\` å¯ä»¥ä½¿å¤šè¡Œå­—ç¬¦ä¸²ä¸æ¢è¡Œã€‚
    Use a `\` at the end of a line if you don't want a line break.
  code: >- 
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26'static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20%E6%88%91%E5%86%99%E4%B8%8B%EF%BC%8C%E6%93%A6%E6%8E%89%EF%BC%8C%0A%20%20%20%20%20%20%20%20%E5%86%8D%E5%86%99%EF%BC%8C%E5%86%8D%E6%93%A6%EF%BC%8C%0A%20%20%20%20%20%20%20%20%E7%84%B6%E5%90%8E%E4%B8%80%E6%9C%B5%E7%BD%82%E7%B2%9F%E8%8A%B1%E5%BC%80%E4%BA%86%E3%80%82%0A%20%20%20%20%20%20%20%20-%20%E8%91%9B%E9%A5%B0%E5%8C%97%E6%96%8B%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22%E4%BD%A0%E5%A5%BD%20%5C%0A%20%20%20%20%E4%B8%96%E7%95%8C%22)%3B%20%2F%2F%20%E6%B3%A8%E6%84%8F11%E8%A1%8C%20%E4%B8%96%20%E5%AD%97%E5%89%8D%E9%9D%A2%E7%9A%84%E7%A9%BA%E6%A0%BC%E4%BC%9A%E8%A2%AB%E5%BF%BD%E7%95%A5%0A%7D
- title: åŸå§‹å­—ç¬¦ä¸²å¸¸é‡
  content_markdown: >
    åŸå§‹å­—ç¬¦ä¸²æ”¯æŒå†™å…¥åŸå§‹çš„æ–‡æœ¬è€Œæ— éœ€ä¸ºç‰¹æ®Šå­—ç¬¦è½¬ä¹‰è€Œå¯¼è‡´å¯è¯»æ€§ä¸‹é™ï¼ˆå¦‚åŒå¼•å·ä¸åæ–œæ ï¼‰ï¼Œåªéœ€ä»¥ `r#"` å¼€å¤´ï¼Œä»¥ `"#` ç»“å°¾ã€‚
    Raw strings allow us to write a sequence of characters verbatim by starting
    with `r#"` and ending with `"#`. It lets us insert

    characters that might otherwise confuse a normal string as literals (like
    double quotes and backslashes).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9C%A8%E4%B8%80%E4%BA%9B%E6%83%85%E6%99%AF%E4%B8%8B%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E3%80%82%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D
- title: æ–‡ä»¶ä¸­çš„å­—ç¬¦ä¸²å¸¸é‡
  content_markdown: >
    å¦‚æœä½ éœ€è¦ä½¿ç”¨å¤§é‡æ–‡æœ¬ï¼Œå¯ä»¥å°è¯•ç”¨å®ï¼ˆmarcoï¼‰ `include_str!` æ¥ä»æœ¬åœ°æ–‡ä»¶ä¸­å¯¼å…¥æ–‡æœ¬åˆ°ç¨‹åºä¸­ã€‚
    If you have some very large text, consider using the macro `include_str!` to
    include text from local files in your program:


    ```rust

    let 00_html = include_str!("00_en.html");

    ```
- title: å­—ç¬¦ä¸²ç‰‡æ®µï¼ˆString Slice)
  content_markdown: >
    å­—ç¬¦ä¸²ç‰‡æ®µæ˜¯å¯¹å†…å­˜ä¸­å­—èŠ‚åºåˆ—çš„å¼•ç”¨ï¼Œè€Œä¸”è¿™æ®µå­—èŠ‚åºåˆ—å¿…é¡»æ˜¯æœ‰æ•ˆçš„ utf-8 ç¼–ç ã€‚
    A string slice is a reference to a sequence of bytes in memory that must
    always be valid utf-8.

    å­—ç¬¦ä¸²ç‰‡æ®µæ˜¯ `str` çš„åˆ‡ç‰‡ç‰‡æ®µï¼Œå¿…é¡»æ˜¯æœ‰æ•ˆçš„ utf-8 ç¼–ç ã€‚
    A string slice (a sub-slice) of a `str` slice, must also be valid utf-8.

    `&str` å¸¸ç”¨çš„æ–¹æ³•ï¼š
    Common methods of `&str`:

    * `len` è·å–å­—ç¬¦ä¸²å¸¸é‡çš„å­—èŠ‚é•¿åº¦ï¼ˆä¸æ˜¯å­—ç¬¦é•¿åº¦ï¼‰ã€‚

    *  `starts_with`/`ends_with` ç”¨äºåŸºç¡€æµ‹è¯•ã€‚

    * `is_empty` é•¿åº¦ä¸º 0 æ—¶è¿”å› trueã€‚

    * `find` è¿”å› `Option<usize>`ï¼Œå…¶ä¸­çš„ `usize` ä¸ºåŒ¹é…åˆ°çš„ç¬¬ä¸€ä¸ªå¯¹åº”æ–‡æœ¬çš„ç´¢å¼•å€¼ã€‚
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22%E4%BD%A0%E5%A5%BD%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20first_word%20%3D%20%26a%5B0..6%5D%3B%0A%20%20%20%20let%20second_word%20%3D%20%26a%5B7..11%5D%3B%0A%20%20%20%20%2F%2F%20let%20half_crab%20%3D%20%26a%5B7..9%5D%3B%20%E6%8A%A5%E9%94%99%0A%20%20%20%20%2F%2F%20Rust%20%E4%B8%8D%E6%8E%A5%E5%8F%97%E6%97%A0%E6%95%88%20unicode%20%E5%AD%97%E7%AC%A6%E6%9E%84%E6%88%90%E7%9A%84%E7%89%87%E6%AE%B5%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20first_word%2C%20second_word)%3B%0A%7D
- title: Char
  content_markdown: >
    ä¸ºäº†è§£å†³ä½¿ç”¨ Unicode å¸¦æ¥çš„å›°éš¾ï¼ŒRust æä¾›äº†å°† utf-8 ç¼–ç çš„å­—èŠ‚åºåˆ—è½¬åŒ–ä¸ºç±»å‹ `char` çš„ vector çš„æ–¹æ³•ã€‚
    With so much difficulty in working with Unicode, Rust offers a way to
    retrieve a sequence of utf-8 bytes as a vector of characters of type `char`.


    æ¯ä¸ª `char` é•¿åº¦éƒ½ä¸º 4 å­—èŠ‚ï¼ˆå¯æé«˜å­—ç¬¦æŸ¥æ‰¾çš„æ•ˆç‡ï¼‰ã€‚
    A `char` is always 4 bytes long (allowing for efficient lookup of individual
    characters).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E6%94%B6%E9%9B%86%E5%AD%97%E7%AC%A6%E5%B9%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B1%BB%E5%9E%8B%E4%B8%BA%20char%20%E7%9A%84%20vector%0A%20%20%20%20let%20chars%20%3D%20%22%E4%BD%A0%E5%A5%BD%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20%E7%BB%93%E6%9E%9C%E5%BA%94%E4%B8%BA%204%0A%20%20%20%20%2F%2F%20%E7%94%B1%E4%BA%8E%20char%20%E4%B8%BA%204%20%E5%AD%97%E8%8A%82%E9%95%BF%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%85%B6%E8%BD%AC%E5%8C%96%E4%B8%BA%20u32%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A
- title: å­—ç¬¦ä¸²ï¼ˆStringï¼‰
  content_markdown: >
    **å­—ç¬¦ä¸²`String`** æ˜¯ä»¥å †ï¼ˆheapï¼‰çš„å½¢å¼åœ¨å†…å­˜ä¸­å­˜å‚¨ utf-8 å­—èŠ‚åºåˆ—çš„ä¸€ç§æ•°æ®ç±»å‹ã€‚
    A **String** is a struct that owns a sequence of utf-8 bytes in heap memory.


    ç”±äºå®ƒä»¥å †çš„å½¢å¼æ¥å­˜å‚¨ï¼Œå­—ç¬¦ä¸²å¯ä»¥å»¶é•¿ã€ä¿®æ”¹ç­‰ç­‰ã€‚è¿™äº›éƒ½æ˜¯å­—ç¬¦ä¸²å¸¸é‡ï¼ˆstring literalsï¼‰æ— æ³•æ‰§è¡Œçš„æ“ä½œã€‚
    Because its memory is on the heap, it can be extended, modified, etc. in
    ways string literals cannot.


    å¸¸ç”¨æ–¹æ³•ï¼š
    Common methods:


    * `push_str` ç”¨äºåœ¨å­—ç¬¦ä¸²çš„ç»“å°¾æ·»åŠ å­—ç¬¦ä¸²å¸¸é‡ï¼ˆ&strï¼‰ã€‚

    * `replace` ç”¨äºå°†ä¸€æ®µå­—ç¬¦ä¸²æ›¿æ¢ä¸ºå…¶å®ƒçš„ã€‚

    * `to_lowercase`/`to_uppercase` ç”¨äºå¤§å°å†™è½¬æ¢ã€‚

    * `trim` ç”¨äºå»é™¤å­—ç¬¦ä¸²å‰åçš„ç©ºæ ¼ã€‚


    å¦‚æœå­—ç¬¦ä¸²`String` è¢«é‡Šæ”¾ï¼ˆdropï¼‰äº†ï¼Œå…¶å¯¹åº”çš„å †å†…å­˜ç‰‡æ®µä¹Ÿå°†è¢«é‡Šæ”¾ã€‚
    When a String is dropped, its heap memory is also dropped.


    å­—ç¬¦ä¸²`String` å¯ä»¥ä½¿ç”¨ `+` è¿ç®—ç¬¦æ¥åœ¨å…¶ç»“å°¾å¤„è¿æ¥ä¸€ä¸ª `&str` å¹¶å°†å…¶è‡ªèº«è¿”å›ã€‚ä½†è¿™ä¸ªæ–¹æ³•å¯èƒ½å¹¶ä¸åƒä½ æƒ³è±¡ä¸­çš„é‚£ä¹ˆäººæ€§åŒ–ã€‚
    `String` has a `+` operator that extends the string with a `&str` and
    returns itself, but it might not be as ergonomic as you hope for.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20helloworld%20%3D%20String%3A%3Afrom(%22%E4%BD%A0%E5%A5%BD%22)%3B%0A%20%20%20%20helloworld.push_str(%22%20%E4%B8%96%E7%95%8C%22)%3B%0A%20%20%20%20helloworld%20%3D%20helloworld%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%7D%0A
- title: å°†æ–‡æœ¬ä½œä¸ºå‡½æ•°çš„å‚æ•°
  content_markdown: >
    å­—ç¬¦ä¸²å¸¸é‡ï¼ˆString literalsï¼‰å’Œå­—ç¬¦ä¸²ï¼ˆStringï¼‰ä¸€èˆ¬ä»¥å­—ç¬¦ä¸²ç‰‡æ®µï¼ˆstring sliceï¼‰çš„å½¢å¼ä¼ é€’ç»™å‡½æ•°ã€‚è¿™ç»™è®¸å¤šåœºæ™¯æä¾›äº†å……è¶³çš„çµæ´»æ€§ï¼Œå› ä¸ºæ‰€æœ‰æƒå¹¶æœªè¢«ä¼ é€’ã€‚
    String literals and strings are generally passed around as a string slice to
    functions. This offers a lot of flexibility for

    most scenarios where you don't actually have to pass ownership.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D%EF%BC%81%EF%BC%81%EF%BC%81%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20borrow%20%26'static%20str%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%22%E4%BD%A0%E5%A5%BD%22)%3B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20also%20borrow%20String%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22%E5%86%8D%E8%A7%81%22))%3B%0A%7D%0A
- title: å­—ç¬¦ä¸²æ„å»º
  content_markdown: |
    `concat` å’Œ `join` å¯ä»¥ä»¥ç®€æ´è€Œæœ‰æ•ˆçš„æ–¹å¼æ„å»ºå­—ç¬¦ä¸²ã€‚
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22%E4%BD%A0%E5%A5%BD%22%2C%20%22%20%22%2C%20%22%E4%B8%96%E7%95%8C%22%2C%20%22%EF%BC%81%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A
- title: å­—ç¬¦ä¸²æ ¼å¼åŒ–
  content_markdown: >
    å® `format!` å¯ç”¨äºåˆ›å»ºä¸€ä¸ªä½¿ç”¨å ä½ç¬¦çš„å‚æ•°åŒ–å­—ç¬¦ä¸²ã€‚ï¼ˆä¾‹ï¼š`{}`ï¼‰
    `format!` macro allows us to create a string by defining a parameterized
    string with placeholders for where and how values should be placed (e.g.
    `{}`).


    `format!` å’Œ `println!` ç”Ÿæˆçš„å‚æ•°åŒ–å­—ç¬¦ä¸²ç›¸åŒï¼Œåªæ˜¯ `format!` å°†å…¶è¿”å›è€Œ `println!` å°†å…¶æ‰“å°å‡ºæ¥ã€‚
    `format!` uses the same parameterized strings as `println!`


    
    è¿™ä¸ªå‡½æ•°æ¶‰åŠçš„å†…å®¹å¤ªè¿‡å¹¿æ³›ï¼Œå› è€Œä¸èƒ½åœ¨ *Tour of Rust* ä¸­è¯¦ç»†ä»‹ç»ï¼Œ 
    å¦‚éœ€äº†è§£å®Œæ•´çš„å†…å®¹å¯çœ‹[è¿™é‡Œ](https://doc.rust-lang.org/std/fmt/)ã€‚
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22%E7%94%9F%E6%B4%BB%E8%AF%80%E7%AA%8D%3A%20%7B%7D%22%2Ca)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cf)%3B%0A%7D%0A
- title: å­—ç¬¦ä¸²è½¬æ¢
  content_markdown: |
    è®¸å¤šç±»å‹éƒ½å¯ä»¥é€šè¿‡ `to_string` è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚
    Many types can be converted to a string using `to_string`.

    è€Œæ³›å‹å‡½æ•° `parse` åˆ™å¯å°†å­—ç¬¦ä¸²æˆ–æ˜¯å­—ç¬¦ä¸²å¸¸é‡è½¬æ¢ä¸ºå…¶å®ƒç±»å‹ï¼Œè¯¥å‡½æ•°ä¼šè¿”å› `Result` å› ä¸ºè½¬æ¢æœ‰å¯èƒ½å¤±è´¥ã€‚
    The generic function `parse` can be used to convert strings 
    or string literals into a typed value. This function returns 
    a `Result` because it could fail.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
- title: ç¬¬å…­ç«  - æ€»ç»“
  content_markdown: >
    ç°åœ¨ä½ å·²ç»æ‡‚å¾— Rust ä¸­æ–‡æœ¬çš„åŸºç¡€äº†ï¼æ­£å¦‚ä½ æ‰€è§ï¼ŒUnicode ç¼–ç çš„åº”ç”¨ä½¿æ–‡æœ¬ç›¸å…³æ“ä½œæœ‰äº›æ£˜æ‰‹ï¼Œä½†æ ‡å‡†åº“ä¸­ä¸°å¯Œçš„åŠŸèƒ½å¼¥è¡¥äº†è¿™ä¸€ç¼ºé™·ã€‚
    Now you know the basics of text!  As you have seen, Unicode makes working
    with text a bit tricky, but the standard library 

    has plenty of functionality to make it easy to manage.  


    åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸»è¦æ˜¯ä»ç¨‹åºåŒ–èŒƒå¼çš„è§’åº¦æ¥çœ‹å¾…Rustï¼ˆå³åªæ˜¯å‡½æ•°å’Œæ•°æ®ï¼‰ï¼Œä½†ç°åœ¨æ˜¯æ—¶å€™è®©æˆ‘ä»¬æ¥äº†è§£ä¸€äº›Rustçš„é¢å‘å¯¹è±¡èŒƒå¼çš„ç‰¹æ€§å’Œèƒ½åŠ›äº†ã€‚
    Up to now, we've mostly looked at Rust from the lens of a procedural
    paradigm (i.e. just functions and data),

    but it's time we now talk about traits and the capabilties unlocked by
    Rust's object oriented paradigm.
