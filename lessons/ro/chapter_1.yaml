- title: Capitolul 1 - Ideile și conceptele de bază
  content_markdown: >
    În acest prim capitol vom explora ideile și conceptele de bază despre
    funcții, variabile și tipurile primare de date. Ne bucurăm că

    ne sunteți alături!


    De asemenea, în cazul în care vă întrebați cine este crabul adorabil care
    vă vorbește, mă numesc **Ferris**,
    mascota neoficială a limbajului Rust. Încântat de cunoștință!


    Odată ce vă veți familiariza cu Rust, puteți să vă declarați un **Rustaceu**. Așa
    se numesc toți oamenii care folosesc, contribuie sau sunt interesați de Rust.

- title: Ce este Rust?
  content_markdown: >
    Rust este un limbaj de programare al sistemelor care este cunoscut pentru accentul pe care îl pune
    pe siguranță, performanță și concurență.
    
    Rust este conceput pentru a oferi control la un nivel aproape de hardware asupra resurselor sistemului
    fără a sacrifica abstracţiile de nivel înalt.
    
    Ce are Rust diferit de alte limbaje de programare.
    - proprietate și împrumut
    - durata de viață
    - potrivire de model (pattern matching)
    - concurență fără curse de date (rivalitate de date)
    - trăsături (trait-uri)
    - absența valorii `null` sau a colectării gunoiului (garbage collection)
    - macro-uri
    - pachete numite "cutii" (crates)
    - comunitate și ecosistem
    - UTF-8 și text Unicode
- title: Rust Playground
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Bun%20venit%20în%20locul%20de%20joacă!%20Puteți%20modifica%20codul%20aici.%22)%3B%0A%7D%0A
  content_markdown: >
    În acest curs veți folosi un utilitar interactiv pentru scrierea codului [Rust
    Playground](https://play.rust-lang.org).


    E o modalitate bună de a vă juca cu Rust și a arăta altora
    creativitatea și provocările dumneavoastră!

- title: Ce este println! ?
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++println%21%28%29%3B%0A++++print%21%28%22Este+o+linie+deasupra.+%22%29%3B%0A++++print%21%28%22Ce+tare%2C+nu%3F%22%29%3B%0A++++println%21%28%29%3B+++++%2F%2F+linie+nou%C4%83+la+finalul+consolei%0A%7D%0A
  content_markdown: >
    Spre deosebire de alte limbaje de programare, unde există o funcție pentru
    afişarea la `stdout` (consolă), Rust folosește `macro-urile` **println!** și **print!**.
    Vom vorbi despre `macro-uri` mai târziu.

    > `println!` va afișa un nou caracter de linie nouă `\n` la sfârșitul șirului
    > `print!` nu va folosi `\n` de la sfârșitul textului

- title: Cum să compilezi?
  content_markdown: >
    Pe Linux / MacOS:
    ```
    $ rustc main.rs
    $ ./main
    ```

    Pe sistemele Windows:
    ```
    > rustc main.rs
    > .\main.exe
    ```

    | System de Operare (OS) | comenzi de rulat în terminal      |
    | ---------------------- | --------------------------------- |
    | Linux / MacOS          | $ rustc main.rs <br> $ ./main     |
    | Windows                | > rustc main.rs <br> > ./main.exe |

- title: Variabile
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Rust%20intuie%C8%99te%20tipul%20de%20date%20pentru%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20poate%20fi%20%C8%99i%20explicit%20atunci%20c%C3%A2nd%20stabile%C8%99te%20tipul%20de%20date%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20poate%20declara%20o%20variabil%C4%83%20%C8%99i%20s%C4%83%20o%20ini%C8%9Bializeze%20mai%20t%C3%A2rziu%2C%0A%20%20%20%20%2F%2F%20dar%20acest%20lucru%20nu%20se%20face%20des%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Variabilele sunt declarate folosind cuvântul cheie **let**.


    Atunci când dați unei variabile o valoare, Rust este capabil să deducă tipul acesteia
    în 99%

    din cazuri. Dacă acesta nu poate, puteți adăuga tipul de date la declararea variabilei.


    Observați cum putem să folosim același nume de variabilă (același identificator) de mai multe ori. Acest
    fenomen se numește variable

    shadowing (punere în umbră) și tipul de date se poate schimba pentru referințe ulterioare
    la acel nume de variabilă.


    Numele de variabile sunt mereu scrise sub formă `snake_case` (ex: `my_first_variable`).
- title: Modificarea variabilelor
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Limbajul Rust ține foarte mult la ce variabile pot fi modificate. Variabilele

    fac parte din două categorii:


    * **mutabile** (mutable) - compilatorul va lăsa utilizatorul să modifice și
    să citească valoarea acestui tip de variabile.

    * **imutabile** (immutable) - compilatorul va lăsa utilizatorul doar să citească valoarea acestei variabile.


    Valorile mutabile sunt declarate cu ajutorul cuvântului cheie **mut**.


    O să revenim pentru a vorbi mai multe despre acest concept, dar deocamdată doar fiți
    atenți la acest cuvânt cheie.

- title: Tipuri de date de bază
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++let+a+%3D+13u8%3B%0A++++let+b+%3D+7u32%3B%0A++++let+c+%3D+a+as+u32+%2B+b%3B%0A++++println%21%28%22%7B%7D%22%2C+c%29%3B%0A%0A++++let+t+%3D+true%3B%0A++++println%21%28%22%7B%7D%22%2C+t+as+u8%29%3B%0A%0A++++%0A++++let+d%3A+u32+%3D+12%3B%0A++++%2F%2F+let+e%3A+u32+%3D+-12%3B++%2F%2F+numerele+%60unsigned%60+%28fara+semn%29+includ+doar+nunmerele+pozitive%0A++++let+e%3A+i32+%3D+12%3B%0A++++let+f%3A+i32+%3D+-12%3B%0A++++println%21%28%22%7B%7D+%7B%7D+%7B%7D+%7B%7D%22%2C%0A++++++++++++++++d%2C+-%28d+as+i32%29%2C+e%2C+f%29%3B%0A%7D%0A%0A
  content_markdown: >
    Tipuri de date de bază
    - bool
    - u8
    - u16
    - u32
    - u64
    - u128
    - i8
    - i16
    - i32
    - i64
    - i128
    - usize
    - isize
    - f32
    - f64
    
    | u/i |  semn            | sign                                 |semn |
    | --- | ---------------- | ------------------------------------ | --- |
    | `u` | numere fără semn | doar numere pozitive                 |  +  |
    | `i` | numere cu semn   | atâ numere pozitive, cât și negative |  ±  |

    Rust are o varietate de tipuri de date familiare dumneavoastră:

    * variabilă booleană - `bool` pentru a reprezenta adevărat și fals

    * numere întregi fără semn - `u8` `u16` `u32` `u64` `u128` pentru a reprezenta
    numere naturale

    * numere întregi cu semn - `i8` `i16` `i32` `i64` `i128` pentru a reprezentare numere întregi

    * numere întregi de dimensiunea unui pointer - `usize` `isize` pentru a reprezenta indici

    și dimensiunea datelor în memorie

    * numere cu virgulă mobilă - `f32` `f64` pentru a reprezenta numere reale

    * caractere - `char` pentru reprezentarea unui singur caracter Unicode

    * tuplu - `(valoare, valoare, ...)` pentru trecerea unor secvențe fixe de valori pe stivă

    * tablou - `[valoare, valoare, ...]` o colecție de elemente de același tip; dimensiunea colecției este fixă și devine cunoscută doar în momentul compilării

    * parte (slice) - o parte dintr-o colecție de elemente de același tip; dimensiunea părții devine cunoscută doar în timpul rulării

    * `str` (string slice) - text de lungime cunoscută în timpul rulării


    Sintaxa s-ar putea să fie mai complexă în Rust față de alte limbaje de programare cu care sunteți obișnuiți;

    având în vedere că Rust este un limbaj de programare pentru sisteme, îi pasă de problemele

    de memorie cu care s-ar putea să nu fiți obișnuiți. O să aprofundăm aceste lucruri mai târziu.


    Tipurile numerice pot fi specificate explicit prin adăugarea tipului la finalul numărului (ex: `13u32`, `2u8`).
    
    > nu se poate aplica operatorul unar `-` pe `u8`, `u17`, `u64`, `u128` și `usize`

- title: Conversia tipurilor de bază
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust necesită claritate atunci când vine vorba de tipurile numerice. Nu puteți

    folosi un `u8` pentru un `u32` în mod neglijent fără

    apariția unei erori.


    Din fericire, Rust poate face conversia de la un tip numeric la altul, foarte ușor,
    folosind cuvântul cheie **as**.
- title: Constante
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Pentru%20a%20crea%20un%20m%C4%83r%20%7B%7D%2C%20mai%20%C3%AEnt%C3%A2i%20trebuie%20s%C4%83%20creezi%20un%20univers.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Constantele ne permit să specificăm o valoare folosită uzual de-a lungul

    codului nostru în mod eficient. În loc să copieze valori, constantele înlocuiesc direct,

    acolo unde sunt utilizate, identificatorul de text cu valoarea sa, la momentul compilării.


    Spre deosebire de variabile, constantelor trebuie să li se specifice explicit tipul la declarare.


    Numele constantelor sunt mereu scrise în format `SCREAMING_SNAKE_CASE` (ex: MY\_FIRST\_CONSTANT).

- title: Colecții
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=use+std%3A%3Acollections%3A%3AHashMap%3B%0Ause+std%3A%3Acollections%3A%3AHashSet%3B%0A%0Afn+main%28%29+%7B%0A%0A++++%2F%2F+array%0A++++let+array%3A+%5Bi32%3B+3%5D+%3D+%5B1%2C+2%2C+3%5D%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+array%29%3B%0A++++%0A++++%2F%2F+vector%0A++++let+vector%3A+Vec%3Ci32%3E+%3D+vec%21%5B1%2C+2%2C+3%5D%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+vector%29%3B%0A%0A++++%2F%2F+slice+%28from+other+collection%29%0A++++let+slice+%3D+%26array%5B1..3%5D%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+slice%29%3B%0A++++%0A++++%2F%2F+string%0A++++let+string%3A+String+%3D+String%3A%3Afrom%28%22Hello%2C+Rust%21%22%29%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+string%29%3B%0A++++%0A++++%2F%2F+tuple%0A++++let+tuple%3A+%28i32%2C+f64%2C+u8%29+%3D+%2842%2C+3.14%2C+5%29%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+tuple%29%3B%0A%0A++++%2F%2F+map%0A++++let+mut+map+%3D+HashMap%3A%3Anew%28%29%3B%0A++++map.insert%28%22one%22%2C+1%29%3B%0A++++map.insert%28%22two%22%2C+2%29%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+map%29%3B%0A++++%0A++++%2F%2F+set%0A++++let+mut+set+%3D+HashSet%3A%3Anew%28%29%3B%0A++++set.insert%281%29%3B%0A++++set.insert%282%29%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+set%29%3B%0A%7D%0A
  content_markdown: >
    Rust oferă o varietate de tipuri de colecție care vă permit să stocați și
    manipula datele.

    Principalele colecții din Rust:
    - Matrice
    - Vectori
    - Felii
    - Siruri de caractere
    - Tuplu
    - Hărți hash
    - Seturi de hash
      
    Vom discuta pe fiecare dintre ele mai târziu.

- title: Afişarea cu `{:?}`
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A%0A++++let+my_vector+%3D+vec%21%5B1%2C+2%2C+3%5D%3B%0A++++%2F%2F+println%21%28%22%7B%7D%22%2C+my_vector%29%3B+++%2F%2F+will+generate+an+error%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+my_vector%29%3B%0A++++println%21%28%22%7B%3A%23%3F%7D%22%2C+my_vector%29%3B+++%2F%2F+debug+mode%0A++++%0A++++let+x%3A+i32+%3D+-12%3B%0A++++println%21%28%22%7B%7D%22%2C+x%29%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+x%29%3B%0A++++println%21%28%22%7B%3A%23%3F%7D%22%2C+x%29%3B%09%0A%7D%0A
  content_markdown: >
    Observați că atunci când afișați o colecție, `println!("{}", collection);` nu merge.

    În Rust, `:?` este un specificator de format folosit cu trăsătura `Debug` when
    imprimarea valorilor / colecţiilor de valori.
    
    Când utilizați `println!("{:?}", x);`, compilatorul Rust formatează variabila
    în consecinţă.

    Acest lucru este util în special pentru „colecții” precum vectori, matrice, structuri
    si enumerari.

    `{:#?}` le va tipări într-un mod care este conceput pentru a fi informativ în timpul
    depanare.
    
    | Printing              | tip de bază | colecție |
    | --------------------- | ----------- | -------- |
    | println!("{}", x);    |     ✅       |     ❌    |
    | println!("{:?}", x);  |     ✅       |     ✅    |
    | println!("{:#?}", x); |     ✅       |     ✅    |
- title: Tablouri
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    Un *tablou* este o **colecție de dimensiune fixă** de elemente care conțin date de același
    tip.


    Tipul de date pentru un *tablou* este scris sub forma `[T;N]`, unde T reprezintă tipul elementelor, iar N
    reprezintă dimensiunea fixă cunoscută la momentul compilării.


    Elemente individuale pot fi accesate cu ajutorul operatorului `[x]`, unde *x* este un
    index *usize* (începând cu 0) al elementului pe care doriți să-l accesați.


    Colecțiile cu dimensiune dinamică, deseori numite tablouri dinamice sau variabile, vă
    vor fi prezentate într-un capitol viitor numit **Vectori**.


- title: Vectori
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++%2F%2F+vec%21%5B%5D+este+un+macor%0A++++let+v1+%3D+vec%21%5B1%2C+2%2C+3%2C+4%2C+5%5D%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+v1%29%3B%0A++++%0A++++let+mut+v2+%3D+Vec%3A%3Anew%28%29%3B%0A++++v2.push%281%29%3B%0A++++v2.push%282%29%3B%0A++++v2.push%283%29%3B%0A++++%0A++++%2F%2F+folosim+o+bucla+%60for%60%0A++++for+el+in+%26v1+%7B%0A++++++++print%21%28%22%7B%7D+%22%2C+el%29%3B%0A++++%7D%0A++++println%21%28%29%3B%0A++++%0A++++%2F%2F+folosim+metoda+%60.iter%28%29%60%0A++++for+el+in+v1.iter%28%29+%7B%0A++++++++print%21%28%22%7B%7D+%22%2C+el%29%3B%0A++++%7D%0A++++println%21%28%29%3B%0A++++%0A++++for+i+in+0..v1.len%28%29+%7B%0A++++++++print%21%28%22%7B%7D+%22%2C+v1%5Bi%5D%29%3B%0A++++%7D%0A++++println%21%28%29%3B%0A++++%0A++++%0A++++%2F%2F+vom+vorbi+mai+tarziu+despre+Some+%C5%9Fi+Result%0A++++if+let+Some%28element%29+%3D+v1.get%281%29+%7B%0A++++++++println%21%28%22Second+element%3A+%7B%7D%22%2C+element%29%3B%0A++++%7D+else+%7B%0A++++++++println%21%28%22Index+out+of+bounds.%22%29%3B%0A++++%7D%0A++++%0A%7D%0A
  content_markdown: >
    Vectorii sunt unul dintre cele mai flexibile și mai frecvent utilizate tipuri de colecție în Rust.

    Ele reprezintă un tablou dinamic, care poate fi extins și fac parte din
    biblioteca standard Rust (`std::vec::Vec`). Nu este nevoie să-l „utilizați”. :)

- ttile: Strings
  code: >-
  content_markdown: >
  

- title: Funcții
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20subtract(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20x%20-%20y%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%2242%20%2B%2013%20%3D%20%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%20%20%20%20println!(%2242%20-%2013%20%3D%20%7B%7D%22%2C%20subtract(42%2C%2013))%3B%0A%7D%0A
  content_markdown: >
    O funcție admite zero sau mai mulți parametri.


    În acest exemplu, funcția *add* admite doi parametri de tip `i32`
    (număr întreg cu semn cu dimensiune de 32 de biți).


    La returnarea unei expresii se poate omite cuvântul cheie `return` și
    simbolul punct-virgulă de la final, așa cum s-a procedat în funcția *subtract*.


    Numele funcțiilor sunt mereu scrise în format `snake_case`.


    Sfat: dacă definiți o funcție, datele pe care le admite se numesc parametrii formali.
    Dacă apelați o funcție și îi transmiteți niște date, atunci ele se numesc parametrii actuali.
- title: Returnarea mai multor valori
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20returneaz%C4%83%20un%20tuplu%20de%20valori%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructureaz%C4%83%20tuplul%20%C3%AEn%20dou%C4%83%20variabile%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Funcțiile pot returna mai multe valori prin returnarea unui **tuplu**

    de valori.


    Elementele unui tuplu pot fi accesate folosind indexul acestora. (ex: `my_tuple.0`)


    Rust suportă diferite tipuri de destructurări pe care le vom vedea în multe contexte,
    permițându-ne

    să extragem fracțiuni ale unor structuri de date în moduri ingenioase. Fiți pe fază!
- title: A nu returna nimic
  content_markdown: >
    Dacă pentru o funcție nu se specifică ce tip returnează, aceasta va returna un tuplu gol,
    cunoscut și sub numele de *unitate* (unit).


    Un tuplu gol este reprezentat de `()`.


    Folosirea unui `()` nu este des întâlnită, dar va apărea de suficiente ori, deci este bine să știți
    ce se întâmplă.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20tipul%20pe%20care%20%C3%AEl%20returneaz%C4%83%20este%20%C3%AEn%20mod%20implicit%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20aceast%C4%83%20func%C8%9Bie%20va%20returna%20()%2C%20dac%C4%83%20nu%20este%20specificat%20altceva%20pentru%20returnare%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Afi%C8%99area%20unui%20text%20de%20depanare%20pentru%20a%20%C8%99i%20b%0A%20%20%20%20%2F%2F%20Pentru%20c%C4%83%20e%20greu%20s%C4%83%20print%C4%83m%20nimicul%0A%20%20%20%20println!(%22Valoarea%20lui%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22Valoarea%20lui%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
- title: Capitolul 1 - Concluzie
  content_markdown: >
    Până acu', e bine! Bazele Rust-ului nu sunt așa de rele, nu-i așa?  Am

    aruncat o privire modului în care gândește compilatorul de Rust. Fiind un limbaj de programare
    pentru sisteme,

    acesta ține mult la dimensiunea valorilor în memorie, fie că pot fi
    modificate sau nu,

    și la corectitudinea matematicii pe care o aplicați. În cele ce urmează, ne vom
    întâlni cu niște vechi prieteni:

    teste `if` și bucle `for`.


    Bibliografie:


    * [Youtube: Rust Cast - A deeper dive on Rust's primitive number
    types](https://www.youtube.com/watch?v=n5TRBkbystY)

    * [Website: Rust Book 2018 - A deeper description on basic data
    types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)

    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
