- title: Capitolul 6 - Text
  content_markdown: >
    Acum că înțelegem într-o oarecare măsură modul în care Rust gestionează memoria, suntem pregătiți să discutăm
    mai în detaliu despre folosirea textelor.

    Limbajul Rust acordă o importanță deosebită folosirii textelor în diverse limbi și modului în care sunt reprezentate
    acestea la nivel de octeți, lucruri cu care s-ar putea să nu fiți familiarizați din alte limbaje.

    Acestea fiind spuse, Rust dispune de numeroase unelte pentru gestionarea acestor aspecte.
- title: Șiruri de caractere literale
  content_markdown: >
    Șirurile de caractere literale (eng. *string literals*) sunt întotdeauna reprezentate
    folosind codificarea **utf-8** a setului de caracatere Unicode.


    Șirurile de caractere literale sunt de tipul `&'static str`:

    * `&` înseamnă că referențiază o locație din memorie, iar neavând `&mut`, compilatorul
    nu va permite modificări. 

    * `'static` înseamnă că datele șirului de caractere vor fi disponibile până la sfârșitul
    programului (nu se dă `drop` niciodată).

    * `str` înseamnă că indică o secvență de octeți ce formează întotdeauna un text valid în formatul **utf-8**


    Detalii legate de memorie:

    * Compilatorul de Rust va pune probabil șirul de caractere în segmentul de date al
    memoriei programului dumneavoastră.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+main%28%29+%7B%0A++++let+a%3A+%26%27static+str+%3D+%22salut+%F0%9F%A6%80%22%3B%0A++++println%21%28%22%7B%7D+%7B%7D%22%2C+a%2C+a.len%28%29%29%3B%0A%7D%0A
- title: Ce este utf-8
  content_markdown: "Pe măsură ce tot mai multe limbi au început să fie folosite
  pe calculatoare, lumea a avut nevoie de modalități de reprezentare a mai multor
  caractere de text decât permitea ASCII (1 octet permitea numai 256 de caractere).
  \n\nCa atare, a fost introdus **utf-8**, având o lungime variabilă de octeți (1-4 octeți),
  ceea ce a extins considerabil gama de caractere disponibile.\n\nUn avantaj al 
  caracterelor de dimensiune variabilă este acela că textul nu mai conține octeți inutili
  pentru caractere ASCII foarte comune (acestea necesitând tot un singur octet în **utf-8**).
  \n\nUn dezavantaj al caracterelor de dimensiune variabilă este faptul că 
  nu se mai poate face rapid căutarea unui caracter \n(timp constant **O(1)**)
  cu o simplă indexare (ex.: `my_text[3]` pentru a obține al 4-lea caracter).
  Caracterele anterioare pot avea lățimi variabile, modificând astfel
  locul în care începe de fapt al 4-lea caracter în secvența de octeți.\n\n
  În schimb, trebuie să parcurgem o secvență **utf-8** de octeți pentru a 
  ne da seama unde încep de fapt caracterele Unicode (timp liniar **O(n)**).
  \n\nFerris: \n„Sunt bucuros că pot folosi **utf-8** pentru a
  reprezenta emoticoane cu prietenii mei subacvatici.”
  
  \n<span class=\"emoji\">\U0001F420\U0001F419\U0001F41F\U0001F42C\U0001F40B</span>\n"
- title: Secvențe Escape
  content_markdown: >
    Este o provocare să reprezinți vizual anumite caractere, așa că **secvențele escape** (eng. *escape codes*)
    ne permit să le înlocuim cu un simbol.


    Rust permite folosirea secvențelor escape comune ale limbajelor bazate pe C:

    * `\n` - linie nouă (eng. *newline*)

    * `\r` - carriage return 

    * `\t` - tab

    * `\\` - bară oblică inversă (eng. *backslash*)

    * `\0` - nul (eng. *null*)

    * `\'` - apostrof (eng. *single-quote*)


    Lista completă poate fi consultată
    [aici](https://doc.rust-lang.org/reference/tokens.html).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22Ferris%20spune%3A%5Ct%5C%22salut%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
- title: Șiruri de caractere literale pe mai multe linii
  content_markdown: |
    Șirurile de caractere din Rust se întind, în mod implicit, pe mai multe linii.

    Folosiți un `\` la sfârșitul rândului dacă nu doriți să se facă o întrerupere de rând.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+main%28%29+%7B%0A++++let+haiku%3A+%26%27static+str+%3D+%22%0A++++++++Scriu%2C+%C8%99terg%2C+rescriu%0A++++++++%C8%98terg+iar%C4%83%C8%99i%2C+%C8%99i+apoi%0A++++++++%C3%8Enflore%C8%99te+un+mac.%0A++++++++-+Katsushika+Hokusai%22%3B%0A++++println%21%28%22%7B%7D%22%2C+haiku%29%3B%0A++++%0A++++%0A++++println%21%28%22salutare+%5C%0A++++lume%22%29+%2F%2F+observa%C8%9Bi+cum+spa%C8%9Bierea+de+dinainte+de+%E2%80%9El%E2%80%9D+este+ignorat%C4%83%0A%7D%0A
- title: Șiruri de caractere literale brute
  content_markdown: >
    Șirurile de caractere brute (eng. *raw strings*) ne permit scrierea unei secvențe de caractere,
    cuvânt cu cuvânt, începând cu `r#"` și terminând cu `"#`. Acest lucru ne permite să inserăm

    caractere care altfel ne-ar putea face să confundăm un șir de caractere normal cu unul literal
    (cum ar fi ghilimele duble și backslash-uri).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+main%28%29+%7B%0A++++let+a%3A+%26%27static+str+%3D+r%23%22%0A++++++++%3Cdiv+class%3D%22sfat%22%3E%0A++++++++++++%C8%98irurile+de+caractere+brute+sunt+folositoare+%C3%AEn+unele+situa%C8%9Bii.%0A++++++++%3C%2Fdiv%3E%0A++++++++%22%23%3B%0A++++println%21%28%22%7B%7D%22%2C+a%29%3B%0A%7D%0A
- title: Șiruri de caractere literale din fișiere
  content_markdown: >
    Dacă aveți un text foarte mare, luați în considerare utilizarea macroului `include_str!` pentru
    a include text din fișiere locale în programul dumneavoastră:


    ```rust

    let salut_html = include_str!("salut.html");

    ```
- title: Subșiruri de caractere
  content_markdown: >
    Un subșir de caractere (eng. *string slice*) este o referință la o secvență de octeți din memorie ce trebuie
    să fie întotdeauna în format utf-8 valid.


    Un subșir al unui subșir (eng. *sub-slice*) de `str` trebuie să fie, de asemenea, în format utf-8 valid.


    Metode comune ale `&str`:

    * `len` obține lungimea șirului literal în octeți (nu numărul de caractere).

    * `starts_with`/`ends_with` pentru teste de bază.

    * `is_empty` returnează *true* dacă lungimea este zero.

    * `find` returnează un `Option<usize>` al primei poziții dintr-un text.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+main%28%29+%7B%0A++++let+a+%3D+%22salut+%F0%9F%A6%80%22%3B%0A++++println%21%28%22%7B%7D%22%2C+a.len%28%29%29%3B%0A++++let+primul_cuvant+%3D+%26a%5B0..5%5D%3B%0A++++let+al_doilea_cuvant+%3D+%26a%5B6..10%5D%3B%0A++++%2F%2F+let+jum%C4%83tate_de_crab+%3D+%26a%5B6..8%5D%3B+E%C8%98UEAZ%C4%82%0A++++%2F%2F+Rust+nu+accept%C4%83+sub%C8%99iruri+formate+din+caractere+Unicode+invalide%0A++++println%21%28%22%7B%7D+%7B%7D%22%2C+primul_cuvant%2C+al_doilea_cuvant%29%3B%0A%7D%0A
- title: Tipul `char`
  content_markdown: >
    Cu atâtea dificultăți în lucrul cu Unicode, Rust oferă o modalitate de a
    prelua o secvență de octeți utf-8 ca un vector de caractere de tip `char`.


    Un `char` are întotdeauna o lungime de 4 octeți (ceea ce permite o căutare eficientă după caractere individuale).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+main%28%29+%7B%0A++++%2F%2F+colecteaz%C4%83+caracterele+ca+vector+de+char-uri%0A++++let+chars+%3D+%22salut+%F0%9F%A6%80%22.chars%28%29.collect%3A%3A%3CVec%3Cchar%3E%3E%28%29%3B%0A++++println%21%28%22%7B%7D%22%2C+chars.len%28%29%29%3B+%2F%2F+ar+trebui+s%C4%83+fie+7%0A++++%2F%2F+cum+un+char+ocup%C4%83+4+octe%C8%9Bi%2C+putem+converti+la+u32%0A++++println%21%28%22%7B%7D%22%2C+chars%5B3%5D+as+u32%29%3B%0A%7D%0A
- title: Șiruri de caractere
  content_markdown: >
    Un **șir de caractere** (eng. *string*) este o structură care deține o secvență de octeți utf-8 în memoria heap.


    Deoarece memoria sa se află în heap, aceasta poate fi extinsă, modificată etc. în moduri în care șirurile
    de caractere literale nu pot fi modificate.


    Metode comune:


    * `push_str` pentru a adăuga mai mulți octeți utf-8 la sfârșitul unui șir de caractere.

    * `replace` pentru a înlocui secvențe de octeți utf-8 cu altele.

    * `to_lowercase`/`to_uppercase` pentru a schimba între majuscule și minuscule.

    * `trim` pentru eliminarea spațiilor.


    Atunci când un șir de caractere este eliminat (drop), este eliminată și memoria heap a acestuia.


    Șirile de caractere au un operator `+` care extinde șirul cu un `&str` (șirul din stânga este `consumat`, iar buffer-ul lui
    este refolosit pentru a stoca valoarea finală; șirul din dreapta este doar împrumutat pentru a efectua concatenarea), 
    dar s-ar putea să nu fie atât de ergonomic pe cât sperați.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20salutarelume%20%3D%20String%3A%3Afrom(%22salutare%22)%3B%0A%20%20%20%20salutarelume.push_str(%22%20lume%22)%3B%0A%20%20%20%20salutarelume%20%3D%20salutarelume%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20salutarelume)%3B%0A%7D%0A
- title: Text ca parametru de funcție
  content_markdown: >
    Șirurile de caractere (literale) sunt în general transmise către funcții sub forma unui subșir.
    
    Acest lucru oferă o mare flexibilitate în majoritatea scenariilor, când nu este nevoie
    să transmiteți de fapt proprietatea (eng. *ownership*).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+spune_tare%28mesaj%3A%26str%29%7B%0A++++println%21%28%22%7B%7D%21%21%21%22%2Cmesaj.to_string%28%29.to_uppercase%28%29%29%3B%0A%7D%0A%0Afn+main%28%29+%7B%0A++++%2F%2F+spune_tare+poate+%C3%AEmprumuta+un+%26%27static+str+ca+%26str%0A++++spune_tare%28%22salut%22%29%3B%0A++++%2F%2F+spune_tare+poate%2C+de+asemenea%2C+%C3%AEmprumuta+un+String+ca+%26str%0A++++spune_tare%28%26String%3A%3Afrom%28%22la+revedere%22%29%29%3B%0A%7D%0A
- title: Construirea șirurilor de caractere
  content_markdown: |
    `concat` și `join` sunt două moduri simple, dar eficiente de a construi șiruri de caractere.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20salutarelume%20%3D%20%5B%22salutare%22%2C%20%22%20%22%2C%20%22lume%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20salutarelume)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A
- title: Formatarea șirurilor de caractere
  content_markdown: >
    Macroul `format!` ne permite să creăm un șir de caractere prin definirea unui șir parametrizat
    cu poziții pentru locul și modul în care trebuie plasate valorile (ex.: `{}`).


    `format!` utilizează aceleași șiruri parametrizate ca și `println!`.


    Capabilitățile acestei funcții sunt de o amploare prea mare pentru *Turul limbajului Rust*;
    puteți consulta documentația [aici](https://doc.rust-lang.org/std/fmt/).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn+main%28%29+%7B%0A++++let+a+%3D+42%3B%0A++++let+f+%3D+format%21%28%22secretul+vie%C8%9Bii%3A+%7B%7D%22%2Ca%29%3B%0A++++println%21%28%22%7B%7D%22%2Cf%29%3B%0A%7D%0A
- title: Convertirea șirurilor de caractere
  content_markdown: |
    Multe tipuri pot fi convertite într-un șir de caractere folosind `to_string`.

    Funcția generică `parse` poate fi utilizată pentru a converti șiruri de caractere (literale)
    într-o valoare tipizată. Această funcție returnează un `Result` deoarece ar putea eșua.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
- title: Capitolul 6 - Concluzie
  content_markdown: >
    Acum cunoașteți elementele de bază ale textului! După cum ați văzut, Unicode face lucrul
    cu textul puțin mai complicat, dar biblioteca standard 

    are o mulțime de funcționalități care facilitează gestionarea acestuia.  


    Până acum, am privit limbajul Rust în mare parte prin prisma unei paradigme procedurale
    (adică doar funcții și date),

    dar este momentul să vorbim acum despre trăsături (eng. *traits*) și despre capacitățile oferite de
    paradigma orientată pe obiecte a limbajului Rust.
