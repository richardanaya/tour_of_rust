- title: Capitolul 5 - Proprietatea și împrumutul Datelor
  content_markdown: >
    Rust are o paradigmă unică pentru gestionarea memoriei în comparație cu alte limbaje
    de programare. O să analizăm

    pe rând comportamentul și verificările compilatorului pentru a nu deveni
    copleșitor. Este important să rețineți faptul că

    la finalul zilei, regulile prezentate nu există pentru a vă face viața grea, dar ca să vă ajute
    să scrieți cod mai puțin predispus la erori!
- title: Proprietate
  content_markdown: >
    Instanțiind un tip și **legându-l** de un nume de variabilă vom crea o resursă în memorie
    pe care compilatorul de Rust o va valida
    
    pe tot parcursul **duratei sale de viață**. Variabila de care a fost legat se numește
    **proprietarul** resursei.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Instan%C8%9Biem%20struct-uri%20%C8%99i%20leg%C4%83m%20de%20variabile%0A%20%20%20%20%2F%2F%20pentru%20a%20crea%20resurse%20%C3%AEn%20memorie%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20este%20proprietarul%0A%7D%0A
- title: Gestionarea resurselor bazată pe scope
  content_markdown: |
    Rust folosește finalul unui scope ca moment pentru a destructura și a dealoca o resursă.

    Termenul pentru această acțiune se numește **drop**.

    Detalii despre memorie:
    * Rust nu are un colector pentru deșeuri în memorie.
    * Acest aspect este cunoscut în C++ ca Achiziția Resurselor înseamnă Inițializare ( RAII ).
  code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo_b%20aici%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo_a%20aici%0A%7D%0A
- title: Drop-ul este o acțiune ierarhică
  content_markdown: >
    Atunci când se renunță la un struct (drop), mai întâi se renunță la struct, apoi la
    copiii acestuia individual și așa mai departe.

    Detalii despre memorie:

    * Prin eliberarea automată a memoriei, Rust ne asigură că vor fi mai
    puține pierderi de memorie.

    * Se poate renunța la resurse din memorie o singură dată.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo%20mai%20%C3%AEnt%C3%A2i%0A%20%20%20%20%2F%2F%20apoi%20se%20renun%C8%9B%C4%83%20la%20foo.bar%0A%7D%0A
- title: Mutarea proprietății
  content_markdown: >
    Când un proprietar este trimis unei funcții ca argument, proprietatea este dată
    parametrului funcției.

    După o **mutare a proprietății**, variabila din funcția originală nu mai poate fi
    folosită.


    Detalii despre memorie:

    * În timpul **mutării proprietății**, valoarea din memoria stivei a proprietarului este copiată
    memoria stivei parametrului funcției apelate.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20f%20aici%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20este%20mutat%20%C3%AEn%20func%C8%9Bia%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20nu%20mai%20poate%20fi%20folosit%0A%7D%0A
- title: Returnarea proprietății
  content_markdown: |
    Proprietatea poate fi de asemenea returnată de o funcție.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20proprietatea%20este%20mutat%C4%83%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20devine%20proprietar%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo%20din%20cauza%20termin%C4%83rii%20func%C8%9Biei%0A%7D%0A
- title: Împrumutul proprietății prin Referințe
  content_markdown: |
    Referințele ne permit să împrumutăm accesul la o resursă prin operatorul `&`.

    Asemănător altor resurse, se poate renunța (drop) și la referințe.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20f%20aici%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo%20aici%0A%7D%0A
- title: Împrumutul proprietății mutabile prin Referințe
  content_markdown: >
    Putem de asemenea să împrumutăm accesul mutabil la o resursă cu ajutorul operatorului `&mut`.


    Proprietarul unei resurse nu poate fi mutat sau modificat în timp ce este împrumutat accesul mutabil.


    Detalii despre memorie:

    * Rust previne existența a două căi de a modifica o valoare deținută, deoarece acest lucru
    ar introduce posibilitatea intercalării datelor (data race).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20f%20aici%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20E%C8%98EC%3A%20do_something(foo)%20va%20e%C8%99ua%20pentru%20c%C4%83%0A%20%20%20%20%2F%2F%20foo%20nu%20poate%20fi%20mutat%20%C3%AEn%20timp%20ce%20este%20%C3%AEmprumutat%20%C3%AEn%20mod%20mutabil%0A%0A%20%20%20%20%2F%2F%20E%C8%98EC%3A%20foo.x%20%3D%2013%3B%20va%20e%C8%99ua%20aici%20pentru%20c%C4%83%0A%20%20%20%20%2F%2F%20foo%20nu%20poate%20fi%20modificat%20%C3%AEn%20timp%20ce%20este%20%C3%AEmprumutat%20%C3%AEn%20mod%20mutabil%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20f%20aici%20pentru%20c%C4%83%20nu%20mai%20este%20folosit%20dupa%20acest%20moment%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20acest%20lucru%20func%C8%9Bioneaz%C4%83%20pentru%20s-a%20renun%C8%9Bat%20la%20toate%20referin%C8%9Bele%20mutabile%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20mut%C4%83m%20proprietatea%20lui%20foo%20%C3%AEntr-o%20func%C8%9Bie%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A
- title: Dereferențiere
  content_markdown: >
    Folosind referințe prin `&mut`, putem seta valoarea proprietarului prin folosirea operatorului `*`.


    Puteți de asemenea copia valoarea unei valori deținute folosind operatorul `*` (dacă valoarea
    poate fi copiată - vom discuta despre tipuri care se pot copia în capitole viitoare).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20primim%20o%20copie%20a%20valorii%20proprietarului%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20set%C4%83m%20valoarea%20proprietarului%20prin%20referin%C8%9B%C4%83%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A
- title: Trimiterea Datelor Împrumutate
  content_markdown: >
    Regulile din Rust pentru referințe pot fi rezumate foarte bine de:

    * Rust permite existența unei singure referințe mutabile **sau** a mai multor
    referințe nemutabile, **dar nu a celor două în același timp**.

    * O referință nu trebuie niciodată să aibă **o durată de viață mai lungă** decât proprietarul ei.


    Aceste lucruri nu tind să fie o problemă atunci când trimitem referințe unor funcții.


    Detalii despre memorie:

    * Prima regula pentru referințe previne intercalarea datelor (data races). Ce este o intercalare a datelor?
    Există posibilitatea ca atunci când citim niște date, acestea să fie desincronizate
    din cauza existenței unei entități care modifică acele date în același timp. Acest lucru
    se întâmplă des în programarea pe mai multe thread-uri (multi-threaded).

    * A doua regulă pentru referințe previne folosirea greșită a referințelor legate de
    date care nu mai există în memorie (numite și dangling pointers în C).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20referin%C8%9Ba%20mutabil%C4%83%20f%20aici%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20pentru%20c%C4%83%20se%20renun%C8%9B%C4%83%20la%20toate%20referin%C8%9Bele%20mutabile%0A%20%20%20%20%2F%2F%20%C3%AEn%20cadrul%20func%C8%9Biei%20do_something%2C%20putem%20crea%20alta.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo%20aici%0A%7D%0A
- title: Referințele unor referințe
  content_markdown: |
    Referințele pot fi folosite și pentru referințe.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20x%20aici%20%C8%99i%20putem%20crea%20o%20referin%C8%9B%C4%83%20nemutabil%C4%83%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20y%20aici%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo%20aici%0A%7D%0A
- title: Durate de viață explicite
  content_markdown: >
    Cu toate că Rust nu arată acest lucu în cod, compilatorul înțelege
    duratele de viață a fiecărei variabile și va încerca
    
    să se asigure că nu există nicio referință cu durată de viață mai mare decât proprietarul ei.

    Funcțiile pot fi explicite prin parametrizarea semnăturii cu
    simboluri care ajuta la identificarea

    care parametrii și valori de retur au aceeași durată de viață.


    Specificatorii duratelor de viață mereu încep cu `'` (ex: `'a`, `'b`, `'c`).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20parametrul%20foo%20%C8%99i%20valoarea%20de%20retur%20au%20aceea%C8%99i%20durat%C4%83%20de%20via%C8%9B%C4%83%0Afn%20do_something%3C%27a%3E(foo%3A%20%26%27a%20Foo)%20-%3E%20%26%27a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20x%20aici%2C%20deci%20putem%20crea%20o%20referin%C8%9B%C4%83%20nemutabil%C4%83%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20y%20aici%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo%20aici%0A%7D%0A
- title: Durate de viață multiple
  content_markdown: >
    Specificatorii duratelor de viață ne permit să fim expliciți pentru anumite scenarii
    pe care compilatorul nu le poate rezolva singur

    prin distingerea tuturor componentelor semnăturii unei funcții.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20%C8%99i%20valoarea%20de%20retur%20au%20aceea%C8%99i%20durat%C4%83%20de%20via%C8%9B%C4%83%0A%2F%2F%20foo_a%20are%20o%20durat%C4%83%20de%20via%C8%9B%C4%83%20f%C4%83r%C4%83%20leg%C4%83tur%C4%83%20cu%20foo_b%0Afn%20do_something%3C%27a%2C%20%27b%3E(foo_a%3A%20%26%27a%20Foo%2C%20foo_b%3A%20%26%27b%20Foo)%20-%3E%20%26%27b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo_a%20aici%20pentru%20c%C4%83%20numai%20durata%20de%20via%C8%9B%C4%83%20a%20lui%20foo_b%20continu%C4%83%20de%20aici%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20x%20aici%0A%20%20%20%20%2F%2F%20se%20renun%C8%9B%C4%83%20la%20foo_b%20aici%0A%7D%0A
- title: Durate de viață statice
  content_markdown: >
    O variabilă **statică** e o resursă în memorie creată la momentul compilării care
    există de la începutul rulării unui program și până la
    
    sfârșit. Acestea trebuie să aibă tip explicit.

    
    O **durată de viață statică** e o resursă în memorie care poate exista dincolo
    de terminarea programului. Observați că după această definiție
    
    unele resurse cu durată de viață statică pot fi create în timpul rulării.

    
    Resurse cu durată de viață statică au specificatorul special `'static`.


    **Nu se renunță niciodată** la resursele cu durată de viață statică (drop).


    Dacă resurse cu durată de viață statică conțin referințe, atunci toate trebuie să fie `'static`.
    (orice cu durată de viață mai mică nu va exista suficient de mult).


    Detalii despre memorie:


    * Modificarea variabilelor statice este periculos, pentru că sunt
    accesibile global și pot fi citite de oricine, introducând
    posibilitatea interacalării datelor. Vom vorbi despre provocările aduse de date globale mai târziu.
    * Rust permite folosirea blocurilor `unsafe { ... }` pentru a face operații
    pentru care compilatorul nu poate garanta că sunt sigure din punctul de vedere al memoriei. Despre [<span
    style="color:red; font-weight:
    bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/)
    nu ar trebui să se vorbească fără grijă.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20variabilele%20statice%20pot%20fi%20%C3%AEncadrate%20%C3%AEntr-o%20func%C8%9Bie%0A%20%20%20%20static%20mut%20SECRET%3A%20%26%27static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20string-urile%20%C3%AEntre%20ghilimele%20au%20durat%C4%83%20de%20via%C8%9B%C4%83%20static%C4%83%0A%20%20%20%20let%20msg%3A%20%26%27static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26%27static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20Pute%C8%9Bi%20%C3%AEnc%C4%83lca%20unele%20reguli%2C%20dar%20trebuie%20s%C4%83%20fi%C8%9Bi%20explici%C8%9Bi%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20putem%20seta%20SECRET%20cu%20un%20string%20%C3%AEntre%20ghilimele%0A%20%20%20%20%20%20%20%20%2F%2F%20pentru%20c%C4%83%20are%20de%20asemenea%20durat%C4%83%20de%20via%C8%9B%C4%83%20static%C4%83%20(%60static)%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A
- title: Durate de viață în interiorul Tipurilor de Date
  content_markdown: >
    Similiar funcțiilor, tipurile de date pot fi parametrizate cu specificatorul duratei 
    de viață al membrilor lor.


    Rust se asigură că structurile de date care conțin referințe nu există niciodată
    mai mult timp decât proprietarii către care arată aceste referințe.


    Nu putem avea struct-uri alergând de colo-colo cu referințe către
    nimic!
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A
- title: Capitolul 5 - Încheiere
  content_markdown: >
    Pfiu, felicitări că ai ajuns până aici! Știu că este foarte mult de digerat, dar sunteți 
    deja
    
    pe drumul cel bun pentru a deveni un Rustaceu. Sper că este clar cum Rust ca
    limbaj de programare încearcă să
    
    rezolve multe provocări obișnuite din programarea sistemelor:


    * Modificarea neintenționată a resurselor

    * Neglijarea eliberării resurselor 

    * Eliberarea accidentală a resurselor de două ori

    * Folosirea resurselor după ce acestea au fost eliberate

    * Intercalări de date cauzate de modificarea resurselor citite în același timp de către alți 
    utilizatori

    * Distingerea zonelor din cod unde compilatorul nu poate garanta anumite lucruri


    În următorul capitol vom aplica o parte din aceste noi cunoștințte în timp ce
    învățăm cum Rust gestionează textul.
