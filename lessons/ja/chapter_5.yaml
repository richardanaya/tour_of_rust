- title: 第 5 章 - データの所有権と借用
  content_markdown: |
    Rust には他のプログラミング言語に比べて、メモリを管理するための独特な枠組みがあります。
    ここでは圧倒されないように、コンパイラの動作と検証を一つずつ見ていきます。
    突き詰めると、ここで紹介するルールはあなたを苦しめるためのものではなく、
    コードをエラーになりにくいものにするためのものだと覚えておくことが重要です。
- title: 所有権
  content_markdown: |
    型のインスタンスを作成して変数に**束縛**するとメモリリソースが作成され、そのすべての**ライフタイム**に渡って Rust コンパイラが検証します。
    束縛された変数はリソースの**所有者**と呼ばれます。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E6%A7%8B%E9%80%A0%E4%BD%93%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E5%8C%96%E3%81%97%E3%80%81%E5%A4%89%E6%95%B0%E3%81%AB%E6%9D%9F%E7%B8%9B%E3%81%97%E3%81%A6%E3%83%A1%E3%83%A2%E3%83%AA%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%92%E4%BD%9C%E6%88%90%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E6%89%80%E6%9C%89%E8%80%85%0A%7D%0A
- title: スコープベースのリソース管理
  content_markdown: |
    Rust では、スコープの終わりをリソースのデストラクトと解放の場所として使用します。

    このデストラクトと解放のことを**ドロップ** (drop) と呼びます。

    メモリの詳細:

    * Rust にはガベージコレクションがありません。
    * C++ では Resource Aquisition Is Initialization (RAII)「リソース取得は初期化である」とも呼ばれています。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20%2F%2F%20foo_a%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: ドロップは階層的
  content_markdown: |
    構造体がドロップされると、まず構造体自体がドロップされ、次にその子要素が個別に削除されます。

    メモリの詳細:

    * メモリを自動的に解放することで、メモリリークを軽減できます。
    * メモリリソースのドロップは一度しかできません。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo%20%E3%81%8C%E6%9C%80%E5%88%9D%E3%81%AB%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20%2F%2F%20%E6%AC%A1%E3%81%AB%20foo.bar%20%E3%81%8C%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: 所有権の移動
  content_markdown: |
    所有者が関数の実引数として渡されると、所有権は関数の仮引数に移動 (move) します。

    **移動**後は、元の関数内の変数は使用できなくなります。

    メモリの詳細:

    * **移動**している間、所有者の値のスタックメモリは、関数呼び出しパラメータのスタックメモリにコピーされます。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AE%E6%89%80%E6%9C%89%E6%A8%A9%E3%81%AF%20do_something%20%E3%81%AB%E7%A7%BB%E5%8B%95%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E4%BD%BF%E3%81%88%E3%81%AA%E3%81%8F%E3%81%AA%E3%82%8B%0A%7D%0A
- title: 所有権を返す
  content_markdown: |
    所有権を関数から返すこともできます。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20%E6%89%80%E6%9C%89%E6%A8%A9%E3%81%AF%E5%A4%96%E3%81%AB%E7%A7%BB%E5%8B%95%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E6%89%80%E6%9C%89%E8%80%85%E3%81%AB%E3%81%AA%E3%82%8B%0A%20%20%20%20%2F%2F%20%E9%96%A2%E6%95%B0%E3%81%AE%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%AE%E7%B5%82%E7%AB%AF%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81foo%20%E3%81%AF%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: 参照による所有権の借用
  content_markdown: |
    参照は、`&` 演算子を使ってリソースへのアクセスを借用できるようにしてくれます。

    参照も他のリソースと同様にドロップされます。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: 参照による所有権の可変な借用
  content_markdown: |
    `&mut` 演算子を使えば、リソースへの変更可能なアクセスを借用することもできます。

    リソースの所有者は、可変な借用の間は移動や変更ができません。

    メモリの詳細:

    * データ競合を防止するため、Rust では同時に 2 つの変数から値を変更することはできません。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20%E5%A4%B1%E6%95%97%3A%20do_something(foo)%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%82%A8%E3%83%A9%E3%83%BC%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E5%8F%AF%E5%A4%89%E3%81%AB%E5%80%9F%E7%94%A8%E3%81%95%E3%82%8C%E3%81%A6%E3%81%8A%E3%82%8A%E7%A7%BB%E5%8B%95%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%0A%0A%20%20%20%20%2F%2F%20%E5%A4%B1%E6%95%97%3A%20foo.x%20%3D%2013%3B%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%82%A8%E3%83%A9%E3%83%BC%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E5%8F%AF%E5%A4%89%E3%81%AB%E5%80%9F%E7%94%A8%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E9%96%93%E3%81%AF%E5%A4%89%E6%9B%B4%E3%81%A7%E3%81%8D%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%8B%E3%82%89%E5%85%88%E3%81%A7%E3%81%AF%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%80%81%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20%E5%8F%AF%E5%A4%89%E3%81%AA%E5%80%9F%E7%94%A8%E3%81%AF%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%81%9F%E3%82%81%E5%A4%89%E6%9B%B4%E5%8F%AF%E8%83%BD%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AE%E6%89%80%E6%9C%89%E6%A8%A9%E3%82%92%E9%96%A2%E6%95%B0%E3%81%AB%E7%A7%BB%E5%8B%95%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A
- title: 参照外し
  content_markdown: |
    `&mut` による参照では、`*` 演算子によって参照を外す (dereference) ことで、所有者の値を設定できます。

    `*` 演算子によって所有者の値のコピーを取得することもできます（コピー可能な型については後の章で説明します）。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20%E6%89%80%E6%9C%89%E8%80%85%E3%81%AE%E5%80%A4%E3%82%92%E5%8F%96%E5%BE%97%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20%E5%8F%82%E7%85%A7%E3%81%AE%E6%89%80%E6%9C%89%E8%80%85%E3%81%AE%E5%80%A4%E3%82%92%E8%A8%AD%E5%AE%9A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A
- title: 借用したデータの受け渡し
  content_markdown: |
    Rust の参照に関するルールは、以下のようにまとめられます。

    * Rust では、可変な参照が 1 つだけか、不変な参照が複数かの**どちらか**が許可されます。**両方を同時には使用できません**。
    * 参照は所有者よりも**長く存在**してはなりません。

    これは関数へ参照を渡す際に問題となることはありません。

    メモリの詳細:

    * 参照の最初のルールはデータ競合を防ぎます。データ競合とは？
      データを読み込む際、データへの書き込みが同時に行われると、同期が取れなくなる可能性があります。
      これはマルチスレッドプログラミングでよく起こります。
    * 参照の 2 番目のルールは、存在しないデータへの参照（C 言語ではダングリングポインタと呼ばれる）による誤動作を防ぐためのものです。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20f%20%E3%81%B8%E3%81%AE%E5%8F%AF%E5%A4%89%E3%81%AA%E5%8F%82%E7%85%A7%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20%E9%96%A2%E6%95%B0%20do_something%20%E3%81%A7%E5%8F%AF%E5%A4%89%E3%81%AA%E5%8F%82%E7%85%A7%E3%81%AF%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%E3%81%95%E3%82%8C%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%0A%20%20%20%20%2F%2F%20%E5%88%A5%E3%81%AE%E5%8F%82%E7%85%A7%E3%82%92%E4%BD%9C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%8F%AF%E8%83%BD%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: 参照の参照
  content_markdown: |
    参照の一部を参照することができます。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%E3%81%95%E3%82%8C%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E4%B8%8D%E5%A4%89%E3%81%AA%E5%8F%82%E7%85%A7%E3%81%8C%E4%BD%9C%E6%88%90%E5%8F%AF%E8%83%BD%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: 明示的なライフタイム
  content_markdown: |
    Rust では、常にコードに表れるわけではありませんが、コンパイラはすべての変数のライフタイムを管理しており、参照がその所有者よりも長く存在しないことを検証しようとします。

    関数は、どの引数と戻り値とがライフタイムを共有しているかを、識別のための指定子で明示的に指定できます。

    ライフタイム指定子は常に `'` で始まります（例: `'a`, `'b`, `'c`）。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20%E5%BC%95%E6%95%B0%20foo%20%E3%81%A8%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%AF%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%92%E5%85%B1%E6%9C%89%0Afn%20do_something%3C%27a%3E(foo%3A%20%26%27a%20Foo)%20-%3E%20%26%27a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%E3%81%95%E3%82%8C%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E4%B8%8D%E5%A4%89%E3%81%AA%E5%8F%82%E7%85%A7%E3%81%8C%E4%BD%9C%E6%88%90%E5%8F%AF%E8%83%BD%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20%2F%2F%20foo%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: 複数のライフタイム
  content_markdown: |
    ライフタイム指定子は、関数の引数や戻り値のライフタイムをコンパイラが解決できない場合に、明示的に指定することができます。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20%E3%81%A8%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%AF%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0%E3%82%92%E5%85%B1%E6%9C%89%0A%2F%2F%20foo_a%20%E3%81%AE%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0%E3%81%AF%E5%88%A5%0Afn%20do_something%3C%27a%2C%20%27b%3E(foo_a%3A%20%26%27a%20Foo%2C%20foo_b%3A%20%26%27b%20Foo)%20-%3E%20%26%27b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20%E3%81%93%E3%81%93%E3%81%8B%E3%82%89%E5%85%88%E3%81%AF%20foo_b%20%E3%81%AE%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0%E3%81%97%E3%81%8B%E5%AD%98%E5%9C%A8%E3%81%97%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%80%81%0A%20%20%20%20%2F%2F%20foo_a%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%20%20%20%20%2F%2F%20foo_b%20%E3%81%AF%E3%81%93%E3%81%93%E3%81%A7%E3%83%89%E3%83%AD%E3%83%83%E3%83%97%0A%7D%0A
- title: スタティックライフタイム
  content_markdown: |
    **スタティック**変数は、コンパイル時に作成され、プログラムの開始から終了まで存在するメモリリソースです。
    これらの変数の型は明示的に指定しなければなりません。

    **スタティックライフタイム**は、プログラムの終了まで無期限に持続するメモリリソースです。
    この定義では、スタティックライフタイムを持つリソースは実行時にも作成できることに注意してください。

    スタティックライフタイムを持つリソースには、特別なライフタイム指定子 `'static` があります。

    `'static` リソースは決して**ドロップ**することはありません。

    スタティックライフタイムを持つリソースが参照を含む場合、それらはすべて `'static` でなければなりません（そうでなければ、参照はプログラムの終了前にドロップする可能性があります）。

    メモリの詳細:

    * スタティック変数を変更することは本質的に危険です。なぜならスタティック変数は誰でもグローバルにアクセスして読み取ることができるからです。
      グローバルデータの課題については後ほど説明します。
    * Rust ではコンパイラがメモリを保証できない操作を実行するために、`unsafe { ... }` ブロックを使用することができます。
      [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-jp.rs/rust-nomicon-ja/) について気軽に話してはいけません。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E3%82%B9%E3%82%BF%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E5%A4%89%E6%95%B0%E3%81%AF%E9%96%A2%E6%95%B0%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97%E3%81%A7%E3%82%82%E5%AE%9A%E7%BE%A9%E5%8F%AF%E8%83%BD%0A%20%20%20%20static%20mut%20SECRET%3A%20%26%27static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%E3%81%AF%20%27static%20%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0%0A%20%20%20%20let%20msg%3A%20%26%27static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26%27static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20%E3%83%AB%E3%83%BC%E3%83%AB%E3%82%92%E7%A0%B4%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AF%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%81%8C%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E6%98%8E%E7%A4%BA%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB%E3%81%AF%20%27static%20%E3%81%AA%E3%81%AE%E3%81%A7%20SECRET%20%E3%81%AB%E4%BB%A3%E5%85%A5%E5%8F%AF%E8%83%BD%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A
- title: データ型のライフタイム
  content_markdown: |
    関数と同様に、データ型はメンバのライフタイムを指定できます。

    Rust は、参照を含む構造体が、その参照が指す所有者よりも長く存在しないことを検証します。

    構造体には、何もないところを指している参照を含めることはできません。
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A
- title: 第 5 章 - まとめ
  content_markdown: |
    ここまでお疲れ様でした。
    所有権を受け入れるのは大変だと思いますが、あなたは Rustacean への道を歩んでいます。
    言語としての Rust が、システムプログラミングに共通する課題の多くを解決しようとしているのが、はっきりしたのではないでしょうか。

    * リソースの意図しない変更
    * リソースの解放漏れ
    * リソースを誤って複数回解放
    * 解放されたリソースの利用 
    * 他でリソースを読み込んでいる最中にリソースへの書き込みが行われた場合に発生するデータ競合 
    * コンパイラが保証できない部分の明確化

    次の章では、所有権を応用して、Rust がどのようにテキストを扱うかを見ていきます。
