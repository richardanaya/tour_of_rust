---
common_words:
  en:
    chapter: Chapter
    tor: Tour of Rust
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
  fr:
    chapter: Chapitre
    tor: Tour de Rust
    next: Suivant
    previous: Précédent
    toc: Table des matières
    lessons: Lessons
    untranslated: Non traduit
  de:
    tor: Tour zu Rust
    next: Weiter
    previous: Zurück
    toc: Inhaltsverzeichnis
    lessons: Kapitel
    chapter: Kapitel
    untranslated: Untranslated
  ie:
    tor: Tur de Rust
    next: Sequent
    previous: Precedent
    toc: Tabelle de contenete
    lessons: Lectiones
    chapter: Capitul
    untranslated: Untranslated
  ru:
    chapter: Глава
    tor: Тур по Rust
    next: Далее
    previous: Назад
    toc: Содержание
    lessons: Занятия
    untranslated: Untranslated
  es:
    chapter: Capítulo
    tor: Tour de Rust
    next: Siguiente
    previous: Anterior
    toc: Tabla de Contenidos
    lessons: Unidades
    untranslated: Untranslated
  pt-br:
    chapter: Capítulo
    tor: Um tour por Rust
    next: Próximo
    previous: Anterior
    toc: Índice
    lessons: Unidades
    untranslated: Untranslated
pages:
  - en:
      title: "Hello, <span class=\"emoji\">\U0001F980</span>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Welcome to the *Tour of Rust*. This is meant to be a step by
        step guide through the features of the Rust programming language.  Rust is often
        considered a language with a steep learning curve, I hope I can convince you there's
        a lot to explore before we even get to complex parts.</p><p>You can find this
        guide in these languages:

        * [Deutsch](index_de.html)
        * [English](index.html)
        * [Español](index_es.html)
        * [Français](index_fr.html)
        * [Interlingue](index_ie.html)
        * [Português Brasileiro](index_pt-br.html)
        * [Русский](index_ru.html)

        if you have suggestions on content
        or would like to contribute to translations, checkout out Tour of Rust's 
        [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>

        In this classic example we show Rust's support for unicode
        strings.
    fr:
      title: "Bonjour, <span class=\"emoji\">\U0001F980</span>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Bonjour%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Bienvenue au *Tour de Rust*. Celui-ci a pour but de te guider pas à
        pas au travers des fonctionnalités du language de programmation Rust. Rust est souvant
        considéré comme difficile et il y a beaucoup à explorer avant d'aborder
        les choses complexes.

        tu peux trouver ce guide dans les languages suivants:

        * [Deutsch](index_de.html)
        * [English](index.html)
        * [Español](index_es.html)
        * [Français](index_fr.html)
        * [Interlingue](index_ie.html)
        * [Português Brasileiro](index_pt-br.html)
        * [Русский](index_ru.html)

        si tu as des suggestions sur le contenu
        ou si tu souhaites contribuer aux traductions, rends-toi sur le
        [dépôt github](https://github.com/richardanaya/tour_of_rust).

        Tu peux naviguer au fils du site avec <span class="emoji">⬅️</span> et <span class="emoji">➡️</span>

        Dans cette example classique nous montrons le support des caractères unicode par Rust.
    de:
      title: "Hallo, <span class=\"emoji\">\U0001F980</span>"
      content_markdown: |
        Willkommen auf der *Tour zu Rust*. Hier werden die Features
        aus der Programmiersprache Rust Schritt für Schritt eingeführt. Rust wird oft
        mit einer steilen Lernkurve in Verbindung gebracht - allerdings gibt es schon
        zu Beginn viele spannende Besonderheiten zu entdecken, die hoffentlich dein Interesse
        wecken werden!

        In diesem klassischen Beispiel sehen wir Rust's Unterstützung
        von Unicode Strings.

        Du kannst mittels der rechten <span class="emoji">➡️</span> und linken <span class="emoji">⬅️</span> Pfeiltaste durch die Tour navigieren.

        Wenn du dieses Projekt mit Übersetzungen
        (wie diese hier) oder anderweitig unterstützen willst, wirf einen Blick auf die
        [Github Repository](https://github.com/richardanaya/tour_of_rust).

        Translations:
        * [Deutsch](index_de.html)
        * [English](index.html)
        * [Español](index_es.html)
        * [Interlingue](index_ie.html)
        * [Português Brasileiro](index_pt-br.html)
        * [Русский](index_ru.html)
    ie:
      title: "Salute, <span class=\"emoji\">\U0001F980</span>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20println!(%22Salute%2C%20%F0%9F%A6%80%22)%3B%0A%7D
      content_html:
        <p>Benevenit al <b>Tur de Rust</b>. Li tur intente esser un guide explicat
        passu a passu al caracteristicas trovat in li lingue de programmation Rust. On
        considera Rust un lingue complex con un scarp curve de aprension, ma yo espera
        convicter te que hay multcos a explorar e aprender ante que veni li complexitá.</p>
        <p>In ti-ci exemple on vide li exemple classic de programmation quel monstra li
        subtention de strings (catenes) unicode in Rust.</p><p>Translations:<ul><li><a
        href="index_de.html">Deutsch</a></li><li><a href="index.html">English</a></li><li><a href="index_es.html">Español</a></li><li><a
        href="index_ie.html">Interlingue</a></li><li><a href="index_ru.html">Русский</a></li></ul></p><p>Si
        tu have suggestiones pri contenete o vole contribuer un traduction, ples visitar
        li <a href="https://github.com/richardanaya/tour_of_rust">repositoria github</a>
        del Tur de Rust.</p>
    ru:
      title: "Привет, <span class=\"emoji\">\U0001F980</span>"
      content_markdown: |
        Добро пожаловать в **Тур по Rust**. Это пошаговое руководство
        по возможностям языка программирования Rust. Rust часто ассоциируется как язык,
        который сложен в обучении, я надеюсь, что смогу объяснить многое до того,  как
        мы перейдём к более сложным частям.

        Тур доступен на таких языках:
        * [Deutsch](index_de.html)
        * [English](index.html)
        * [Español](index_es.html)
        * [Français](index_fr.html)
        * [Interlingue](index_ie.html)
        * [Português Brasileiro](index_pt-br.html)
        * [Русский](index_ru.html)

        Если у вас есть предложения по содержимому или вы бы хотели помочь с переводом, проверьте
        Тур по Rust [github репозиторий](https://github.com/richardanaya/tour_of_rust).

        В этом классическом примере мы показываем поддержку юникод строк в Rust.
    es:
      title: "Hola, <span class=\"emoji\">\U0001F980</span>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Hola%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Bienvenido al *Tour de Rust*. Esta es una guía paso a
        paso de las características del lenguaje de programación Rust. Rust está considerado
        como un lenguaje con una elevada curva de aprendizaje, por lo que hay mucho que explorar
        antes de llegar a las partes complejas.</p><p>Puedes encontrar esta
        guía en los siguientes idiomas:

        * [Deutsch](index_de.html)
        * [English](index.html)
        * [Español](index_es.html)
        * [Français](index_fr.html)
        * [Interlingue](index_ie.html)
        * [Português Brasileiro](index_pt-br.html)
        * [Русский](index_ru.html)

        Si tienes alguna sugerencia sobre el contenido
        o quieres contribuir a las traducciones, puedes encontrar el repositorio del 
        Tour de Rust en [github](https://github.com/richardanaya/tour_of_rust).

        Puedes navegar por el curso usando <span class="emoji">⬅️</span> y <span class="emoji">➡️</span>

        En este clásico ejemplo te mostramos el uso de cadenas unicode con Rust.
    pt-br:
      title: "Olá, <span class=\"emoji\">\U0001F980</span>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Ol%C3%A1%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Bem-vindo ao *Tour por Rust*. Este é um guia passo-a-passo pelas características da
        linguagem de programação Rust. Como ela é considerada uma linguagem com uma curva de 
        aprendizado elevada espero convencê-lo que há muito a explorar antes de chegar 
        às partes complexas.

        Você pode ver este guia nestes idiomas:

        * [Deutsch](index_de.html)
        * [English](index.html)
        * [Español](index_es.html)
        * [Français](index_fr.html)
        * [Interlingue](index_ie.html)
        * [Português Brasileiro](index_pt-br.html)
        * [Русский](index_ru.html)

        Caso tenha alguma sugestão a respeito do conteúdo ou queira contribuir com as
        traduções, veja o repositório do Tour por Rust no 
        [github](https://github.com/richardanaya/tour_of_rust).

        Você pode navegar pelo curso usando <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>

        Neste exemplo clássico mostramos o suporte de strings Unicode em Rust.
  - chapter: 1
    en:
      title: Chapter 1 - The Basics
      content_markdown: |
        In this first chapter we're going to be exploring the very basics
        with functions, variables, and the most primitive types. Glad to have you on board!

        Also! In case you are wondering who this adorable crab is speaking to you, I am **Ferris**,
        the unofficial mascot for the Rust programming language. Nice to meet you.
    fr:
      title: Chaptitre 1 - Les fondamentaux
      content_markdown: |
        Dans ce premier chapitre nous allons explorer les fondamentaux
        avec les fonctions, les variables et les types primitifs. Bienvenue à bord!

        Aussi! Si tu te demande qui est cet adorable crabe qui te parle, sache que je m'appelle **Ferris**,
        la mascotte non officiel du language de programmation Rust. Heureux de te renconter!
    de:
      title: Kapitel 1 - Die Basics
      content_html:
        "<p>Im ersten Kapitel werden grundlegende Eigenschaften von Funktionen,
        Variablen und (fast) allen primitiven Datentypen präsentiert. Willkommen an Board!</p><p>Ach
        ja! Falls du dich fragst, wer diese süße sprechende Krabbe ist, das ist <b>Ferris</b>,
        das inoffizielle Maskottchen der Programmiersprache Rust. Sag hallo!</p>"
    ie:
      title: Capitul 1 - Coses Simplic
      content_html:
        "<p>Ci in li unesim capitul, noi va explorar li max simplic coses in
        li lingue, includente functiones, variabiles, e li tipes max primitiv. Felici
        a haver te con noi!</p><p>Hay alquo in plu! Un brevi introduction por li casu
        in quel tu questiona te qui es ti-ci amabil crabe quel parla te: yo nomina me
        <b>Ferris</b>, li mascote ínoficial por li lingue de programmation Rust. Felici
        a incontrar te.</p>"
    ru:
      title: Глава 1 - Основы
      content_markdown: |
        В первой главе мы узнаем основы функций, переменных и примитивных
        типов. Рад видеть вас на борту!

        Также! Если вам интересно, кто этот восхитительный краб, говорящий с вами,
        Я **Феррис** - неофициальный маскот языка программирования Rust. 
        Приятно познакомиться.
    es:
      title: Capítulo 1 - Lo Básico
      content_html:
        "<p>En este primer capítulo vamos a ver lo más básico respecto a funciones, variables y los tipos de datos primitivos.
        ¡Bienvenido a bordo!</p><p>Y por si te estas preguntando quién es el adorable cangrejo parlante, me llamo <b>Ferris</b>,
        y soy la mascota no oficial del lenguaje de programación Rust. Encantado de conocerte.</p>"
    pt-br:
      title: Capítulo 1 - O Básico
      content_markdown: |
        Neste primeiro capítulo iremos explorar o mais básico sobre funções, variáveis e os
        tipos de dados mais primitivos. Bem-vindo a bordo!

        E se por acaso você está se perguntando quem é este adorável caranguejo falante, eu me 
        chamo **Ferris** e sou o mascote não oficial da linguagem de programação Rust.
        Prazer em conhecê-lo.
  - en:
      title: The Rust Playground
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%20You%20can%20modify%20the%20code%20in%20here.%22)%3B%0A%7D%0A
      content_markdown: |
        This tour uses an interactive coding tool from [Rust Playground](https://play.rust-lang.org)

        It's a great way to play around with Rust and show others your creativity and challenges!
    fr:
      title: Le terrain de jeu de Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Bienvenue%20au%20terrain%20de%20jeu%20Rust!%20Tu%20peux%20modifer%20le%20code%20ici.%22)%3B%0A%7D%0A
      content_markdown: |
        Ce tour utilise l'outils de code intéractif [Rust Playground](https://play.rust-lang.org)

        C'est un excellent moyen d'expérimenter avec Rust and montrer aux autres ta créativité et tes challenges!
    de:
      title: The Rust Playground
      content_html:
        <p>Diese Tour macht sich das interaktive Coding Tool von <a href="https://play.rust-lang.org/">https://play.rust-lang.org</a>
        zu Nutze.</p><p>Beispiele in Rust lassen sich so spielend leicht testen. Hierbei
        sind deiner Kreativität auch keine Grenzen gesetzt. Ändere Codeschnipsel, teste
        Funktionen, lass deiner Fantasie freien Lauf!</p>
    ie:
      title: Li Lud-terren Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20println!(%22Benevenit%20al%20lude-terren!%20Tu%20posse%20modificar%20li%20code%20ci.%22)%3B%0A%7D
      content_html:
        <p>Ti-ci tur usa un instrument interactiv por codar quel trova se a
        <a href="https://play.rust-lang.org/">https://play.rust-lang.org</a></p><p>It
        es un bonissim metode por luder con Rust e monstrar li altres tui creativitá e
        defís!</p>
    ru:
      title: The Rust Playground
      content_markdown: |
        Этот тур использует интерактивный компилятор [Rust playground](https://play.rust-lang.org/)

        Это хороший способ попробовать Rust, показать другим вашу креативность и сложные задачи!
    es:
      title: Familiarízate con Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22%C2%A1Bienvenido%20al%20%C3%A1rea%20de%20pruebas!%20Puedes%20modificar%20tu%20c%C3%B3digo%20aqu%C3%AD.%22)%3B%0A%7D%0A
      content_html: |
        <p>En el tour usaremos la siguiente herramienta de programación interactiva: <a href="https://play.rust-lang.org/">https://play.rust-lang.org</a>
        </p><p>De esta manera podrás trastear con Rust y demostrar tu creatividad y aptitudes.</p>
    pt-br:
      title: O Playgroung do Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Bem-vindo%20%C3%A0%20%C3%A1rea%20de%20testes!%20Voc%C3%AA%20pode%20modificar%20seu%20c%C3%B3digo%20aqui.%22)%3B%0A%7D%0A
      content_markdown: |
        Este tour usa a ferramenta de codificação interativa [Rust Playground](https://play.rust-lang.org)

        É uma boa maneira de brincar com Rust e mostrar aos outros a sua criatividade e desafios!
  - en:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Variables are declared using the **let** keyword.

        When assigning a value, Rust will be able to infer the type of your variable 99% of
        the time. If it cannot you may add the type to your variable declaration.

        Notice how we can assign to the same variable name multiple times. This is called variable
        shadowing and the type can be changed for subsequent references to that name.

        Variable names are always in `snake_case`
    fr:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20inf%C3%A8re%20le%20type%20de%20la%20variable%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20on%20peut%20%C3%A9galement%20sp%C3%A9cifier%20explicitement%20le%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20on%20peut%20aussi%20d%C3%A9clarer%20une%20variable%20et%20l%27initialiser%20plus%20tard%2C%20%0A%20%20%20%20%2F%2F%20bien%20qu%27ici%20il%20n%27y%20ait%20pas%20d%27int%C3%A9r%C3%AAt%20%C3%A0%20utiliser%20deux%20lignes%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Les variables sont déclarées en utilisant le mot clé **let**.

        Lorsqu'on assignera une valeur, Rust sera capable d'inférer le type de la variable (99% du
        temps). Si pour quelque raison que ce soit cela n'est pas possible, on peut toujours ajouter le type
        à la déclaration de la variable.

        Remarque comment on peut déclarer la même variable plusieurs fois. Ceci est appelé **shadowing**
        et le type peut être modifié pour les prochaines références à ce nom de variable.

        Les nom de variables sont toujours `snake_case`
    de:
      title: Variablen
      content_html: <p>Variablen werden mit dem Schlüsselwort <code>let</code>
        deklariert.</p><p>Im Regelfall sollte man Rust die Entscheidung überlassen, um
        welchen Datentypen es sich handelt. In Sonderfällen kann der Typ explizit angegeben
        werden.</p><p>Huch, was ist denn bei dem Beispiel los? Die Variable <code>x</code>
        wird mehrmals deklariert?</p><p>Das ist kein Fehler - Rust erlaubt sogenanntes
        <b>variable shadowing</b> (Variable überschatten). Bei Neudeklaration "verfällt"
        die vorige Deklaration und wir können mit der Variable arbeiten, als ob es sie
        davor noch nie gegeben hätte. Der Datentyp darf sich dabei auch ändern.</p><p>Variablennamen
        werden ebenfalls in <code>snake_case</code> geschrieben.</p>
    ie:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%2F%2F%20rust%20infere%20li%20tip%20de%20x%0A%20%20let%20x%20%3D%2013%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%0A%20%20%2F%2F%20rust%20posse%20anc%20specificar%20li%20tip%20explicitmen%0A%20%20let%20x%3Af64%20%3D%203.14159%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%0A%20%20%2F%2F%20rust%20posse%20anc%20declarar%20in%20prim%2C%20poy%20inicialisar%2C%20ma%20ti-ci%20metode%0A%20%20%2F%2F%20es%20rarmen%20usat%0A%20%20let%20x%3B%0A%20%20x%20%3D%200%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%7D
      content_html:
        ' <p>On declara variabiles con li clave-parol <b>let</b>.</p><p>Quande
        on assigna un valore, Rust va posser inferer li tip del variabile con un certitá
        de 99%. Si it ne posse, tu posse adjunter li tip al declaration por li variabile.</p><p>A
        notar es qualmen noi posse assignar li sam nómine por un variabile plu quam un
        vez. Ti-ci metode es nominat variable shadowing ("variabil-ombration") in quel
        li tip va posser changear se por referenties sequent por ti nómine.</b></p><p>Nómines
        por variabiles sempre usa <code>snake_case</code> (minuscules con infra-strecs)</p>'
    ru:
      title: Переменные
      content_markdown: |
        Переменные объявляются с помощью ключевого слова **let**.

        Когда ей присваивается значение, Rust в состоянии вывести тип переменной в 99% случаях.
        Если вывод невозможен, вы можете добавить тип в объявлении переменной.

        Заметьте, как мы можем присвоить значение одной и той же переменной несколько раз. Это называется
        сокрытие переменной (variable shadowing), её тип может быть изменен в последующих
        присваиваниях.

        Название переменных всегда `snake_case`
    es:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Rust%20deduce%20el%20tipo%20de%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tambi%C3%A9n%20puede%20ser%20expl%C3%ADcito%20con%20el%20tipo%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tambi%C3%A9n%20puede%20declarar%20primero%20e%20inicializar%20despu%C3%A9s%2C%20pero%20es%20poco%20com%C3%BAn%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Las variables se declaran usando la palabra reservada **let**.

        Al asignar un valor, Rust podrá deducir el tipo de la variable el 99% de las veces.
        Si no puede, tú mismo podrás especificar el tipo al declarar una variable.

        Fíjate en cómo podemos declarar variables con el mismo nombre varias veces. Esto se llama
        sombreado (shadowing) de variables y se puede modificar el tipo para futuras referencias a ese nombre.

        Los nombres de las variables se escriben siempre en `snake_case`
    pt-br:
      title: Variáveis
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Rust%20infere%20o%20tipo%20de%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tamb%C3%A9m%20pode%20ser%20expl%C3%ADcito%20com%20o%20tipo%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tamb%C3%A9m%20pode%20declarar%20primero%20e%20inicializar%20depois%2C%20mas%20%C3%A9%20incomum%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Variáveis são declaradas usando a palavra-chave **let**.

        Quando atribuimos um valor, o Rust poderá inferir o tipo da sua variável em 99% dos casos.
        Se não for possível, você poderá especificar o tipo ao declarar a variável.

        Veja que podemos atribuir valores à mesma variável várias vezes. Isto é chamado
        *sobreamento* de variáveis (shadowing) e podemos mudar o seu tipo para referências
        futuras a esse nome.

        Os nomes das variáveis são sempre em `snake_case`.
  - en:
      title: Changing Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Rust cares a great deal about what variables are modifiable. Values
        fall into two types:

        * **mutable** - the compiler will allow the variable to be written to and read from.
        * **immutable** - the compiler will only allow the variable to be read from.

        Mutable values are denoted with a **mut** keyword.

        We will have more to say on this concept later, but for now just keep an eye out for this keyword.
    fr:
      title: Modification des variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Rust prend très au sérieux le fait de savoir si une variable est modifiable ou non.
        Les variables peuvent être de deux types:

        * **modifiable** - la variable peut être modifiée et sa valeur lue
        * **immuable** - seule la valeur de la variable peut être lue

        Les variables modifiables sont préfixées du mot clé **mut**.

        Nous aurons plus à dire à ce sujet par la suite.
    de:
      title: Variablenwerte ändern
      content_html:
        ' <p>Rust sorgt sich sehr darum, welche Variablen verändert werden können
        und welche nicht. Daher gibt es die folgende Unterscheidung:</p><ul><li><b>mutable</b>
        - der Speicherort der Variable kann beschrieben und gelesen werden</li><li><b>immutable</b>
        - der Speicherort der Variable kann nur gelesen werden</li></ul><p>Variablen,
        die verändert werden können, werden mit einem extra <code>mut</code>
        Schlüsselwort gekennzeichnet.</p><p>Auf dieses Konzept wird im späteren Verlauf
        noch mehr eingegangen, für jetzt ist es wichtig zu wissen, dass "mutable" Variablen
        beschrieben werden können.</p>'
    ie:
      title: Changear valores
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%20%20x%20%3D%2013%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%7D
      content_html:
        " <p>Rust sucia se mult pri li valores queles es modificat. Valores
        possede du tipes:</p><ul><li><b>mutabil</b> - li loc in memorie posse esser inscrit
        e leet</li><li><b>ínmutabil</b> - li loc in memorie posse esser solmen leet</li></ul><p>On
        denota sempre li valores mutabil con li clave-parol <b>mut</b></p><p>Pri to noi
        va parlar plu con detallies, ma por li momente ples solmen atenter pri ti-ci parol-clave
        quel monstra que un cose es modificabil</p>"
    ru:
      title: Изменение переменных
      content_markdown: |
        Rust уделяет много внимания тому, какие значения могут быть изменены.
        Значения (переменные) делятся на два типа:

        * **mutable** - область памяти, в которую можно записать и считать
        * **immutable** - область памяти, с которой можно только считать

        Mutable значения всегда каким-то образом обозначены с помощью ключевого слова **mut**.

        Мы поговорим об этом позже, сейчас просто следите за этим ключевым словом и тем, какие элементы
        могут быть изменены.
    es:
      title: Modificar Variables
      content_markdown: |
        En Rust es importante tener en cuenta qué valores se modifican.
        Los valores se dividen en dos tipos:

        * **mutables** - la ubicación en memoria puede ser escrita y leída
        * **inmutables** - la ubicación en memoria sólo puede ser leída

        Los valores mutables siempre se denotan con la palabra reservada **mut**.

        Hay mucho más que explicar aún sobre este concepto, pero de momento presta atención solamente a la palabra reservada.
        We will have more to say on this concept later, but for now just keep an eye out for this keyword.
    pt-br:
      title: Modificando valores
      content_markdown: |
        Em Rust é importante levar em consideração quais valores serão alterados. Os valores
        se dividem em dois tipos:

        * **mutáveis** - o compilador permitirá que a variável seja lida e gravada.
        * **imutáveis** - o compilador permitirá apenas a leitura da variável.

        Valores mutáveis são marcados com a palavra-chave **mut**.

        Temos muito a explicar ainda sobre este conceito, mas por enquanto apenas preste atenção 
        nesta palavra-chave.
  - en:
      title: Basic Types
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20by%20default%20this%20is%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20by%20default%20this%20is%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rust has a variety of familiar types:

        * booleans - `bool` for representing true/false
        * unsigned integers - `u8` `u32` `u64` `u128` for representing positive whole numbers
        * signed integers - `i8` `i32` `i64` `i128` for representing positive/negative whole numbers
        * pointer sized integers - `usize` `isize` for representing indexes
        and sizes of things in memory
        * floating point - `f32` `f64`
        * tuple - `(value, value, ...)` for passing fixed sequences of values on the stack
        * arrays - a collection of similar elements with fixed length known at compile time
        * slices - a collection of similar elements with length known at runtime
        * `str`(string slice) - text with a length known at runtime

        Text might be more complex than you are used to in other languages,
        since Rust is a system programming language, it's cares about memory 
        issues you might not be used to. We will be going into this in detail later.

        Numeric types can be explicitly specified by appending the type to the end of the number (e.g. `13u32`, `2u8`)
    fr:
      title: Types primitifs
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20par%20d%C3%A9faut%20c%27est%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20par%20d%C3%A9faut%20c%27est%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rust possède une variété de types primitifs dont certains te seront certainement famillier:

        * booleans - `bool` pour représenter vrai/faux
        * entiers non signés - `u8` `u32` `u64` `u128` pour représenter les entiers positifs
        * entiers signés - `i8` `i32` `i64` `i128` pour représenter les entiers positifs et négatifs
        * entiers de taille de pointeur - `usize` `isize` pour représenter les indices
        et tailles des éléments en mémoire
        * nombre réel à virgule flottante - `f32` `f64` pour représenter notamment les nombres rationnels
        * tuple - `(valeur, valeur, ...)` pour passer une séquence finie de valeurs sur la pile
        * tableaux - `[valeur, valeur, ...]` une collection d'éléments de même type dont la taille est
        fixe (déterminé à la compilation)
        * slices - similaire aux tableaux à l'exception que la taille est redimensionable
        * chaîne de caractères - `str` pour représenter une suite de caractères

        Les chaînes de caractères peuvent être plus complexes comparées aux autres languages de programmation,
        étant donné que Rust est un language de programmation système, il est sensible aux problèmes
        de mémoire que tu n'es peu-être pas abituer à traiter. Nous reviendrons sur ce sujet un peu plus tard.

        Les types numériques peuvent être explicitement spécifiés en ajoutant le type après
        le nombre e.g. `13u32`, `2u8`)
    de:
      title: Basistypen
      content_html:
        "<p>Rust besitzt eine vielzahl an bekannten Datentypen <ul><li>booleans
        - <code>bool</code> für true/false bzw. wahr/falsch Werte</li><li>unsigned
        integers - <code>u8</code><code>u32</code><code>u64</code>
        für positive Ganzzahlen (inkl. 0 für die Mathematiker)</li><li>signed integers
        - <code>i8</code><code>i32</code><code>i64</code>
        für vorzeichenbehaftete Ganzzahlen</li><li>pointer sized integers - <code>uint</code><code>isize</code>
        für Indizes und Größen im Speicher</li><li>floating point - <code>f32</code><code>f64</code>
        für Dezimalzahlen</li><li>text zeug - <code>str</code><code>char</code></li><li>tuple
        - <code>(value,value,...)</code> zum Übergeben von Wertsequenzen auf
        dem Stack<li>slices - <code>&[T]</code> um Views in Sequenzen zu referenzieren
        (hier evt bessere Übersetzung finden)</ul></p><p>Wir sehen schon, dass es einiges
        zum Anpacken geben wird!</p><p>Eine Warnung vorweg: text-Zeug wird etwas komplexer
        sein als du es vielleicht von anderen Programmiersprachen gewohnt bist, da Rust
        eine Systemprogrammiersprache ist und daher mehr auf effektives Speichermanagement
        fokussiert. Keine Panik auf der Titanic aber, wir werden unser Bestes geben, dich
        darauf vorzubereiten!</p><p>Noch ein Hinweis: Numerische Datentypen können auch
        nach dem Zahlenliteral spezifiziert werden (z.B. <code>13u32</code>)</p>"
    ie:
      title: Basic tipes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%0A%20%20%20%20let%20c%20%3D%204.3f64%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20frase%20%3D%20%22salute%20munde!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20frase%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Rust possede un varietá de tipes familiari <ul><li>booleanes - <code>bool</code>
        por representar true/false (ver/fals)</li><li>unsigned integers (integrales ínsignat)
        - <code>u8</code><code>u32</code><code>u64</code><code>u128</code>
        por representar integrales positiv</li><li>signed integers (integrales signat)
        - <code>i8</code><code>i32</code><code>i64</code><code>i128</code>
        por representar integrales sive positiv sive negativ</li><li>pointer sized integers
        (integrales con puntator-mesurat grandore) - <code>usize</code><code>isize</code>
        por representar indexes e grandores de coses in memorie</li><li>floating point
        (punctu flottant) - <code>f32</code><code>f64</code></li><li>con
        relation a textu - <code>str</code><code>char</code></li><li>tuple
        - <code>(value, value,...)</code> por passar fixat sequenties de valore
        sur li stack (li cumul)<li>slices (tranches) - <code>&[T]</code> por
        referer visus ad-in sequenties de valores in memorie</ul></p><p>Noi va parlar
        pri alcunes ex ili plu detalliatmen plu tard.</p><p>Un avise in prim: textu va
        posser esser plu complicat quam tui experientie con altri lingues, pro que Rust
        es un lingue de programmation por sistemas quel orienta se pri problemas de memorie
        con quel fórsan tu ne ha experientie. Noi va parlar plu detalliatmen pri textu
        plu tard.</p><p>Nota qualmen on posse explicitmen specificar tipes numeric per
        afixar li tip directmen pos li numeró (p.e. <code>13u32</code>)</p>"
    ru:
      title: Базовые типы
      content_markdown: |
        Rust имеет много знакомых типов: 

        * булевые - `bool` представляет true/false
        * беззнаковые целочисленные - `u8`, `u32`, `u64`, `u128` представляют положительные числа
        * знаковые целочисленные - `i8`, `i32`, `i64`, `i128` представляют положительные/отрицательные числа 
        * целочисленные размером указателя - `usize`, `isize` представляют индексы и размеры
        * числа с плавающей точкой - `f32`, `f64`
        * относятся к тексту - `str`, `char`
        * кортежи - `(значение,значение,...)` представляют фиксированную последовательность
        значений, размещаются на стеке
        * слайсы (slices) - `&[T]` представляют указатель на последовательность значений в памяти

        Мы поговорим о нескольких из пунктов в деталях чуть позже.

        Справедливое предупреждение: текст может быть более сложным, чем вы привыкли на 
        других языках, поскольку Rust является языком системного программирования,
        он ориентирован на решение проблем, свясвязанных с памятью, с которыми вы,
        возможно, не сталкивались. Мы поговорим о текстовых данных позже.
         
        Заметьте, как числа могут быть приведены к определенному типу, если явно указать 
        тип в конце числа (пример `13u32`)
    es:
      title: Tipos básicos
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20Por%20defecto%20es%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20Por%20defecto%20es%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22%C2%A1Hola%2C%20mundo!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Rust tiene una variedad de tipos que puede que te resulten familiares: <ul><li>booleanos - <code>bool</code>
        para representar verdadero/falso</li><li>números enteros sin signo - <code>u8</code><code>u32</code><code>u64</code><code>u128</code>
        para representar números enteros positivos</li><li>números enteros con signo - <code>i8</code><code>i32</code><code>i64</code><code>i128</code>
        para representar números enteros positivos y negativos</li><li>números enteros de tamaño de puntero
        - <code>usize</code><code>isize</code> se usan para representar índices y tamaños de elementos en memoria
        </li><li>números en coma flotante - <code>f32</code><code>f64</code></li>
        <li>En relación a textos - <code>str</code><code>char</code></li><li>tuplas
        - <code>(valor,valor,...)</code> para pasar secuencias fijas de valores en la pila
        <li>slices - <code>&[T]</code> para referenciar “vistas” en
        secuencias de valores en la memoria</ul></p><p>Profundizaremos en algunos más adelante.</p>
        <p>Advertencia: los formatos de texto pueden ser más complejos de lo que estás acostumbrado
        en otros lenguajes, ya que Rust es un lenguaje de programación de sistemas, está orientado
        a gestionar los problemas de la memoria, algo a lo que puedes no estar acostumbrado.
        Entraremos en detalles sobre los textos más tarde.</p><p>Observa cómo los tipos numéricos pueden especificarse
        explícitamente añadiendo el tipo al final del número (por ejemplo, <code>13u32</code>)</p>"
    pt-br:
      title: Tipos básicos
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20infere%20o%20tipo%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20infere%20o%20tipo%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22Ol%C3%A1%2C%20mundo!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rust tem uma variedade tipos que lhe serão familiares:

        * booleanos - `bool` para representar verdadeiro/falso
        * números inteiros sem sinal - `u8` `u32` `u64` `u128` para representar números inteiros positivos
        * números inteiros com sinal - `i8` `i32` `i64` `i128` para representar números inteiros positivos e negativos
        * ponteiros de números inteiros - `usize` `isize` para representar índices e o comprimento de coleções em memória
        * números de ponto flutuante - `f32` `f64`
        * tuplas - `(value, value, ...)` para passar sequências de valores fixas para a pilha
        * matriz - uma coleção de elementos similares com comprimento fixo conhecidos em tempo de compilação
        * slices - uma coleção de elementos similares com comprimento conhecido em tempo de execução
        * `str` (string slice) - texto com comprimento conhecido em tempo de execução

        Textos podem ser mais complexos do que você está acostumado com outras linguagens. Uma vez que o Rust 
        é uma linguagem de programação de sistemas, ele cuida do gerenciamento de memória de uma maneira que
        pode não estar familiarizado. Entraremos em detalhes mais adiante.

        Tipos numéricos podem ser especificados explicitamente adicionando o tipo ao final do 
        número (por exemplo: `13u32`, `2u8`)
  - en:
      title: Basic Type Conversion
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
      content_markdown: |
        Rust requires explicitness when it comes to numeric types. One cannot
        use a `u8` for a `u32` casually without
        error.

        Luckily rust makes numeric type conversions very easy with the **as** keyword.
    fr:
      title: Conversion des types primitifs
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
      content_markdown: |
        Avec Rust, l'utilisation des types est stricte. On ne peut pas
        utiliser une variable de type `u8` et la faire passer pour une variable de type `u32`.

        Heureusement Rust rend la conversion de type très facile grâce au mot clé **as**.
    de:
      title: Basistypen konvertieren
      content_html:
        "<p>Rust vordert explizite Konvertierungen, wenn es um Zahlentypen geht.
        Ein <code>u8</code> (8-bit unsigned integer) kann nicht mit einem <code>u32</code>
        locker aus dem Handgelenk zusammengerechnet werden ohne das Programm zum Absturz
        zu bringen.</p><p>Glücklicherweise ist auf die Konvertierung mit dem <code>as</code>
        Schlüsselwort Verlass.</p>"
    ie:
      title: Conversion de basic tipes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20let%20a%20%3D%2013u8%3B%0A%20%20let%20b%20%3D%207u32%3B%0A%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20let%20t%20%3D%20true%3B%0A%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D
      content_html:
        "<p>Rust exige explicitá quande it acte se pri tipes numeric. On ne
        posse usar un <code>u8</code> hasardalmen por un <code>u32</code>
        sin un erra.</p><p>Felicimen, conversiones de tipes numeric es facil in Rust con
        li clave-parol <b>as</b>.</p>"
    ru:
      title: Преобразование базовых типов
      content_markdown: |
        Rust требует явности, когда речь идет о числовых типах. Нельзя использовать
        `u8` вместо `u32` случайно, это ошибка.

        К счастью, Rust имеет ключевое слово **as**, которое позволяет очень легко преобразовывать
        типы.
    es:
      title: Conversión de tipos básica
      content_html:
        "<p>Rust requiere ser explícito cuando se trata de tipos numéricos. No se
        puede usar un <code>u8</code> cuando necesitemos un <code>u32</code> sin que se produzca
        un error.</p><p>Por suerte, Rust hace que las conversiones de tipos numéricos sean
        muy fáciles con la palabra reservada <b>as</b>.</p>"
    pt-br:
      title: Conversão de tipos básica
      content_markdown: |
        O Rust requer que sejamos explícitos quando se trata de tipos numéricos. Não podemos
        usar um `u8` quando precisamos usar um `u32` sem que se produza um erro.

        Por sorte o Rust faz com que as conversões de tipos numéricos sejam muito siples usando 
        a plavra-chave **as**.
  - en:
      title: Constants
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Constants allow us to specify a common value that's used through
        out our code many times efficiently.  Instead of copying values like variables
        where they are used, constants directly replace the text identifier where they
        are used with their value at compile time.

        Unlike variables, constants must always have explicit types

        Constant names are always in `SCREAMING_SNAKE_CASE`
    fr:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%CF%80%20est%20le%20rapport%20de%20la%20circonf%C3%A9rence%20d%E2%80%99un%20cercle%20%C3%A0%0A%20%20%20%20%20%20%20%20son%20diam%C3%A8tre%20et%20une%20valeur%20approximative%20est%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Les constantes permettent de spécifier une valeur qui sera utilisée
        à plusieurs endroits du code et de manière efficiente. A la différence des variables, 
        rust remplace le nom des constantes par leurs valeurs lors de la compilation.

        Le type des constantes doit être explicitement déclaré, ce qui n'est pas le cas pour
        les variables.

        Les noms de constantes sont toujours de la forme `SCREAMING_SNAKE_CASE`.
    de:
      title: Konstanten
      content_html: "<p>Konstanten (<code>const</code>) erlauben uns einen Wert
        in der Kompilierzeit zu setzen, die in unserem Code eingesetzt werden. Kompilierzeit
        ist hier das Stichwort: anstelle von Variablen sitzen dann an Orten, an denen
        Konstanten eingestetzt werden, die Werte selbst.</p><p>Anders als bei Variablen
        muss bei Konstanten der Datentyp explizit angeben werden.</p><p>Die Namensgebung
        erfolgt generell in <code>SCREAMING_SNAKE_CASE</code>.</p>"
    ie:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Por%20crear%20un%20%7B%7D%20de%20pom%20desde%20li%20comense%2C%20on%20deve%20in%20prim%20crear%20un%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Constantes possibilisa li specification de valores comun quel noi
        usa tra nor code con un eficientie mult vezes plu grand.  Vice copiar valores
        quam variabiles chascun vez ú ili es usat, constantes remplazza li textu-identificator
        directmen con lor valore in li locs ú on usa les.</p><p>In contraste a variabiles,
        constantes deve sempre posseder un tip explicit</p><p>Nómines de constantes es
        sempre in <code>SCREAMING_SNAKE_CASE</code> (majuscules con infra-strecs)</p>"
    ru:
      title: Константы
      content_markdown: |
        Константы (**const**) позволяют нам указать неизменяемую переменную,
        которую можно использовать много раз. Вместо того, чтобы копировать значение,
        как делают переменные, имя константы заменяется на значение во время компиляции.

        В отличии от переменных, константам нужно явно обозначать их тип.

        Имена констант всегда пишутся в верхнем регистре `SCREAMING_SNAKE_CASE`
    es:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Vamos%20de%20paseo%2C%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20PI%2C%20PI%2C%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Las constantes nos permiten especificar un valor común que se utiliza
        muchas veces a lo largo de nuestro código de manera eficiente. En vez de copiar valores
        como variables en el lugar donde se usan, las constantes reemplazan directamente el
        identificador de texto (donde se haya usado) por su valor en tiempo de compilación.</p>
        <p>A diferencia de las variables, el tipo de las constantes se debe especificar explícitamente.</p>
        <p>Los nombres de las constantes se escriben siempre en <code>SCREAMING_SNAKE_CASE</code></p>"
    pt-br:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Para%20fazer%20uma%20%7B%7Dzza%2C%20voc%C3%AA%20deve%20primeiro%20criar%20o%20Universo.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        As constantes nos permitem especificar um valor comum que pode ser usado
        muitas vezes por todos o nosso código de maneira eficiente. Ao invés de
        copiar os valores como variáveis onde serão utilizadas, as constantes substituirão
        o identificador de texto pelo seu valor onde quer que estejam sendo usadas em tempo
        de compilação.

        Diferentemente das variáveis, o tipo das constantes devem ter sempre declarados.

        Os nomes das constantes são sempre em `SCREAMING_SNAKE_CASE`.
  - en:
      title: Arrays
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
      content_markdown: |
        An *array* is a fixed length collection of data elements all of the same type.

        The data type for an *array* is `[T;N]` where T is the elements' type, and N is the fixed length known at compile-time.

        Individual elements can be retrieved with `[x]` operator where *x* is a *usize* index (starting at 0) of the element you want.
    fr:
      title: Tableaux
      content_markdown: |
        Un *tableau* est une collection de taille fixe (celle-ci doit être
        connue à la compilation) contenant des éléments du même type.

        Le type d'un *tableau* est `[T;N]` où T est le type de l'élément
        et N est la taille du tableau.

        Chaque élément du tableau peut être récupéré avec la syntaxe `[x]` où *x* est
        l'index de type *usize* (commençant à 0) de l'élément à récupérer.
    de:
      title: Arrays
      content_markdown: |
        Need translation
    ie:
      title: Arrays
      content_markdown: |
        Need translation
    ru:
      title: Arrays
      content_markdown: Need translation
    es:
      title: Arrays
      content_markdown: |
        Un *array* es una colección de longitud fija de elementos de datos del mismo tipo.

        El tipo de datos para un *array* es `[T;N]` siendo T el tipo del elemento, y N la longitud fija conocida en tiempo de compilación.

        Los elementos individuales se pueden recuperar con el operador `[x]`, siendo *x* un índice de tipo *usize* (empezando por 0) del elemento que quieras.
    pt-br:
      title: Matrizes
      content_markdown: |
        Uma *matriz* é uma coleção de elementos de tamanho fixo todos os seu valores do mesmo tipo.

        O tipo de dado para uma *matriz* é `[T;N]`, onde T é o tipo dos valores e
        N é o comprimento fixo conhecido em tempo de compilação.

        Os elementos podem ser recuperados individualmente com o operador `[x]`, onde *x* 
        é o índice do tipo *usize* (começando de 0) do elemento que deseja recuperar.
  - en:
      title: Functions
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
      content_markdown: |
        A function has zero or more parameters.

        In this example, add takes two arguments of type `i32` (integer of 32-bit
        length).

        Function names are always in `snake_case`.
    fr:
      title: Fonctions
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
      content_markdown: |
        Une fonction possède 0 ou plusieurs paramètres.

        Dans cette example, la fonction `add` accèpte 2 arguments de type `i32` (entier
        de longueur 32-bit).

        Les noms de fonctions sont toujours de la forme `snake_case`.
    de:
      title: Funktionen
      content_html:
        "<p>Eine Funktion kann eine beliebige (nicht-negative) Anzahl an Argumenten
        bzw. Parametern aufnehmen.</p><p>In diesem Beispiel verlangt die Funktion <code>add</code>
        zwei Parameter vom Typ <code>i32</code> (32 Bit Ganzzahl).</p><p>Funktionsnamen
        sollten im <code>snake_case</code> Format vergeben werden.</p>"
    ie:
      title: Functiones
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20adddir(x%3Ai32%2C%20y%3Ai32)%20-%3E%20i32%20%7B%0A%09return%20x%20%2B%20y%20%2F%2F%20Ci%20on%20utilisa%20return%20por%20monstrar%20que%20anc%20Rust%20possede%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20ti%20clave-parol%20comun%20in%20altri%20lingues%20de%20programmation%2C%20%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20ma%20li%20plu%20idiomatic%20metode%20por%20retornar%20un%20valore%20in%20Rust%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20es%20simplicmen%20scrir%20x%20%2B%20y%20sin%20un%20punctu-comma%20(%3B)%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Dunc%3A%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20return%20x%20%2B%20y%20%3C--%20retorna%20un%20valore%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20x%20%2B%20y%20%3C--%20retorna%20un%20valore%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20x%20%2B%20y%3B%20%3C--%20retorna%20null%20valore%20(nota%20li%20%3B%20pos%20x%20%2B%20y)%0A%7D%0A%0Afn%20main()%20%7B%0A%09println!(%22%7B%7D%22%2Cadddir(42%2C%2013))%3B%0A%7D
      content_html:
        "<p>Un function posse prender null o plu argumentes.</p><p>In ti-ci
        exemple, adddir prende du parametres del tip <code>i32</code> (integer
        (númere integrale) del longore 32-bit).</p><p>Nómines de functiones es sempre
        in <code>snake_case</code> (minuscules con infra-strecs)</p>"
    ru:
      title: Функции
      content_markdown: |
        Функция может принимать ноль или больше аргументов.

        В этом примере, функция **add** принимает два аргумента типа `i32`
        (целочисленное, длиной в 32 бита).

        Имена функций всегда пишутся в `змеином_регистре`(snake_case)
    es:
      title: Funciones
      content_markdown: |
        Una función tiene cero o más parámetros.

        En este ejemplo, "add" recibe dos argumentos de tipo `i32` (entero de 32 bits).

        Los nombres de las funciones se escriben siempre en `snake_case`.
    pt-br:
      title: Funções
      content_markdown: |
        Uma função pode receber zero ou mais parâmetros.

        Neste exemplo, *add* recebe dois parâmetros do tipo `i32` (número inteiro de 32 bits).

        Os nomes das funções são sempre em `snake_case`.
  - en:
      title: Multiple Return Values
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Functions can return multiple values by returning a **tuple**
        of values.

        Tuple elements can be referenced by their index number.

        Rust supports various kinds of destructuring that we will see in many forms, allowing
        us to extract sub-pieces of data structures in ergonomic ways. Be on the lookout!
    fr:
      title: Multiple Return Values
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20la%20variable%20result%20est%20un%20tuple%20qui%20contient%0A%20%20%20%20%2F%2F%20deux%20entiers%20de%20type%20%60i32%60%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20la%20destructuration%20permet%20d%27affecter%20directement%0A%20%20%20%20%2F%2F%20les%20valeurs%20aux%20variables%20a%20et%20b%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Une fonction peut retourner plusieurs valeurs en retournant un *tuple* de valeurs.

        Les éléments du tuple peuvent être référencés par leur index.

        Rust nous donne la possibilité d'extraire simplement certaines parties de structures de données,
        c'est la destructuration. Nous en verrons d'autres formes par la suite. Garde l'oeil ouvert!
    de:
      title: Mehrere return-Variablen
      content_html:
        <p>Funktionen können mehrere Variablen auf einmal zurückgeben mittels
        eines <b>tuples</b>.</p><p>Die Werte können danach über einen Index gelesen werden.</p><p>Rust
        unterstützt verschiedene Formen von "destructuring", wodurch sich Wertepaare auf
        einzelne Variablen aufteilen lassen. Halte Ausschau danach!</p>
    ie:
      title: Multiplic retorn-valores
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20interchangear(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20retorna%20un%20tuple%20de%20retorn-valores%0A%20%20%20%20let%20resulta%20%3D%20interchangear(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20resulta.0%2C%20resulta.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructura%20li%20tuple%20in%20du%20n%C3%B3mines%20de%20variabiles%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20interchangear(resulta.0%2C%20resulta.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_html:
        "<p>Functiones posse retornar multiplic valores per retornar un <b>tuple</b>
        de valores. (N.B. un tuple es parent con -tuplic in Interlingue-Occidental)</p><p>On
        posse referer al valores per lor position in li tuple.</p><p>Rust subtene varie
        tipes de destructuration quel noi va vider in pluri formes. To possibilisa li
        extraction de sub-pezzes de data ergonomicmen. Esse atentiv por it!</p>"
    ru:
      title: Возвращение нескольких значений
      content_markdown: |
        Функции могут возвращать несколько значений с помощью **кортежа** (tuple)
        значений.

        Доступ к значениям осуществляется по их позиции в кортеже.

        Rust поддерживает разные виды деструктуризации, которые вы увидите в разных формах.
        Это позволяет нам извлекать частички структур данных удобным способом. Смотрите
        внимательно!
    es:
      title: Múltiples variables de retorno
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20intercambiar(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Devuelve%20una%20tupla%20de%20valores%0A%20%20%20%20let%20result%20%3D%20intercambiar(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20Desestructura%20la%20tupla%20en%20dos%20variables%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20intercambiar(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_html:
        "<p>Las funciones pueden devolver múltiples valores utilizando una <b>tupla</b>
        de valores.</p><p>Los valores se pueden referenciar por su posición en la tupla.</p><p>Rust
        soporta varios modos de desestructuración que veremos en diferentes formas, esto nos
        permite extraer subconjuntos de estructuras de datos de manera práctica.
        ¡Presta mucha atención!</p>"
    pt-br:
      title: Returno de Múltiplos Valores
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20devolve%20uma%20tupla%20de%20valores%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20desestrutura%20a%20tupla%20para%20duas%20vari%C3%A1veis%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Funções podem devolver múltiplos valores retornando uma **tupla** de valores.

        Os elementos da tupla podem ser referenciados pelo seu índice.

        O Rust suporta vários modos de desestruturação que veremos em diferentes formas, 
        permintindo extrair subconjuntos de dados de maneira prática.
  - en:
      title: Returning Nothing
      content_markdown: |
        If no return type is specified for a function, it returns an empty tuple, also known as a *unit*

        An empty tuple is represented by `()`

        Using `()` is uncommon, but will come up often enough that it's good to know whats happening.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    fr:
      title: Ne rien retourner
      content_markdown: |
        Si une fonction ne spécifie aucun type de retour, celle-ci retourne un tuple vide,
        également appelé *unité*

        Un tuple vide est représenté par `()`

        Il est rare d'utiliser `()`, mais cela arrive et il est bon de le savoir.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20le%20type%20de%20retour%20est%20implicitement%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20cette%20fonction%20retournera%20()%0A%20%20%20%20%2F%2F%20si%20rien%20n%27est%20sp%C3%A9cifi%C3%A9%20en%20retour%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20le%20symbol%20%3A%3F%20signifie%20qu%27on%20souhaite%20utilis%C3%A9%0A%20%20%20%20%2F%2F%20un%20formatage%20sp%C3%A9cial%20de%20debug%20qui%20affichera%0A%20%20%20%20%2F%2F%20notamment%20le%20type%20des%20variables%20a%20et%20b%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    de:
      title: Keine return-Variablen
      content_markdown: |
        Wenn kein Variablentyp als Rückgabewert einer Funktion angegeben wird, gibt die Funktion ein leeres Tupel zurück, auch bekannt als *unit*.

        Ein leeres Tupel wird durch ein `()` repräsentiert.

        Die leeren Klammern werden selten verwendet, finden trotzdem an manchen Orten ihren Platz, weshalb wir diese hier kurz zum Vorschein bringen wollen.
    ie:
      title: Retornar necos
      content_markdown: |
        Si null tip de retorn es specificat por un function, it retorna un vacui tuple, anc conosset quam un *unit* (li tal-nominat tip unitic)

        On representa un vacui tuple per `()`

        In Rust it passa presc ínvisibil por que on ne mey esser distractet de it, ma it es bon a saver que un functiona retornant necos retorna un fact un vacui tuple.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20crear_necos()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20li%20tip%20de%20retorn%20es%20implicat%20quam%20()%0Afn%20crear_necos2()%20%7B%0A%20%20%20%20%2F%2F%20ti-ci%20functiona%20va%20retornar%20()%20si%20on%20specifica%20nullcos%20a%20retornar%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20crear_necos()%3B%0A%20%20%20%20let%20b%20%3D%20crear_necos2()%3B%0A%0A%20%20%20%20%2F%2F%20Printant%20un%20string%20(catene)%20debug%20por%20a%20e%20b%0A%20%20%20%20%2F%2F%20Pro%20que%20printar%20%27necosit%C3%A1%27%20es%20desfacil%0A%20%20%20%20println!(%22Li%20valore%20de%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22Li%20valore%20de%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    ru:
      title: Возврат пустого значения
      content_markdown: |
        Если в функции не указан возвращаемый тип, она возвратит пустой кортеж, также известный как **юнит**

        Пустой кортеж представлен `()`

        Использование `()` немного необычно, но вы будете часто это замечать, поэтому хорошо знать, что это такое.

    es:
      title: No devolver nada
      content_markdown: |
        Si no se especifica un tipo de retorno para una función, esta devuelve una tupla vacía, también conocida como *unidad*.

        Una tupla vacía se representa mediante `()`

        El uso de `()` es poco común, pero es necesario saber su significado ya que aparecerá de vez en cuando.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20no_hagas_nada()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20El%20valor%20de%20retorno%20es%20impl%C3%ADcitamente%20()%0Afn%20no_hagas_nada2()%20%7B%0A%20%20%20%20%2F%2F%20Esta%20funci%C3%B3n%20devuelve%20()%20si%20no%20se%20especifica%20nada%20que%20devolver%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20no_hagas_nada()%3B%0A%20%20%20%20let%20b%20%3D%20no_hagas_nada2()%3B%0A%0A%20%20%20%20%2F%2F%20Mostrando%20una%20sentencia%20de%20depuraci%C3%B3n%20para%20a%20y%20b%0A%20%20%20%20%2F%2F%20porque%20es%20dif%C3%ADcil%20no%20mostrar%20nada%0A%20%20%20%20println!(%22El%20valor%20de%20a%20es%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22El%20valor%20de%20b%20es%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    pt-br:
      title: Retornando nada
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_nada()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20o%20tipo%20de%20retorno%20%C3%A9%20implicitamente%20()%0Afn%20faz_nada2()%20%7B%0A%20%20%20%20%2F%2F%20esta%20fun%C3%A7%C3%A3o%20ir%C3%A1%20devolver%20()%20se%20nada%20for%20especificado%20para%20retornar%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20faz_nada()%3B%0A%20%20%20%20let%20b%20%3D%20faz_nada2()%3B%0A%0A%20%20%20%20%2F%2F%20Exibindo%20uma%20string%20de%20depura%C3%A7%C3%A3o%20para%20a%20e%20b%0A%20%20%20%20%2F%2F%20Porque%20%C3%A9%20dif%C3%ADcil%20n%C3%A3o%20mostrar%20nada%0A%20%20%20%20println!(%22O%20valor%20de%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22O%20valor%20de%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Se nenhum tipo for especificado para o retorno de uma função, ele devolve uma tupla vazia,
        também conhecida como *unit*.

        Uma tupla vazia é representada por `()`.

        O uso de `()` é incomum, mas é necessário saber o seu significado uma vez que aparecerá de vez em quando.
  - en:
      title: Chapter 1 Conclusion
      content_markdown: |
        Nice job so far! The basics of Rust aren't so bad, right?  We're
        getting a peek into how the Rust compiler thinks.  As a system programming language 
        it cares a lot about the size  of values in memory, whether things can be modified or not, 
        and making sure your math is what you want it to be. Next up we'll be looking at some old friends 
        `if` and `for` loops.
    fr:
      title: Chapter 1 Conclusion
      content_markdown: |
        Bon travail! Les fondamentaux de rust ne sont pas si dûr que ça, n'est-ce pas? Nous avons
        commençé à voir comment le compilateur de Rust fonctionne. Celui-ci prend soin de la taille
        des éléments en mémoires, s'assure si les choses peuvent êtres modifiées ou non, et fait en sorte
        qu'on ne se mélange pas les pinceaux dans les types de variables. Tu peux donc avoir un aperçu de
        ce qu'on appele la **sécurité** de Rust qui est l'un des aspects le plus mis en avant de Rust.
        Le compilateur fait en sorte que le résultat du programme exécuté est celui espéré.
        Par la suite, nous allons voir de vieux amis les structures de contrôles `if`
        et les boucles `for`.
    de:
      title: Kapitel 1 Fazit
      content_html:
        <p>Puh! Das wäre schon mal geschafft! War nicht so übel, oder? Wir wissen
        schon ein wenig, wie der Compiler denkt. Er setzt viel Wert auf Speichermanagement,
        wie groß Variablen sind, ob diese "mutable" sind oder nicht, und ob du garantiert
        weißt, welche Datentypen zusammenaddiert werden. Das sind erste kleine Einblicke
        in die <b>Sicherheit</b>, die sich durch die gesamte Rustsprache hindurchzieht
        - nicht unbedingt die Sicherheit des Systems, aber die Sicherheit, dass du weißt,
        was du tust.</p><p>Im nächsten Kapitel werden wir uns mit den altbekannten Datenkontrollstrukturen
        <code>if</code> und <code>for</code> Schleifen beschäftigen!
        Worauf wartest du noch!</p>
    ie:
      title: Capitul 1 - Conclusion
      content_html:
        "<p>Bon labor til nu! Li coses basic in Rust ne es tam mal, ne ver?
        Vi til nu un curt regarde pri qualmen pensa li compilator Rust. It sucia se mult
        pri li grandore de valores in memorie, qualmen on posse modificar un cose o ne,
        e si tui matematica es vermen to quel tu intente scrir o ne. Tis-ci es micri previsiones
        del principie de <b>safety</b> (securitá) quel prevale tra Rust. Li compilator
        solmen intente far cert que tui code fa to quo tu intente que it fa! A sequer
        noi va vider li old amics <code>if</code> (si) e cicles usant <code>for</code>
        (por).</p>"
    ru:
      title: Раздел 1. Заключение
      content_markdown: |
        Хорошая работа! Основы Rust не так уж и плохи, правда?  Мы получили
        представление о том, как думает компилятор Rust. Ему очень важно знать размер
        значений в памяти, могут ли значения изменятся или нет, и делает необходимое для
        того, чтобы математические операции вели себя так, как вы предполагали. Это маленькое
        превью принципов **безопасности**(safety), которые так распространены в Rust.
        Компилятор всего лишь хочет, что бы ваш код делал то, что вы ожидаете! Далее мы
        рассмотрим конструкцию `if` и цикл `for`.
    es:
      title: Capítulo 1 - Conclusión
      content_html:
        "<p>¡Buen trabajo! No ha sido tan complicado, ¿verdad? Esta ha sido
        una visión general de cómo trabaja el compilador de Rust. Como ya has comprobado,
        hay que tener muy en cuenta el tamaño de los valores en memoria, las cosas que se
        pueden modificar y las que no, y asegurarse de que tu código de el resultado que esperas.
        Estos son pequeños avances de un principio de <b>seguridad</b> que prevalece a través
        de Rust. Este compilador pretende asegurarse de que tu código hace lo que esperas.
        A continuación echaremos un vistazo a algunos viejos conocidos: <code>if</code>
        y <code>for</code>.</p>"
    pt-br:
      title: Capítulo 1 - Conclusão
      content_markdown: |
        Bom trabalho! O básico do Rust não foi tão ruim, não é? Este foi só o
        comecinho de como o compilador Rust trabalha. Por ser uma linguagem de
        programação de sistemas, ele se importa muito com o tamanho dos valores
        na memória, se as coisas podem ser modificadas ou não, e garantir que sua
        matemática seja o que você quer que seja. A seguir veremos alguns velhos
        amigos: `if` e `for`.
  - chapter: 2
    en:
      title: Chapter 2 - Basic Control Flow
      content_markdown: |
        In this chapter let's talk about basic control flow methods in Rust.
        If you are familiar with C based languages you'll feel right at home and maybe
        enjoy a surprise or two.
    de:
      title: Kapitel 2 - Ein bisschen Kontrollfluss
      content_html:
        "<p>In diesem Kapitel werden wir Kontrollflussmethoden in Rust angehen
        (engl. control flow methods). Wenn du ein bisschen Erfahrung in C-verwandten Sprachen
        hast, dürftest du dich hier wie zu Hause fühlen - die ein oder andere Überraschung
        sei dennoch zu erwarten.</p>"
    ie:
      title: Chapter 2 - Basic Control-flution
      content_html:
        "<p>Lass nos in ti-ci capitul parlar pri li metodes de basic control-flution
        in Rust. Si tu ha ja conossentat te con lingues basat sur C tu va trovar it tre
        familiari, ma con un o du plesent surprises.</p>"
    ru:
      title: Глава 2 - Управление потоком исполнения
      content_markdown: |
        В этой главе мы поговорим про базовые методы управления потоком
        исполнения в Rust. Если вы знакомы с Си-подобными языками вы будете чувствовать
        себя как дома и может быть встретите пару сюрпризов"
    es:
      title: Capítulo 2 - Estructuras de control básicas
      content_html:
        "<p>En este capítulo hablaremos de las estructuras de control básicas en Rust.
        Si estás familiarizado con lenguajes basados en C, te sentirás como en casa y quizá
        te lleves alguna que otra sorpresa.</p>"
    pt-br:
      title: Capítulo 2 - Controle de Fluxo Básico
      content_markdown: |
        Neste capítulo falaremos das estruturas de controle de fluxo básicas em Rust.
        Se você está familiarizado com linguagens baseadas em C, se sentirá em casa
        e, quem sabe, algumas agradáveis surpresas.
  - en:
      title: if/else if/else
      content_markdown: |
        Code branching in Rust is not surprising.

        Conditions don't have parentheses! Did we ever really need them? Our logic now looks nice and clean.

        All your usual logical operators still work: `!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22less%20than%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22is%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22greater%20than%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
    de:
      title: if/else if/else
      content_html:
        "<p>Codeverzweigungen (branching) bieten viel bekanntes.</p><p>Außer
        den fehlenden Klammern! Wer braucht die schon? Logik war noch nie so sauber.</p><p>Die
        üblichen logischen Operatoren funktionieren noch: <code>!</code><code>!=</code><code>||</code><code>&&</code><code>&lt;</code><code>&gt;</code><code>&lt;=</code><code>&gt;=</code></p><p>Versuch
        ein paar von den Operatoren in dem Code einzubauen.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20age%20%3D%2017%3B%0A%20%20%20%20%0A%20%20%20%20if%20age%20%3C%2016%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Keine%20alkoholischen%20Getr%C3%A4nke%22)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%7D%20else%20if%20age%20%3E%3D%2016%20%26%26%20age%20%3C%2018%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20checking%20(age%20%3E%3D%2016)%20could%20have%20been%20omitted%20here%0A%20%20%20%20%20%20%20%20println!(%22Darf%20Bier%2C%20Wein%20und%20Sekt%20kaufen.%20Keine%20Spirituosen%22)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Darf%20alles%20kaufen%22)%3B%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: if/else if/else
      content_html:
        "<p>Code-ramification in Rust ne es surprisant.</p><p>Conditiones ne
        prende parentheses! Esque noi vermen alquande besonat les? Nu nor logica sembla
        nett e clar.</p><p>Omni tui usual operatores logical functiona quam sempre: <code>!</code><code>!=</code><code>||</code><code>&&</code><code>&lt;</code><code>&gt;</code><code>&lt;=</code><code>&gt;=</code></p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20exemple()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20return%20-1%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20return%200%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20return%201%3B%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: if/else if/else
      content_markdown: |
        Ветвление кода в Rust не особо отличается от того, к чему вы привыкли.

        Условия не оборачиваются в круглые скобки! Разве они нам действительно нужны? Теперь условные
        конструкции выглядят красиво и чисто.

        Все логические операторы, к которым вы так привыкли, всё еще работают: 
        `!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`
    es:
      title: if/else if/else
      content_html:
        "<p>La ramificación de código en Rust te resultará familiar.</p><p>Las condiciones no
        van entre paréntesis, ¿acaso son necesarios? De esta manera nuestra lógica se ve más limpia y sencilla.</p>
        <p>Los demás operadores lógicos conocidos siguen funcionando: <code>!</code><code>!=</code><code>||</code><code>&&</code><code>&lt;</code><code>&gt;</code><code>&lt;=</code><code>&gt;=</code></p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22es%20menor%20que%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22es%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22es%20mayor%20que%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
    pt-br:
      title: if/else if/else
      content_markdown: |
        A ramificação de código em Rust não tem nenhuma novidade.

        Não há parêntesis nas condições! Realmente precisamos deles? Assim a nossa
        lógica fica mais simples e limpa.

        Todos os nossos operadores lógicos habituais continuam funcionando: 
        `!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22menor%20que%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22igual%20a%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22maior%20que%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
  - en:
      title: loop
      content_markdown: |
        Need an infinite loop?

        Rust makes it easy.

        `break` will escape a loop when you are ready.</p><p>`loop` has a secret we'll talk about soon.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
    de:
      title: loop
      content_html: "<p>Unendliche Schleifen gefällig? <code>loop</code> macht
        es möglich!</p><p>Mit <code>break</code> kann diese Schleife unterbrochen
        werden.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%20%22%2C%20x)%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
    ie:
      title: loop (cicle)
      content_html:
        "<p>Tu besona un cicle ínfinit?</p><p>Con Rust it es simplic.</p><p>Con
        <code>break</code> on exea un cicle quande on es pret.</p><p><code>loop</code>
        have un secrete pri quel noi va parlar max bentost.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
    ru:
      title: loop
      content_markdown: |
        Нужен бесконечный цикл?

        В Rust есть такой.

        `break` прервёт цикл, когда вам будет нужно.

        `loop` имеет секрет, о котором мы вскоре поговорим.
    es:
      title: loop
      content_html:
        "<p>¿Necesitas un bucle infinito?</p><p>Con Rust es muy sencillo.</p><p><code>break</code>
        nos permite salir de un bucle cuando lo indiquemos.</p><p><code>loop</code> guarda un
        secreto del que te hablaremos más adelante.</p>"
    pt-br:
      title: loop
      content_markdown: |
        Precisando de um loop infinito?

        Rust faz isso fácil.

        O `break` nos permite sair de um loop quando precisar.

        O `loop` tem um segredo do qual falaremos em breve.
  - en:
      title: while
      content_markdown: |
        `while` lets you easily add a condition to a loop.

        If the condition evaluates to `false`, the loop will exit.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: while
      content_html: "<p><code>while</code> Schleifen werden so lange ausgeführt,
        bis aus der angegeben Kondition <code>false</code> evaluiert wird.</p>"
    ie:
      title: while (durant)
      content_html: "<p><code>while</code> possibilisa te adjunter un condition
        a un cicle.</p><p>Si li condition evalua se a <code>false</code>, li
        cicle va exear.</p>"
      code-ie: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: while
      content_markdown: |
        `while` это тот же `loop`, только с условием.

        Если условие будет `false`, цикл закончится.
    es:
      title: while
      content_html:
        "<p><code>while</code> permite añadir fácilmente una condición
        al bucle.</p><p>El bucle terminará cuando la condición se evalúe a <code>false</code></p>"
    pt-br:
      title: while
      content_markdown: |
        O `while` permite que você estabeleça facilmente uma condição no loop.

        Se a condição avaliar `falso`, o loop terminará.
  - en:
      title: for
      content_markdown: |
        Rust's `for` loop is a powerful upgrade. It
        iterates over values from any expression that evaluates into an iterator. What's
        an iterator? An iterator is an object that you can ask the question "What's the
        next item you have?" until there are no more items.

        We'll explore this more in a future chapter, in the meantime just know Rust makes 
        it easy to create iterators that generate a sequence of integer numbers.

        The `..` operator creates an iterator that generates numbers from a start number up to
        but not including an end number.

        The `..=` operator creates an iterator that generates numbers from a start number up to 
        and including an end number.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: for
      content_html:
        <p><code>for</code>-Schleifen in Rust sind ein großes Upgrade.
        Wird ein Ausdruck (expression) in einen Iterator evaluiert, kann dieser in eine
        for-Schleife eingebaut werden.</p><p>Was ist ein Iterator? Ein Iterator ist ein
        Objekt, dem die Frage "Was kommt als nächstes?" gestellt werden kann. Sind keine
        Elemente mehr vorhanden, wird die Schleife abgebrochen.</p><p>In diesem Beispiel
        sehen wir, wie in Rust eine Zahlensequenz erstellt wird, über die wir iterieren
        können. Hierbei gibt es zwei unterschiedliche Notationen:</p><p><ul><li><code>x..y</code>
        erstellt einen Iterator, der bei <code>x</code> anfängt und <b>vor</b>
        <code>y</code> aufhört (exklusives <code>y</code> also)</li><li><code>x..=y</code>
        erstellt einen Iterator, der bei <code>x</code> anfängt und <b>mit</b>
        <code>y</code> aufhört (inklusives <code>y</code>)</li></ul></p>
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20print!(%220..5%20%3A%22)%3B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%20%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20print!(%22%5Cn0..5%3D%3A%22)%3B%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%20%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: for (por)
      content_html:
        '<p>Li cicle <code>for</code> de Rust es un potent amelioration.
        It itera sur valores de quelcunc expression queles evalua se ad-in un iterator.
        Quo es un iterator? Un iterator es un object a quel on posse demandar: "Quo es
        li cose sequent quel tu possede?" til quande ti coses es exhaustet.</p><p>Noi
        va explorar pri to in plu detallie in un capitul futuri, ma por li moment it mey
        suficer a saver que in Rust it es facil crear iteratores queles genera un sequentie
        de ciffres integral.</p><p>Li operator <code>..</code> crea un iterator
        quel genera ciffres ex un comensant ciffre til, ma ne includent, un final ciffre.</p><p>Con
        li operator <code>..=</code> on crea un iterator quel genera ciffres
        ex un comensant ciffre til, e includent, un final ciffre.</p>'
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: for
      content_markdown: |
        Rust(овый) цикл `for`, очень мощное средство.
        Он перебирает значения из любого выражения, которое вычисляется в итератор. А
        что такое итератор? Итератор - это обьект, которому вы можете сказать "Дай мне
        свой следующий элемент!" и так до тех пор, пока в нём не останется элементов.

        Мы посмотрим на это в следующей главе, между прочим Rust позволяет очень легко перебирать
        последовательности целых чисел.

        Оператор `..` создает структуру, которая итерируется с первого числа включительно по второе, в математике
        это называют полуинтервалом [0..5).

        Оператор `..=` делает то же самое, но итерируется по замкнутому интервалу [0..5]. Разница между
        ними в том что в первом случае не проитерируем пятёрку, а втором да.
    es:
      title: for
      content_html: >
        <p>El bucle <code>for</code> en Rust es una gran mejora, ya que
        itera sobre valores en cualquier expresión que se evalúe como un iterador. ¿Qué
        es un iterador? Un iterador es un objeto al que le puedes hacer la pregunta: "¿Cuál es el
        siguiente elemento?" hasta que ya no queden más elementos.</p><p>Nos centraremos más en esto
        en próximos capítulos, mientras tanto, sólo necesitas saber que en Rust es sencillo crear iteradores
        que generen secuencias de números enteros.</p><p>El operador <code>..</code>
        crea un iterador que genera números a partir de un número inicial
        pero sin incluir el número final.</p><p>El operador <code>..=</code> crea
        un iterador que genera números a partir de un número inicial, incluyendo el número final.</p>
    pt-br:
      title: for
      content_markdown: |
        O loop `for` do Rust é uma grande melhoria, uma vez que ele itera
        sobre valores de qualquer expressão que se avalie como um iterador.
        O que é um iterador? Um iterador é um objeto ao qual você pode perguntar
        "qual o seu próximo item?" até que não haja mais itens.

        Iremos explorar mais isso em um capítulo futuro, mas por enquanto basta
        saber que em Rust é fácil criar iteradores que geram uma seqüência de
        números inteiros.

        O operador `..` cria um iterador que gera uma seqüência a partir de um 
        número inicial até, mas não incluso, um número final.

        O operador `..=` cria um iterador que gera uma seqüência a partir de um 
        número inicial até um número final, inclusive.
  - en:
      title: match
      content_markdown: |
        Miss your switch statement? Rust has an incredibly useful keyword
        for matching all possible conditions of a value and executing a code path if the
        match is true. Let's see how this works for numbers. We will have more to say
        in future chapters on pattern matching more complex data, I promise you it will
        be worth the wait.

        `match` is exhaustive so all cases
        must be handled.

        Matching combined with destructuring is by far one of the
        most common patterns you will see in all of Rust.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20multiple%20values%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%201%20or%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20iterators%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20a%20number%203%20to%209%20inclusively%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20bind%20the%20matched%20number%20to%20a%20variable%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20%7B%7D%20number%20between%2010%20to%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20this%20is%20the%20default%20match%20that%20must%20exist%20if%20not%20all%20cases%20are%20handled%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20something%20else!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: match
      content_html:
        <p>Du vermisst dein Switch Statement? Rust lässt dich nicht im Stich!</p><p>Mittels
        <code>match</code> können Werte mit allen möglichen Konditionen und
        Werten verglichen werden. Konditionen ist hier vielleicht das interessanteste.
        Kein stupides Vergleichen, ob zwei Werte eins zu eins übereinstimmen.</p><p>Hier
        sehen wir das "matching" auf die Zahl <code>x</code> angewandt.</p><p><code>match</code>
        in Rust ist <b>exhaustive</b> (erschöpfend). Das bedeuted, dass jeder mögliche
        Wert getested werden muss, den die Variable annehmen kann. Was in manchen Programmiersprachen
        als <b>default</b> bekannt ist, ist hier durch ein einfaches Unterstrich gegeben.</p><p>Hier
        sei schon mal erwähnt, dass ein destructuring in Kombination mit match unglaublich
        viel Anwendung in der Sprache findet. Zu viel für ein Einführungskapitel leider,
        weshalb wir uns dafür etwas gedulden müssen.</p>
    ie:
      title: match
      content_html:
        "<p>Tui declaration 'switch' te manca? In Rust trova se un íncredibilmen
        util clave-parol por verificar li corespondentie de omni possibil conditiones
        de un valore e executer li code si on trova paritá. Lass nos vider qualmen it
        functiona por ciffres. In li capitules a sequer noi va parlar plu detalliatmen
        con data con plu complexitá, e yo promesse te que it va valer li pena atender
        un poc.</p><p><code>match</code> es exhaustiv, significante que omni
        possibil casus mey esser inscrit.</p><p>Serchar coresponses poy destructurar les
        es un modelle quel es de long li max comun inter tis queles on va vider in Rust.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20noi%20posse%20controlar%20li%20corespondentie%20de%20valores%20multiplic%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%201%20o%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20e%20noi%20posse%20controlar%20ti%20contra%20iteratores%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20un%20ciffre%20inter%203%20e%209%20inclusivmen%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20noi%20posse%20ligar%20li%20corespondent%20ciffre%20a%20un%20variabile%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20li%20ciffre%20%7B%7D%20inter%2010%20til%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20ti-ci%20es%20li%20coresponse%20predefenit%20quel%20deve%20exister%20si%20ne%20omni%20casus%0A%20%20%20%20%20%20%20%20%2F%2F%20es%20inscrit%3B%20pro%20que%20noi%20compara%20contra%20un%20ciffre%20quel%20posse%20esser%0A%20%20%20%20%20%20%20%20%2F%2F%20presc%20quelcunc%20valore.%20T%C3%A1men%20p.ex.%20si%20on%20vell%20comparar%20contra%20un%20bool%0A%20%20%20%20%20%20%20%20%2F%2F%20on%20vell%20besonar%20solmen%20li%20casus%20true%20e%20false%3B%20null%20_%20es%20besonat%20nam%0A%20%20%20%20%20%20%20%20%2F%2F%20li%20possibil%20coresponses%20es%20solmen%20du.%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20alquicos%20diferent!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: match
      content_markdown: |
        Хм, а где же оператор switch? Rust имеет очень полезный оператор
        `match` - он позволяет сравнивать значение с серией шаблонов
        и затем выполнять код в зависимости от того, какое значение совпало. Давайте посмотрим,
        как это работает с числами. Я расскажу больше в будущих главах, когда мы будем
        **match**(ить) более комплексные данные, и я обещаю, что вы не зря будете ждать.

        `match` требует обработки всех возможных случаев.

        Match(ить), используя деструктуризацию, один из самых распространенных паттернов в Rust.
    es:
      title: match
      content_html:
        "<p>¿Echas de menos el “switch”? Rust tiene una palabra reservada muy útil
        para hacer coincidir (matching) todas las condiciones posibles de un valor y ejecutar una ruta
        de código si la condición es verdadera. Veamos cómo funciona esto para los números. Nos centraremos en
        los patrones de coincidencia con datos más complejos en próximos capítulos, te prometo
        que valdrá la pena la espera.</p><p><code>match</code> es exhaustivo, así que todos los
        casos deben ser evaluados.</p><p>El emparejamiento (matching) combinado con la desestructuración es uno de los
        patrones más comunes que verás en Rust</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%200%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20hacer%20comparaciones%20con%20m%C3%BAltiples%20valores%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%201%20o%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20hacer%20comparaciones%20con%20iteradores%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%20un%20numero%20entre%203%20y%209%2C%20ambos%20incluidos%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20asignar%20el%20valor%20encontrado%20a%20una%20variable%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%20%7B%7D%2C%20un%20n%C3%BAmero%20entre%2010%20y%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20esta%20es%20la%20condici%C3%B3n%20por%20defecto%20que%20debe%20existir%20%0A%20%20%20%20%20%20%20%20%2F%2F%20si%20no%20se%20han%20evaluado%20todos%20los%20casos%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%20otra%20cosa!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    pt-br:
      title: match
      content_markdown: |
        Sentiu falta do operador *switch*? O Rust tem uma palavra-chave muito
        útil para comparar um valor com todas as condições possíveis e executar
        um bloco de código se a condição for verdadeira. Vejamos como isso funciona
        com números. Falaremos mais a respeito de padrões de correspondência com dados 
        mais complexos em capítulos futuros. Prometo que a espera valerá a pena.

        O `match` é exaustivo, então todos os casos devem ser avaliados.

        Correspondências (matching) combinado com desestruturação é um dos padrões mais comuns
        que você verá no Rust.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20o%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20comparar%20com%20m%C3%BAltiplos%20valores%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%201%20ou%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20comparar%20com%20iteradores%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20um%20n%C3%BAmero%20entre%203%20e%209%2C%20inclusive%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20vincular%20a%20uma%20vari%C3%A1vel%20o%20n%C3%BAmero%20a%20ser%20comparado%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20o%20n%C3%BAmero%20%7B%7D%20entre%2010%20e%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20esta%20%C3%A9%20a%20correspond%C3%AAncia%20padr%C3%A3o%20que%20deve%20existir%20se%20nenhum%20caso%20for%20correspondido%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20outra%20coisa!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Returning Values From loop
      content_markdown: |
        `loop` can break to return a value.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22found%20the%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    de:
      title: Rückgabewerte aus loop
      content_markdown: |
        `loop`	können Werte zurückgeben (return).
        Noch etwas kann mittels `break` den Wert returnen.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%2213%20gefunden!%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22aus%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    ie:
      title: Retornar valores de loop
      content_markdown: |
        `loop` posse exear (break) por retornar un valore.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22trovat%20li%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22del%20loop%20(cicle)%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    ru:
      title: Возвращение значений из loop
      content_markdown: |
        Прерывая `loop`, вы можете возвратить значение.
    es:
      title: Devolviendo valores en loop
      content_markdown: |
        Podemos devolver un valor en un `loop` cuando usamos `break`
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22encontr%C3%A9%20el%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Del%20bucle%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    pt-br:
      title: Retornando Valores de um loop
      content_markdown: |
        `loop` podem ser interrompidos para retornar um valor.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22encontrei%20o%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22do%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
  - en:
      title: Returning Values From Block Expressions
      content_markdown: |
        `if`,`match`,functions, and scope blocks all have a unique way of returning values in Rust.

        If the last statement in an `if`, `match`, function, or scope block is an expression without
        a `;`, Rust will return it as a value from the block. This
        is a great way to create concise logic that returns a value that can be put into
        a new variable.

        Notice that it also allows an `if` statement to operate like a concise ternary expression.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22from%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22is%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22is%20not%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifying%20food%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22from%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    de:
      title: Rückgabewerte aus Blockausdrücken
      content_html:
        "<p>Als <b>Block</b> wird in Rust ein Codestück zwischen zwei geschweiften
        Klammern bezeichnet (<code>{ /* code block */ }</code>).</p><p>Hier
        ist eine Besonderheit in Rust: Blockausdrücke, die in <code>if</code>,
        Funktionen etc. zu finden sind, können Werte zurückgeben (return).</p><p>Noch etwas
        idiomatisches in Rust: wenn die letzte Zeile in einem solchen Codeblock ein Ausdruck
        (expression) ohne <code>;</code> am Ende ist, interpretiert Rust dies
        als den Rückgabewert.</p><p>Für Leute, die ein Fan von ternary Operatoren sind
        und das Fragezeichensymbol in Rust vermissen, <code>if</code> Statements
        bilden dazu die Alternative.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22aus%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22nutella%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22nutella%22%20%3D%3E%20%22ist%20nutella%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22nein%2C%20das%20ist%20keine%20nutella%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Essen%20identifizieren%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22aus%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22aus%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    ie:
      title: Retornar valores de bloc-expressiones
      content_html: "<p><code>if</code>,<code>match</code>,
        functiones, e cadre-blocs omni possede un maniere unic por retornar valores in
        Rust.</p><p>Si
        li ultim declaration in un bloc <code>if</code>,
        functiones, o cadre-bloc es un expression sin un <code>;</code>, Rust
        va retornar it quam un valore ex li bloc. To-ci es un bonissim maniere de crear
        logic concis quel retorna un valore quem on posse plazzar in un nov variabile.</p><p>Ples
        notar que to possibilisa que un declaration <code>if</code> opera quam
        un expression ternari concis.</a>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20exemple()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Li%20expression%20ternari%20de%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22de%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20manjage%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20resultate%20%3D%20match%20manjage%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22es%20un%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20nota%20que%20li%20inbrassamentes%20es%20optional%20quande%20hay%20solmen%20un%0A%20%20%20%20%20%20%20%20%2F%2F%20expression%20de%20retorna%20simplic%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22ne%20es%20un%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifcante%20li%20manjage%3A%20%7B%7D%22%2C%20resultate)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Ti-ci%20cadre-bloc%20fa%20it%20possibil%20por%20nos%20a%20trovar%20un%20resultate%20sin%0A%20%20%20%20%20%20%20%20%2F%2F%20polluer%20li%20cadre%20del%20function%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22del%20bloc%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20Vi%20li%20metode%20idiomatic%20in%20Rust%20por%20retornar%20li%20valore%20de%20un%20function%0A%20%20%20%20%2F%2F%20al%20fine%20de%20it%20(quam%20monstrat%20un%20vez%20in%20Capitul%201)%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22del%20function%3A%20%7B%7D%22%2C%20exemple())%3B%0A%7D%0A
    ru:
      title: Возвращение значений из выражений-блоков
      content_markdown: |
        `if`, `match`, функции и блоки(scope blocks) - все имеют уникальный
        способ возвращать значение.

        Если последняя инструкция в `if`, `match`, функции или 
        блоке(scope block) не завершается `;`, Rust вернёт это значение 
        из данного блока. Это отличный способ создать краткую логику, которая
        возвращает какое-то значение, не создавая новую функцию, и сразу же присваивая
        это значение переменной.

        Примечание: если `if` имеет ветку `else`, его можно использовать как 
        тернарый оператор.
    es:
      title: Devolviendo valores en bloques de expresiones
      content_html:
        "<p>Las sentencias <code>if</code>,<code>match</code>, funciones
        y bloques de código presentan maneras únicas de devolver valores en Rust.</p>
        <p>Si la última sentencia de un <code>if</code>,
        <code>match</code>, función o bloque de código es una expresión sin
        <code>;</code>, Rust la devolverá como valor de retorno del bloque. Esta
        es una gran manera de crear una lógica concisa que devuelva un valor que pueda ser
        asignado a un nueva variable.</p><p>Ten en cuenta que también permite a una sentencia <code>if</code>
        operar como una expresión ternaria concisa.</a>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Expresi%C3%B3n%20ternaria%20en%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22Del%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburguesa%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22perrito%20caliente%22%20%3D%3E%20%22es%20un%20perrito%20caliente%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20los%20par%C3%A9ntesis%20son%20opcionales%20cuando%20hay%20una%20sola%20expresi%C3%B3n%20de%20retorno%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22no%20es%20un%20perrito%20caliente%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Identificando%20comida%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Este%20bloque%20de%20c%C3%B3digo%20nos%20permite%20obtener%20un%20resultado%0A%20%20%20%20%20%20%20%20%2F%2F%20sin%20tener%20que%20definir%20una%20funci%C3%B3n%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Del%20bloque%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20Esta%20es%20la%20forma%20de%20devolver%20un%20valor%20en%20Rust%20al%20final%20de%20una%20funci%C3%B3n%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22De%20la%20funci%C3%B3n%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    pt-br:
      title: Retornando Valores de um Bloco de Códígo
      content_markdown: |
        `if`, `match`, funções e blocos de código têm maneiras únicas de retornar
        valores em Rust.


        Se a última instrução de um `if`, `match`, função ou bloco de código 
        for uma expressão sem `;`, o Rust vai retorná-la como um valor do bloco.

        Esta é uma ótima maneira de criar uma lógica concisa que retorna um valor que
        pode ser atribuída a uma nova variável.

        Note isso também permite que o operador `if` funcione como uma expressão ternária concisa.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20express%C3%A3o%20tern%C3%A1ria%20em%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22do%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamb%C3%BArger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22cachorro-quente%22%20%3D%3E%20%22%C3%A9%20cachorro-quente%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20repare%20que%20as%20chaves%20s%C3%A3o%20opcionais%20quando%20o%20retorno%20%C3%A9%20s%C3%B3%20uma%20express%C3%A3o%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22n%C3%A3o%20%C3%A9%20cachorro-quente%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identificando%20o%20lanche%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Este%20bloco%20de%20c%C3%B3digo%20nos%20permite%20obter%20um%20resultado%20sem%20poluir%20o%20escopo%20da%20fun%C3%A7%C3%A3o%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22do%20bloco%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20Assim%20retornamos%20um%20valor%20en%20Rust%20no%20final%20de%20uma%20fun%C3%A7%C3%A3o%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22da%20fun%C3%A7%C3%A3o%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
  - en:
      title: Chapter 2 Conclusion
      content_markdown: |
        Hopefully I've shown a glimpse of Rust's power even in the most
        basic language features. We'll be talking about `for` and
        `match` even more in depth as we gain more knowledge that
        can utilize their capabilities. Next time we'll get into Rust's foundational data
        structures.
    de:
      title: Kapitel 2 Fazit
      content_html:
        "<p>Was? Das war's schon?</p><p>Keine Bange, es gibt noch viel zu erforschen!
        Insbesondere <code>match</code> wurde hier außer Acht gelassen, das
        viele mächtige Features beinhaltet, dementsprechend aber auch etwas mehr Hintergrundwissen
        erfordert.</p><p>Im nächsten Kapitel werden wir uns dafür ein bisschen in die
        Datenstrukturen (data structures) von Rust einarbeiten. Worauf warten wir noch?</p>"
    ie:
      title: Conclusion de Capitul 2
      content_html:
        "<p>Vi li tot contenete til nu in li capitul! Yo espera har monstrat
        te un poc pri li potentie de Rust quel trova se mem in li declarationes max basic.
        Noi va parlar mem plu detalliatmen pri <code>for</code> e <code>match</code>
        durant que nor conossentie augmenta se pri qualmen utilisar lor capabilitás. Por
        li proxim vez, noi va conossentar nos pri li fundamental data-structuras de Rust.</p>"
    ru:
      title: Глава 2. Заключение
      content_markdown: |
        Надеюсь, я продемонстрировал силу Rust даже в самых основных возможностях
        языка. Мы будем говорить про `for` и `match` еще глубже, когда обретём больше
        знаний, которые позволят применить больше возможностей языка. В следующий раз
        мы перейдем к основополагающим структурам данных Rust.
    es:
      title: Capítulo 2 - Conclusión
      content_html:
        "<p>Con esto ya hemos echado un vistazo a las características más
        básicas del lenguaje Rust. Hablaremos de <code>for</code> y
        <code>match</code> en más profundidad a medida que aumentemos
        nuestro conocimiento sobre cómo aplicar sus capacidades.
        Lo siguiente será adentrarnos en las estructuras de datos fundamentales de Rust.</p>"
    pt-br:
      title: Capítulo 2 - Conclusão
      content_markdown: |
        Espero ter mostrado um vislumbre do poder de Rust, mesmo nos recursos
        mais básicos de linguagem. Nós iremos falar do `for` e
        `match` com mais profundidade à medida que formos adquirindo mais 
        conhecimento para aproveitar os seus recursos. A seguir entraremos nos 
        fundamentos das estruturas de dados do Rust.
  - chapter: 3
    en:
      title: Chapter 3 - Basic Data Structure Types
      content_markdown: |
        It's time we explore beyond basic types! In this chapter we will look the most primitive 
        data structures in Rust, paying close attention to their representations in memory. I think 
        you will enjoy how little Rust hides from you how things work.
    de:
      title: Kapitel 3 - Datenstrukturen
      content_markdown: |
        Zeit die Basisdatentypen zu erweitern! Hier werden wir leicht komplexere Datenstrukturen
        in Rust betrachten, speziell wie die Daten im Speicher verteilt werden. Alle low-level-Enthusiasten
        (mitunter dir) werden sicherlich Gefallen daran haben, wie wenig Rust vor einem versteckt.
    ie:
      title: Capitul 3 - Basic Tipes de Data-Structura
      content_markdown: |
        Li témpor ha venit por explorar ultra li tipes basic! In ti-ci capitul noi va vider li max primitiv 
        data-structuras in Rust, atentente pri qualmen ili representa se in li memorie. Yo crede que tu va 
        juir vider quant litt Rust oculta de te pri qualmen functiona li coses.
    ru:
      title: Глава 3 - Структуры данных
      content_markdown: |
        Время посмотреть на что-то помимо базовых типов! В этой главе мы посмотрим на самые примитивные структуры данных в Rust, уделив особое внимание их представлению в памяти. 
        Я думаю, вам понравится, что Rust так мало скрывает от вас то, как всё работает.
    es:
      title: Capítulo 3 - Tipos Básicos de Estructuras de Datos
      content_markdown: |
        ¡Ha llegado la hora de explorar más allá de los tipos básicos! En este capítulo veremos
        las estructuras de datos más primitivas de Rust, prestando mucha atención a sus representaciones en
        memoria. También te darás cuenta de lo poco que oculta Rust sobre cómo funcionan las cosas.
    pt-br:
      title: Capítulo 3 - Tipos Básicos de Estrutura de Dados
      content_markdown: |
        Chegou a hora de explorar além dos tipos básicos! Neste capítulo veremos as estruturas
        de dados mais primitivas do Rust, prestando muita atenção nas suas representações em
        memória. Acredito que você gostará do quão pouco o Rust esconde de você como as coisas 
        funcionam.
  - en:
      title: Structures
      content_markdown: |
        A `struct` a collection of fields.

        A *field* is simply a data value associated with a data structure. Its value can be of a primitive type or a data structure.

        Its definition is like a blueprint for a compiler on how to layout the fields in memory nearby each other.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20String%20is%20a%20struct%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D
    de:
      title: Strukturen
      content_markdown: |
        Ein `struct` (dt. "Struktur") ist eine Ansammlung von fields (dt. Feldern).

        Ein *field* ist ein Wert, der mit einer Datenstruktur assoziiert wird. Dies kann ein primitiver Datentyp oder ein weiteres `struct` sein.

        Die Definition eines structs ist wie ein Entwurf für den Compiler, der ihm besagt, welche Felder im Speicher zueinander gehören.
    ie:
      title: Structuras
      content_markdown: |
        Un `struct` es un colection de fields (campes).

        Un *field* es simplicmen un valore de data asociat a un data-structura. Su valore posse esser un tip primitiv o un data-structura.

        Su definition es simil a un plan por li compilator pri qualmen plazzar li campes in memorie proxim unaltru.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20CreaturaMarin%20%7B%0A%20%20%20%20%2F%2F%20String%20es%20un%20struct%0A%20%20%20%20tip_de_animale%3A%20String%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20String%2C%0A%7D
    ru:
      title: Структуры
      content_markdown: |
        `struct` - это колекция полей.

        *field* (поле) - это просто какое-то значение, которое содержится в структуре. Значение поля может быть примитивным типом или другим типом, например структурой.

        Определение структуры - это как чертеж для компилятора, который указывает на то, как поля должны быть расположены в памяти.

        Поля в структуре расположены в памяти один за другим (компилятор может менять их местами для оптимизаций).
    es:
      title: Estructuras
      content_markdown: |
        Una estructura `struct` es una colección de campos.

        Un *campo* es simplemente un valor de datos asociado a una estructura de datos. Su valor puede ser de tipo primitivo o una estructura de datos.

        Su definición es como una plantilla para el compilador sobre cómo disponer los campos en memoria cerca unos de otros.
    pt-br:
      title: Estruturas
      content_markdown: |
        Uma estrutura `struct` é uma coleção de campos.

        Um *campo* é simplesmente um valor de dado associado a uma estrutura de dados. Seu valor pode
        ser um tipo primitivo ou uma estrutura de dados.

        Sua definição é como um modelo para o compilador sobre como organizar os campos na memória 
        próximos uns dos outros.
  - en:
      title: Calling Methods
      content_markdown: |
        Unlike functions, methods are a function associated with a specific data type.

        **static methods** — methods that belong to a type itself are called using the `::` operator.

        **instance methods** — methods that belong to an instance of a type are called using the `.` operator.

        We will talk more on making your own methods in future chapters.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Using%20a%20static%20method%20to%20create%20an%20instance%20of%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20Using%20a%20method%20on%20the%20instance%0A%20%20%20%20println!(%22%7B%7D%20is%20%7B%7D%20characters%20long.%22%2C%20s%2C%20s.length())%3B%0A%7D%0A
    de:
      title: Methoden aufrufen
      content_markdown: |
        Einen feinen Unterschied zu Funktionen bilden Methoden. Methoden sind Erweiterungen zu Datentypen,
        bzw. Funktionen die auf Datentypen anzuwenden sind.

        **statische Methoden** - Methoden, die zum Datentyp selber assoziiert sind. Werden mit dem `::` Operator aufgerufen.

        **instanz Methoden** (instance methods) - Methoden, die bei einer Instanz (oder Objekt) mit dem `.` Operator aufgerufen werden können.

        Wir werden im späteren Verlauf sehen, wie wir selber Methoden erstellen können.
    ie:
      title: Calling Methods
      content_markdown: |
        Need translation.
    ru:
      title: Вызов метода
      content_markdown: |
        Методы - это функции, ассоциированные с определенным типом данных.

        **статические методы** - принадлежат к типу и вызываются с помощью оператора `::`.

        **методы объектов** — это методы, что можно применить только на уже созданном объекте через оператор `.`.

        Мы поговорим о том, как создавать свои методы в следующих главах.
    es:
      title: Llamadas a Métodos
      content_markdown: |
        A diferencia de las funciones, los métodos son funciones asociadas con un tipo de datos específico.

        **Métodos estáticos** — los métodos que pertenecen a un tipo determinado se llaman usando el operador `::`.

        **Métodos de instancia** — los métodos que pertenecen a una instancia de un tipo se llaman usando el operador `.`.

        Hablaremos de cómo hacer tus propios métodos en próximos capítulos.
    pt-br:
      title: Chamando Métodos
      content_markdown: |
        Diferentemente das funções, os métodos são uma função associada a um tipo de dados específico.

        **Métodos estáticos** — os métodos que pertencem a um tipo determinado são chamados usando o operador `::`.

        **Métodos de instância** — os métodos que pertencem a uma instância de um tipo são chamados usando o operador `.`.

        Falaremos mais sobre como criar seus próprios métodos nos próximos capítulos.
  - en:
      title: Memory
      content_markdown: |
        Rust programs have 3 memory regions where data is placed:
        * **data memory** - For data that fixed size and **static** (i.e always available through life of program ). 
          consider the text in your program (e.g. "Hello World!"), this text's bytes are only ever read from 
          therefore they are placed in this region. Compilers make lots of optimizations 
          with this kind of data, they are generally considered very fast to use since
          locations are known and fixed.
        * **stack memory** - For data that is declared as variables within a function. 
          The location of this memory never changes for the duration of a function call, because of this compilers 
          can optimize code so stack data is very fast to use. 
        * **heap memory** - For data that is created while the application is running. 
          Data in this region may be added, moved, removed, resized, etc. Because of 
          it's dynamic nature it's generally considered slower to use, but it allows 
          for much more creative usages of memory.  When data is added to this region we 
          call it an **allocation**. When data is removed from this section we call it a 
          **deallocation**.
    de:
      title: Speicher
      content_markdown: |
        In Rust gibt es 3 unterschiedliche Speicher-Regionen:
        * **data memory** (Datenspeicher) - Für Daten mit fester Größe und die **statisch** sind (zur Gesamtlebenszeit
          eines Programms verfügbar). Nehmen wir beispielsweise festen Text her (z.B. `"Hallo Welt"`). Die Bytes in
          diesem Schnipsel werden nur gelesen und sind bereits zur Kompilierzeit bekannt, daher kommen sie in den
          Datenspeicher. Compiler können dementsprechend den Code optimieren und sind in der Laufzeit am schnellsten
          "auszuwerten."
        * **stack memory** (Stackspeicher) - Variablen, die innerhalb einer Funktion deklariert werden. Während eines
          Funktionsaufrufs ändert sich der Standort nicht. Wird eine weitere Funktion aufgerufen, werden die von der
          Unterfunktion benötigen Variablen weiter auf den Stack gelegt. Erreicht man das Ende der Funktion, werden die
          entsprechenden Variablen wieder vom Stack runtergenommen.
        * **heap memory** (Heapspeicher) - Speicher, der zur Laufzeit für Daten reserviert wird. In dieser Region kann
          Speicher reserviert, bewegt, vergrößert, verkleinert und freigegeben werden. Dieses dynamische
          Speichermanagement kann etwas mehr Zeit in Anspruch nehmen. Beim Reservieren spricht man von **memory allocationt**
          (allozieren), beim Freigeben von **memory deallocation**.
    ie:
      title: Memorie
      content_markdown: |
        Programmas in Rust have 3 regiones de memorie ú es plazzat li data:
        * **data-memorie** - Por data con un grandore fix e **static** (a saver, sempre disponibil durant li vive del programma). 
        Ples considerar li textu in tui programma (p.ex. "Salute Munde!"); li bytes de ti-ci textu es solmen leet e pro to 
        on plazza les in ti-ci loc. Li compilatores sovente optimisa ti tip data, on considera les rapidissim a usar pro que 
        lor locs es conosset e fix.
        * **stack memory** (cumul-memorie) - Por data declarat quam variabiles intra un function. Li loc de ti-ci memorie 
        ne changea se durant li duration del vocation de un function, e pro to li compilatores posse optimisar li code 
        por far data in li cumul rapid a utilisar.
        * **heap memory** (amasse-memorie) - Por data creat durant que li aplication execute se. Li data in ti-ci loc posse esser 
        adjuntet, movet, removet, mesurat, etc. Pro su natura dinamic on considera it plu lent a utilisar, ma it possibilisa 
        plu creativ usationes de memorie. Quande on adjunte data a ti-ci region on nomina it un **alocation**. Quande on remove data 
        de it on nomina it un **dealocation**.
    ru:
      title: Память
      content_markdown: |
        Программы на Rust имеют 3 региона, в которых хранятся данные:

        * **data memory** (память данных) - для данных фиксированного размера и **статические** (доступны в любой момент
          времени выполнения программы). Рассмотрим текст в вашей программе (пример строка "Hello World!"). Эта строка - 
          это набор байт, которые нельзя изменить и можно только считать, поэтому они размещены в этом регионе. Компиляторы
          делают очень много оптимизаций с таким типом данных. Этот регион памяти считается очень быстрым, так как 
          местоположение данные известно и фиксировано заранее.
        * **stack memory** (стек) - для данных, что объявляются как переменные внутри блока видимости (например функция).
          Местоположение этого типа памяти никогда не меняется на протяжении вызова функции, из-за этого компиляторы
          могут оптимизировать код, поэтому стек очень быстро работает.
        * **heap memory** (куча) - для данных, которые создаются, пока приложение работает.
          Данные в этом регионе могут быть добавлены, перемещены, удалены, изменены в размере, и т.д. Из-за своей 
          динамической природы, считается что этот регион медленней остальных, но он позволяет более креативное использование
          памяти. Когда данные добавляются в этот регион, это называется **allocation** (выделение памяти). Когда данные 
          удаляются - deallocation (освобождение памяти).
    es:
      title: Memoria
      content_markdown: |
        Los programas Rust tienen 3 regiones de memoria donde almacenar los datos:
        * **Data memory (o memoria de datos)** - Para datos de tamaño fijo y **estáticos** (es decir, siempre disponibles a lo largo
          de la vida del programa). Considera el texto del programa (por ejemplo, "¡Hola, Mundo!"), los bytes de este texto son de sólo
          lectura, por lo tanto se almacenan en esta región. Los compiladores hacen muchas optimizaciones
          con este tipo de datos, generalmente se consideran muy rápidos de usar ya que
          las ubicaciones son conocidas y fijas.
        * **stack memory (o memoria de pila)** - Para los datos que se declaran como variables dentro de
          una función. La ubicación de esta memoria nunca cambia durante la duración de la llamada a la función, debido a esto los
          compiladores pueden optimizar el código para que los datos de la pila sean rápidos de usar.
        * **heap memory (memoria de montículo o dinámica)** - Para los datos que se crean mientras la aplicación se está ejecutando.
          Los datos de esta región pueden ser añadidos, movidos, eliminados, redimensionados, etc.
          Debido a su naturaleza dinámica, se considera generalmente más lento de usar, pero permite
          usos mucho más creativos de la memoria. Cuando se añaden datos a esta región, lo llamamos
          **asignación**. Cuando los datos se eliminan de esta sección lo llamamos **desasignación**.
    pt-br:
      title: Memória
      content_markdown: |
        Os programas em Rust têm 3 regiões de memória onde os dados são armazenados:
        * **data memory (memória de dados)** - Para dados com tamanho fixo e **estático** (ou seja, 
          sempre disponíveis durante a vida útil do programa). Considere um texto em seu programa 
          (por exemplo, "Olá, mundo!"), os bytes desse texto são somente lidos, então eles são 
          colocados nesta região. Compiladores fazem muitas otimizações esse tipo de dados, eles 
          geralmente são considerados muito rápidos de usar pois onde estão armazenados são 
          conhecidos e fixos.
        * **stack memory (memória de pilha)** - Para dados declarados como variáveis dentro de uma
          função. O local dessa memória nunca muda durante a duração de uma chamada de função, assim
          os compiladores podem otimizar o código e por isso a pilha de dados é muito rápida de 
          usar.
        * **heap memory** - Para dados criados enquanto o aplicativo está em execução. Os dados 
          nessa região podem ser adicionados, movidos, removidos, redimensionados etc. Por causa da 
          sua natureza dinâmica geralmente é considerado mais lenta, mas permite usos de memória muito 
          mais criativas. Quando dados são adicionados a essa região, chamamos de **alocação**. Quando 
          os dados são removidos desta seção, chamamos de **desalocação**.
  - en:
      title: Creating Data In Memory
      content_markdown: |
        When we **instantiate** a **struct** in our code our program creates the associated field data side by side in memory.

        We instantiate by specifying all field values within 

        `StructName { ... }`.

        struct fields are accessed using a dot operator `.`.

        Memory details of our example:
        * The text inside the quotes is read only data (e.g. "ferris"), therefore it is 
          placed in *data memory region*
        * The function call `String::from` creates a struct `String` that is placed side 
          by side with the fields of SeaCreature in the *stack*. A String represents text that can be changed 
          and does this by:
          1. Creating memory on the *heap* for the text where it can be modified
          2. Storing a reference to that memory location on the *heap* and storing it in `String` 
          struct (More on this in future lessons) 
        * Finally our two friends *ferris* and *sara* have data structures that will always have 
          fixed locations in our program, so they are placed on the *stack*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crab%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sara%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22none%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20%7B%7D%20legs%2C%20and%20a%20%7B%7D%20weapon%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20and%20%7B%7D%20legs.%20They%20have%20no%20weapon..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
    de:
      title: Structs initialisieren
      content_markdown: |
        Wenn ein struct **instanziiert** wird, legt das Programm die Felder des structs Seite an Seite im Speicher an.

        Die Initialisierung erfolgt mit folgendem Syntax:

        `StructName { feld1, feld2, ... }`.

        Auf die Felder des structs werden mit einem `.` zugegriffen.

        In unserem Beispiel bedeutet das:
        * Text innerhalb der Anführungszeichen sind read-only Daten (z.B. "ferris"), daher sind sie
          in **data memory**
        * Der Funktionsaufruf `String::from` erstellt ein struct `String` das Seite an Seite der anderen
          Felder in `SeaCreature` auf den **stack** gelegt wird. Ein String repräsentiert (veränderbaren) Text,
          der...
          1. ... im **heap** angelegt wird und daher dort verändert werden kann,
          2. ... die Adresse (Referenz) zum Speicherstück im heap im `String` struct speichert
        * Nachdem unsere Freunde *ferris* und *sara* Datenstrukturen sind, die in der main-Funktion
          erstellt wurden, werden diese auf den **stack** platziert.
    ie:
      title: Creation de Data in Memorie
      content_markdown: |
        Quande on **instantia** un **struct** in nor code, li programma crea li data por li camp relatet con it ye láteres in li memorie.

        Noi instantia per specificar omni camp-valores intra

        `StructNómine { ... }` .

        Accesse es dat al campes de un struct con li punctu-operator `.`.

        Detallies pri memorie in nor exemple:

        * Li textu intra li signes de citation es data quel es solmen leet (p.ex. "ferris"), e pro to es plazzat in li
        *region por data-memorie*
        * Li function-vocation `String::from` crea li struct `String` quel es plazzat lateralmen con li campes de CreaturaMarit 
        sur li *stack*. Un String representa textu changeabil, fante it possibil quam seque:
        1. Per crear memorie sur li *heap* por li textu ú it posse esser modificat
        2. Per aprovisionar un referentie a ti loc de memorie sur li *heap* e aprovisionar it in li struct `String` 
        (plu detallies pri to in lectiones a sequer)
        * In fine, nor amics *ferris* e *sara* possede data-structuras queles sempre va haver locs fix in nor programma, 
        e pro to es plazzat sur li *stack*.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20CreaturaMarin%20%7B%0A%20%20%20%20tip_de_animale%3A%20String%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Li%20data%20de%20CreaturaMarin%20es%20sur%20li%20stack%0A%20%20%20%20let%20ferris%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Anc%20li%20struct%20String%20es%20sur%20li%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20ma%20possede%20un%20referentie%20al%20data%20sur%20li%20heap%0A%20%20%20%20%20%20%20%20tip_de_animale%3A%20String%3A%3Afrom(%22crabe%22)%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%202%2C%0A%20%20%20%20%20%20%20%20jambes%3A%204%2C%0A%20%20%20%20%20%20%20%20arme%3A%20String%3A%3Afrom(%22griffe%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20tip_de_animale%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Sara%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%208%2C%0A%20%20%20%20%20%20%20%20jambes%3A%200%2C%0A%20%20%20%20%20%20%20%20arme%3A%20String%3A%3Afrom(%22nullcos%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20es%20un%20%7B%7D.%20Ili%20have%20%7B%7D%20brasses%2C%20%7B%7D%20jambes%2C%20e%20es%20armat%20con%20un%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20ferris.nomine%2C%20ferris.tip_de_animale%2C%20ferris.brasses%2C%20ferris.jambes%2C%20ferris.arme%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20es%20un%20%7B%7D.%20Ili%20have%20%7B%7D%20brasses%2C%20e%20%7B%7D%20jambes.%20Ili%20have%20null%20armes..%22%2C%0A%20%20%20%20%20%20%20%20sarah.nomine%2C%20sarah.tip_de_animale%2C%20sarah.brasses%2C%20sarah.jambes%0A%20%20%20%20)%3B%0A%7D%0A
    ru:
      title: Создание структур
      content_markdown: |
        Когда мы **создаём экземпляр** структуры в коде, в памяти выделяется память для всех полей структуры.

        Создание екземпляра структуры выглядит так:

        `StructName { ... }`

        Мы указываем значения полей в фигурных скобках. Доступ к полям структуры происходит через оператор точку `.`.

        Подробности по примеру:
        * Текст внутри двойных скобок - это данные только для чтения (пример "ferris"), следовательно 
          он размещается в *data memory* регионе
        * Вызов функции `String::from` создает структуру `String`, которая размещается рядом с другими полями 
          структуры SeaCreature в *стеке*. `String` (строка) представляет текст, который может быть
          изменен и делает это так:
          1. Выделяет память в *куче* (heap) для текста (размер выделенной памяти в куче может увеличиваться и уменьшаться)
          2. Берет ссылку на выделенную память с *кучи* и сохраняет ее в `String` (больше в следующих занятиях)
        * Наши два друга *ferris* и *sara* имеют структуры данных, которые всегда будут иметь фиксированные
          местоположения в нашей программе, так как они расположены на *стеке*.
    es:
      title: Creación de Datos en Memoria
      content_markdown: |
        Cuando **instanciamos** una estructura **struct** en nuestro código, nuestro programa crea los datos asociados a cada campo uno al lado del otro en memoria.

        Para instanciar una estructura, especificaremos todos los valores de los campos dentro de 

        `StructName { ... }`.

        Los campos de una estructura se acceden mediante el operador de punto `.`.

        Detalles de memoria de nuestro ejemplo:
        * El texto dentro de las comillas es de sólo lectura de datos (por ejemplo, "ferris"), por lo tanto se
          coloca en la *región de memoria de datos*.
        * La llamada a la función `String::from` crea una estructura `String` que se coloca al lado de los campos
          de SeaCreature en la *pila*. Un string representa un texto que se puede modificar y lo hace de la siguiente manera: 
          1. Crea memoria en el montículo para el texto, donde se puede modificar.
          2. Guarda una referencia a esa ubicación de memoria en el montículo y lo almacena en la estructura `String` 
          (Nos centraremos en esto en futuras lecciones).
        * Finalmente nuestros amigos *Ferris* y *Sara* tienen estructuras de datos que siempre tendrán
          ubicaciones fijas en nuestro programa, así que se colocan en la *pila*.
    pt-br:
      title: Criando Dados na Memória
      content_markdown: |
        Quando nós **instanciamos** uma **struct** no nosso código o programa cria os campos
        associados lado-a-lado na memória.

        Nós instanciamos uma estrutura especificando todos os valores dos campos dentro de

        `StructName { ... }`.

        Os campos são acessados usando o operador de ponto `.`.

        Detalhes da memória do nosso exemplo:
        * O texto dentro das aspas é somente leitura (por exemplo, "Ferris"), portanto é colocado
          na *região da memória de dados*
        * A chamada da função `String::from` cria uma struct `String` que é colocada lado-a-lado 
          com os campos de SeaCreature na *pilha*. Uma String representa um texto que pode ser 
          alterado e faz assim:
          1. Criando memória no *heap* para o texto onde ele pode ser modificado.
          2. Armazenando uma referência a esse local de memória no *heap* e armazenando-o no struct 
          `String` (mais a respeito em lições futuras)
        * Finalmente, nossos dois amigos *Ferris* e *Sara* têm estruturas de dados que sempre terão
          locais fixos em nosso programa, portanto, eles são colocados na *pilha*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Os%20dados%20de%20SeaCreature%20est%C3%A3o%20na%20pilha%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20A%20struct%20da%20String%20tamb%C3%A9m%20est%C3%A1%20na%20pilha%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20mas%20mant%C3%A9m%20uma%20refer%C3%AAncia%20dos%20dados%20na%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22caranguejo%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22garra%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22polvo%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sara%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22nenhum%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%C3%A9%20um%20%7B%7D.%20Eles%20t%C3%AAm%20%7B%7D%20bra%C3%A7os%2C%20%7B%7D%20patas%2C%20e%20uma%20arma%20de%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%C3%A9%20um%20%7B%7D.%20Eles%20t%C3%AAm%20%7B%7D%20bra%C3%A7os%20e%20%7B%7D%20patas.%20Eles%20n%C3%A3o%20t%C3%AAm%20armas..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
  - en:
      title: Tuple-like Structs
      content_markdown: |
        For conciseness, you can create structs that are used like a tuple.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20This%20is%20still%20a%20struct%20on%20a%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
    de:
      title: Tuple-Structs
      content_markdown: |
        Eine verkürzte Schreibweiße bietet das Instanziieren von structs mittels von **Tupeln**.
    ie:
      title: Tuplic Structs
      content_markdown: |
        Por esser concis, on posse crear structs queles on usa quam un tuple.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Ti%20es%20ancor%20un%20struct%20sur%20un%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
    ru:
      title: Кортежи-структуры
      content_markdown: |
        Для краткости, вы можете создавать структуры, которые используются точно так же как кортежи (tuple).
    es:
      title: Estructuras en Forma de Tupla
      content_markdown: |
        Para ser concisos, puedes crear estructuras que se usan como una tupla
    pt-br:
      title: Estruturas em Tuplas
      content_markdown: |
        Para sermos concisos, você pode criar estruturas que são usadas em tupla.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Isto%20ainda%20%C3%A9%20uma%20estrutura%20em%20uma%20pilha%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
  - en:
      title: Unit-like Structs
      content_markdown: |
        Structs do not have to have any fields at all.

        As mentioned in Chapter 1 a *unit* is another word for an empty tuple `()`. This is why this kind of struct is called *Unit-like*.

        This type of struct is rarely used.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A
    de:
      title: Unit-Structs
      content_markdown: |
        Structs müssen keine Felder enthalten.

        Wie in Kapitel 1 ist ein *unit* ein anderes Wort für ein leeres Tupel `()`. Daher werden diese structs auch *unit-like* (unit-ähnlich) genannt.

        Sowas wird allerdings nur selten verwendet.
    ie:
      title: Unitic Structs
      content_markdown: Structs in fact ne besona quelcunc campes in ili.

        Quam mentionat in Capitul 1 un *unit* es un altri metode por dir vacui tuple `()`. Pro to on nomina un tal struct
        *Unit-like* (unitic, unitesc).

        Tal structs es rarmen usat.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Ti%20es%20ancor%20un%20struct%20sur%20un%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0Av
    ru:
      title: Юнит-структуры
      content_markdown: |
        Структуры могут вовсе не иметь ни одного поля.

        Как было упомянуто в Главе 1, *юнит* - это то же самое, что и пустой кортеж `()`. Вот почему этот вид структур называют *юнит-структуры*.

        Этот тип не так распространен как остальные.
    es:
      title: Estructuras Tipo-Unitario
      content_markdown: |
        No es necesario que las estructuras tengan campos.

        Como ya se mencionó en el capítulo 1, una *unidad (unit)* es otra palabra para una tupla vacía `()`. Es por eso que este tipo de estructura se llama *de Tipo-Unitario*.

        Este tipo de estructura no es muy común.
    pt-br:
      title: Estruturas Tipo Unit
      content_markdown: |
        As estruturas não precisam ter nenhum campo.

        Como mencionado no capítulo 1, a *unit* é outra palavra para uma tupla vazia `()`. 
        É por isso que esse tipo de estrutura é chamado de *Unit-like*.

        Este tipo de estrutura raramente é usado.
  - en:
      title: Enumerations
      content_markdown: |
        Enumerations allow you allow you to create a new type that can have a value of several tagged elements using the `enum` keyword.

        `match` helps ensure exhaustive handling of all possible enum values making it a powerful tool in ensuring quality code.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20is%20a%20crab%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20is%20a%20octopus%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20is%20a%20fish%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20is%20a%20clam%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: Enumerations
      content_markdown: |
        Aufzählungen (enumerations) erlauben das Erzeugen eines neuen Typs, die nur eine fixe Liste an Werten zulassen.
        Die gültigen Werte werden mit dem `enum` Schlüsselwort eingeleitet.

        `enum` ist besonders im Zusammenhang mit `match` nützlich: da `match` exhaustive ist, versucht es den Programmierer darüber zu
        informieren, falls nicht alle möglichen Testfälle durchgegangen wurden.

        Versuche unser Beispielcode zum Laufen zu bringen. Welcher Fall wurde in `match` nicht berücksichtigt? Kannst du diesen noch einfügen?
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%2C%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22ferris%20is%20a%20crab%22)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22ferris%20is%20a%20octopus%22)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22ferris%20is%20a%20fish%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Enumerationes
      content_markdown: |

        Enumerationes possibilisa li creation de un nov tip quel usa li clave-parol `enum` e quel posse posseder li valore 
        de pluri marcat elementes.

        Con `match` on es assecurat tractar se con omni possibil valores del enum, fante it un potent utensile in li creation 
        de code de alt qualitá.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Specie%20%7B%0A%20%20%20%20Crabe%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Pisc%2C%0A%20%20%20%20Mollusco%2C%0A%7D%0A%0Astruct%20CreaturaMarin%20%7B%0A%20%20%20%20specie%3A%20Specie%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Li%20data%20de%20CreaturaMarin%20es%20sur%20li%20stack%0A%20%20%20%20let%20ferris%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Li%20struct%20String%20es%20anc%20sur%20li%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20ma%20possede%20un%20referentie%20de%20data%20sur%20li%20heap%0A%20%20%20%20%20%20%20%20specie%3A%20Specie%3A%3ACrabe%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%202%2C%0A%20%20%20%20%20%20%20%20jambes%3A%204%2C%0A%20%20%20%20%20%20%20%20arme%3A%20String%3A%3Afrom(%22griffe%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20%2F%2F%20Ci%20on%20usa%20match%20por%20comparar%20contra%20omni%20possibil%20%27brasse%27%20(arm)%20del%0A%20%20%20%20%2F%2F%20enum.%20Li%20compilator%20va%20incolerar%20se%20si%20on%20ne%20include%20omni%20possibil%0A%20%20%20%20%2F%2F%20brasses%20in%20li%20comparation.%0A%20%20%20%20match%20ferris.specie%20%7B%0A%20%20%20%20%20%20%20%20Specie%3A%3ACrabe%20%3D%3E%20println!(%22ferris%20es%20un%20crabe%22)%2C%0A%20%20%20%20%20%20%20%20Specie%3A%3AOctopus%20%3D%3E%20println!(%22ferris%20es%20un%20octopus%22)%2C%0A%20%20%20%20%20%20%20%20Specie%3A%3APisc%20%3D%3E%20println!(%22ferris%20es%20un%20pisc%22)%2C%0A%20%20%20%20%20%20%20%20Specie%3A%3AMollusco%20%3D%3E%20println!(%22ferris%20es%20un%20mollusco%22)%2C%0A%20%20%20%20%7D%0A%7D%0A

    ru:
      title: Перечисления
      content_markdown: |
        Перечисления `enum` позволяют вам создавать новый тип, который имеет одно определенное значение из 
        списка перечисленных вами возможных значений.
    es:
      title: Enumeraciones
      content_markdown: |
        Las enumeraciones permiten crear un nuevo tipo que puede tener un valor entre varios elementos etiquetados utilizando
        la palabra reservada `enum`.

        `match` ayuda a asegurar un manejo exhaustivo de todos los posibles valores del enumerado, convirtiéndolo en una
        herramienta muy útil para asegurar un código de calidad.
    pt-br:
      title: Enumerações
      content_markdown: |
        As enumerações permitem criar um novo tipo que pode conter o valor de vários elementos etiquetados
        usando a palavra-chave `enum`.

        O `match` ajuda a garantir o tratamento exaustivo de todos os valores possíveis de *enum*, tornando-o uma ferramenta poderosa para garantir um código de qualidade.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20esta%20linha%20evita%20avisos%20do%20compilador%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20caranguejo%22%2C%20ferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20polvo%22%2C%20ferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20peixe%22%2C%20ferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20molusco%22%2C%20ferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Enumerations With Data
      content_markdown: |
        `enum` elements can also have have one or more data types allowing them to behave like *union* from C.

        When an `enum` is pattern matched using `match`, you can bind a variable name to each data value.

        Memory details of `enum`:
        * An enum data value will have a memory size equal to its largest element. This allows for all potential values to fit in the same space of memory.
        * In addition to element data types (if any), each element also has a numeric value that represents which tag it is.

        Other details:
        * Rust's `enum` is something also known as a *tagged-union*
        * The combining of types to make a new type is what people mean when they say Rust has *algebraic types*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20some%20other%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D
    de:
      title: Enumerations mit Daten
      content_markdown: |
        `enum` Elemente können auch Daten (oder Felder) beinhalten, vergleichbar mit *unions* aus C (nicht der Arbeitergewerkschaft haha).

        Wenn ein `enum` in einem Fall im `match` übereinstimmt, können die Werte aus dem struct direkt an Variablen gebunden werden
        (im Beispiel in Zeile 32 zu sehen).

        Weitere Details zu `enum`:
        * Der Speicherbedarf eines enums entspricht dem des größten Elements (hier wäre `Claw` das größte Element).
        * Neben den Datentypen (sollte es welche geben) kann jedes Element mittels einer Zahl erreicht werden.

        Mehr Details!
        * `enum` ist in Rust auch bekannt als *tagged-union*.
        * Das Kombinieren von verschiedenen Typen wird in Rust auch als *algebraischer Typ* bezeichnet (eng. algebraic type).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0A%0A%2F%2F%20Claw%20has%20additional%20information%20about%20number%20of%20claws%20and%20size%0A%2F%2F%20Poison%20has%20additional%20information%20about%20the%20type%20of%20poison%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20number%20of%20claws%20and%20size%20is%20bound%20to%20the%20variables%20num_claws%20and%20size%0A%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Enumerationes con Data
      content_markdown: |
        Li elementes de `enum` posse haver un o plu data-tipes, quel es un poc simil a *union* in C.

        Quande on fa un pattern match (filtrage de mustres) con `match`, on posse ligar un nómine de variabile a chascun data-valore.

        Detallies pri `enum` in memorie:
        * Un data-valore por un enum va posseder un grandore egal a su max grand element. Con to, omni possibil valores 
        va posser intrar li sam loc de memorie.
        * Ultra le data-tipes de elementes (si ili trova se), chascun element have un valore numeric 
        quel representa su tag (marcation).

        Altri detallies:
        * `enum` in Rust es anc conosset quam un *tagged-union* (marcat union)
        * Li combination de tipes por crear un nov tip es li cose pri quel li gente parla quande ili di que Rust 
        possede *algebraic types*.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Specie%20%7B%20Crabe%2C%20Octopus%2C%20Pisc%2C%20Mollusco%20%7D%0Aenum%20TipVenen%20%7B%20Acidic%2C%20Dolorosi%2C%20Mortific%20%7D%0Aenum%20Grandore%20%7B%20Grand%2C%20Litt%20%7D%0Aenum%20Arme%20%7B%0A%20%20%20%20Griffe(i32%2C%20Grandore)%2C%0A%20%20%20%20Venen(TipVenen)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20CreaturaMarin%20%7B%0A%20%20%20%20specie%3A%20Specie%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20Arme%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Li%20data%20de%20CreaturaMarin%20es%20sur%20li%20stack%0A%20%20%20%20let%20ferris%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Anc%20li%20struct%20String%20es%20sur%20li%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20ma%20possede%20un%20referentie%20al%20data%20sur%20li%20heap%0A%20%20%20%20%20%20%20%20specie%3A%20Specie%3A%3ACrabe%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%202%2C%0A%20%20%20%20%20%20%20%20jambes%3A%204%2C%0A%20%20%20%20%20%20%20%20arme%3A%20Arme%3A%3AGriffe(2%2C%20Grandore%3A%3ALitt)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.specie%20%7B%0A%20%20%20%20%20%20%20%20Specie%3A%3ACrabe%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.arme%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Arme%3A%3AGriffe(num_griffes%2C%20grandore)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20descrition_de_grandore%20%3D%20match%20grandore%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Grandore%3A%3AGrand%20%3D%3E%20%22grand%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Grandore%3A%3ALitt%20%3D%3E%20%22litt%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20es%20un%20crabe%20con%20%7B%7D%20%7B%7D%20griffes%22%2C%20num_griffes%2C%20descrition_de_grandore)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20es%20un%20crabe%20con%20alquel%20altri%20arme%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20es%20alquel%20altri%20animale%22)%2C%0A%20%20%20%20%7D%0A%7D%0A

    ru:
      title: Перечисления с данными
      content_markdown: |
        Элементы `enum` также могут иметь один и больше типов данных (например, структуру или кортеж-структуру). 
        Это чем-то похоже на *union* с языка C.

        Когда `enum` сравнивается с серией шаблонов (или матчится, англ. is pattern matched), вы можете
        связать имя переменной к каждому значению или полю структуры.

        Как `enum` представлен в памяти:
        * Перечисление будет иметь размер, равный наибольшему из его элементов. Это позволяет всем потенциальным
          значениям вместиться в одну и ту же область памяти (без дополнительных выделений памяти).
        * Элементы перечисления имеют невидимый числовой тэг в дополнении к данным, что этот элемент уже и так несет.

        Еще немного информации:
        * `enum` Rust(а) иногда называют *типом-сумой* (tagged-union)
        * Комбинирование разных типов, чтобы создать новый тип - это то, что люди имеют ввиду, когда говорят, что
          Rust имеет *алгебраические типы*
    es:
      title: Enumeraciones con Datos
      content_markdown: |
        Los elementos de un `enum` también pueden tener uno o más tipos de datos que les permitan comportarse como *union* en C.

        Cuando un elemento `enum` se empareja con un patrón usando `match`, se puede vincular un nombre de variable a cada valor de datos.

        Detalles de memoria para `enum`:
        * Un valor de datos enum tendrá un tamaño de memoria igual a su elemento más grande. Esto permite que todos
        los potenciales valores quepan en el mismo espacio de memoria.
        * Además de los tipos de datos de los elementos (si los hay), cada elemento tiene también un valor numérico
        que representa qué etiqueta es.

        Otros detalles:
        * El `enum` de Rust también se conoce como *unión etiquetada* (tagged-union).
        * La combinación de tipos para hacer otros nuevos es a lo que nos referimos al decir que Rust tiene *tipos algebraicos*.
    pt-br:
      title: Enumerações com Dados
      content_markdown: |
        Os elementos `enum` também podem ter um ou mais tipos de dados permitindo que eles se comportem
        como o *union* da linguagem C.

        Quando um `enum` corresponde ao padrão usando `match`, você pode vincular um nome de variável 
        para cada valor de dados.

        Detalhes de memória do `enum`:
        * Um valor de dados *enum* terá um tamanho de memória igual ao seu maior elemento. Isso permite
          que todos os valores possíveis caibam no mesmo espaço de memória.
        * Além dos tipos de dados do elemento (se houver), cada elemento também possui um valor numérico 
          que representa qual etiqueta (tag) ele é.

        Outros detalhes:
        * O `enum` do Rust também é conhecido como *tagged-union*
        * A combinação de tipos para criar um novo tipo é a o que nos referimos quando dizemos que Rust 
          tem *tipos algébricos*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20esta%20linha%20evita%20avisos%20do%20compilador%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20os%20dados%20de%20SeaCreature%20est%C3%A3o%20na%20pilha%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20A%20struct%20da%20String%20tamb%C3%A9m%20est%C3%A1%20na%20pilha%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20mas%20mant%C3%A9m%20uma%20refer%C3%AAncia%20dos%20dados%20na%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22grandes%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22pequenas%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22Ferris%20%C3%A9%20um%20caranguejo%20com%20%7B%7D%20garras%20%7B%7D%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22Ferris%20%C3%A9%20um%20caranguejo%20com%20outro%20tipo%20de%20arma%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22Ferris%20%C3%A9%20outro%20tipo%20de%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D
  - en:
      title: Chapter 3 - Conclusion
      content_markdown: |
        How exciting! We now have a the most basic tools for representing the form of our ideas in code. Hopefully now we 
        can see a glimmer of how Rust's fundamental operations work in harmony and conciseness with its types.  Next up we will talk about 
        a concept that gives our data types even more flexibility of representation: *generics*.
    de:
      title: Kapitel 3 - Fazit
      content_markdown: |
        Wie aufregend! Wir haben jetzt das Werkzeug, womit wir unsere Ideen im Code repräsentieren können.
        Diese Einblicke in Rust's fundamentale Operationen und wie sie im Einklang zueinander stehen, sollte bei so manchen von euch
        hoffentlich einen Funken verursacht haben. Als nächstes wagen wir uns in noch mehr Flexibilität: den *generics*.
    ie:
      title: Capitul 3 - Conclusion
      content_markdown: |
        Quam excitant! Noi ja nu possede un tre basic utensilarium por representar li forme de nor idés in nor code. 
        Esperabilmen desde nu noi va posseder un poc aclaration pri qualmen li operationes fundamental in Rust labora junt 
        in harmonie e con concision con su tipes. A sequer noi va parlar pri un concept quel da nor data-types 
        mem plu flexibilitá e plu representation: *generics*.
    ru:
      title: Глава 3 - Заключение
      content_markdown: |
        Как здорово! Теперь у нас есть базовые инструменты для представления форм наших идей в коде. 
        Надеемся, что теперь мы можем увидеть проблеск того, как основные операции Rust работают в 
        гармонии и согласии с его типами. Далее мы поговорим о концепции, которая дает нашим типам данных 
        ещё большую гибкость представления: *дженерики* (шаблонные типы данных).
    es:
      title: Capítulo 3 - Conclusión
      content_markdown: |
        ¡Genial! Ahora tenemos las herramientas más básicas para representar nuestras ideas en código.
        Esperemos que ahora podamos ver un atisbo de cómo las operaciones fundamentales de Rust funcionan
        en armonía y concisión con sus tipos. A continuación hablaremos de un concepto que da a nuestros
        tipos de datos aún más flexibilidad de representación: *los genéricos*.
    pt-br:
      title: Capítulo 3 - Conclusão
      content_markdown: |
        Que legal! Agora temos as ferramentas mais básicas para representar as nossas idéias no código. 
        Esperamos que agora possamos ver como as operações fundamentais do Rust funcionam em harmonia
        e concisão com seus tipos. A seguir, falaremos sobre um conceito que oferece aos nossos tipos 
        de dados ainda mais flexibilidade de representação: *genéricos*.
  - chapter: 4
    en:
      title: Chapter 4 - Generic Types
      content_markdown: |
        Generic types are incredibly important in Rust. They are used in the representation 
        of nullable values (i.e. variables which might not have a value yet), error handling, 
        collections, and more! In this section we will be learning about the foundational generic types 
        you will likely be using all the time.
    ie:
      title: Capitul 4 - Tipes Géneric
      content_markdown: |
        Tipes géneric es íncredibilmen important in Rust. On usa les por representar valores nullabil
        (t.e. variabiles ancor ne possedent un valore), por tractar errores, colectiones e plu!
        In ti-ci section noi va aprender pri li fundamental tipes géneric queles tu va max possibilmen
        sempre utilisar.
    pt-br:
      title: Capítulo 4 - Tipos Genéricos
      content_markdown: |
        Tipos genéricos são incrivelmente importantes no Rust. Eles são usados na representação de 
        valores *null* (ou seja, variáveis que ainda não tenham um valor atribuído), tratamento de erros, 
        coleções e muito mais! Nesta seção aprenderemos sobre os tipos genéricos fundamentais que você
        provavelmente usará o tempo todo.
  - en:
      title: What Are Generic Types?
      content_markdown: |
        Generic types allow us to partially define a `struct` or `enum`, enabling a compiler to create a fully 
        defined version at compile-time based off our code usage.

        Rust generally can infer the final type by looking at our instantiation, but if it needs help you 
        can always be explicit using the `::<T>` operator, also known by the name `turbofish` (he's a good friend of mine!).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20A%20partially%20defined%20struct%20type%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20item%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Note%3A%20by%20using%20generic%20types%20here%2C%20we%20create%20compile-time%20created%20types%0A%20%20%20%20%2F%2F%20making%20our%20code-size%20bigger.%20Turbofish%20let's%20us%20be%20explicit.%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%2042%20%7D%3B%0A%20%20%20%20let%20bool_bag%20%3D%20BagOfHolding%3A%3A%3Cbool%3E%20%7B%20item%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Rust%20can%20infer%20types%20for%20generics%20too!%0A%20%20%20%20let%20float_bag%20%3D%20BagOfHolding%20%7B%20item%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Note%3A%20never%20put%20a%20bag%20of%20holding%20in%20a%20bag%20of%20holding%20in%20real%20life%0A%20%20%20%20let%20bag_in_bag%20%3D%20BagOfHolding%20%7B%0A%20%20%20%20%20%20%20%20item%3A%20BagOfHolding%20%7B%20item%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20i32_bag.item%2C%20bool_bag.item%2C%20float_bag.item%2C%20bag_in_bag.item.item%0A%20%20%20%20)%3B%0A%7D%0A
    ie:
      title: Quo es Tipes Géneric?
      content_markdown: |
        Tipes géneric possibilisa li partial definition de un `struct` o `enum`, con quel li compilator va posser
        crear un version completmen definat quande it compila se secun li code quel noi scri.

        Rust por li pluparte posse inferer li tip final per regardar nor instantiation, ma si it besona auxilie tu posse
        sempre esser plu explicit con li operator `::<T>`, anc conosset con li nómine `turbofish` (un pisc quel es un
        de mi bon amics!).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Un%20partialmen%20definit%20tip%20de%20un%20struct%0Astruct%20SacSinFunde%3CT%3E%20%7B%0A%20%20%20%20articul%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20A%20notar%3A%20per%20li%20usation%20ci%20de%20tipes%20g%C3%A9neric%2C%20noi%20crea%20tipes%20creat%20durant%0A%20%20%20%20%2F%2F%20li%20compilation%2C%20agrandante%20li%20grandore%20de%20nor%20code.%20Turbofish%20auxilia%20nos%0A%20%20%20%20%2F%2F%20esser%20explicit.%0A%20%20%20%20let%20sac_i32%20%3D%20SacSinFunde%3A%3A%3Ci32%3E%20%7B%20articul%3A%2042%20%7D%3B%0A%20%20%20%20let%20sac_bool%20%3D%20SacSinFunde%3A%3A%3Cbool%3E%20%7B%20articul%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Rust%20posse%20inferer%20tipes%20anc%20por%20g%C3%A9nerics!%0A%20%20%20%20let%20sac_quel_plana%20%3D%20SacSinFunde%20%7B%20articul%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20A%20notar%3A%20nequande%20plazzar%20un%20sac%20sin%20funde%20in%20un%20sac%20sin%20funde%20%0A%20%20%20%20%2F%2F%20in%20li%20ver%20vive%0A%20%20%20%20let%20sac_in_sac%20%3D%20SacSinFunde%20%7B%0A%20%20%20%20%20%20%20%20articul%3A%20SacSinFunde%20%7B%20articul%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20sac_i32.articul%2C%20sac_bool.articul%2C%20sac_quel_plana.articul%2C%20sac_in_sac.articul.articul%0A%20%20%20%20)%3B%0A%7D%0A
    pt-br:
      title: O Que São Tipos Genéricos?
      content_markdown: |
        Tipos genéricos nos permitem definir parcialmente uma `struct` ou `enum`, deixando que o 
        compilador instancie uma versão dela definida em tempo de compilação totalmente com base em
        nosso código.

        Geralmente o Rust pode inferir o tipo final observando a nossa instanciação, mas se ele precisar de
        ajuda você sempre pode ser explícito usando o operador `::<T>`, também conhecido pelo nome `turbofish`
        (ele é um bom amigo meu!).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Um%20tipo%20struct%20definido%20parcialmente%0Astruct%20Sacola%3CT%3E%20%7B%0A%20%20%20%20item%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Nota%3A%20usando%20tipos%20gen%C3%A9ricos%20aqui%20n%C3%B3s%20criamos%20tipos%20em%20tempo%20de%20compila%C3%A7%C3%A3o%0A%20%20%20%20%2F%2F%20fazendo%20o%20nosso%20c%C3%B3digo%20ficar%20maior.%20O%20turbofish%20nos%20permite%20ser%20expl%C3%ADcitos.%0A%20%20%20%20let%20i32_sacola%20%3D%20Sacola%3A%3A%3Ci32%3E%20%7B%20item%3A%2042%20%7D%3B%0A%20%20%20%20let%20bool_sacola%20%3D%20Sacola%3A%3A%3Cbool%3E%20%7B%20item%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20O%20Rust%20pode%20inferir%20os%20tipos%20para%20gen%C3%A9ricos%20tamb%C3%A9m!%0A%20%20%20%20let%20float_sacola%20%3D%20Sacola%20%7B%20item%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Nota%3A%20nunca%20coloque%20uma%20sacola%20dentro%20da%20outra%20na%20vida%20real%0A%20%20%20%20let%20sacola_na_sacola%20%3D%20Sacola%20%7B%0A%20%20%20%20%20%20%20%20item%3A%20Sacola%20%7B%20item%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20i32_sacola.item%2C%20bool_sacola.item%2C%20float_sacola.item%2C%20sacola_na_sacola.item.item%0A%20%20%20%20)%3B%0A%7D%0A
  - en:
      title: Representing Nothing
      content_markdown: |
        In other languages, the keyword `null` is used to represent an absense of a value. It creates
        difficulty in programming languages because it creates the possibility that our program might fail 
        when interacting with a variable/field.

        Rust does not have `null`, but it is not ignorant of the importance of representing nothing! 
        Consider a naive representation using a tool we already know.

        This pattern of providing a `None` alternative representation for one or many alternate values is so 
        common Rust because of its lack of a `null` value. Generic types help solve this challenge.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventory(String)%2C%0A%20%20%20%20%2F%2F%20None%20represents%20the%20absence%20of%20an%20item%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20BagOfHolding%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A
    ie:
      title: Representar Nullcos
      content_markdown: |
        In altri lingues, on usa li clave-parol `null` por representar li absentie de un valore. To crea 
        desfacilitás in lingues de programmation pro que it crea li possibilitá de fallition de nor programma 
        quande it interacte con un variabile/camp.

        Rust ne possede `null`, ma it conosse tre bon li importantie de posser representar nullcos!
        Lass nos considerar un representation naiv usante un utensile quel noi ja conosse.

        Ti-ci mustre quel provide un alternativ represantation usante `None` es tam comun in Rust pro su 
        manca de un valore `null`. Tipes géneric auxilia soluer ti-ci defí.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Articul%20%7B%0A%20%20%20%20Inventarie(String)%2C%0A%20%20%20%20%2F%2F%20None%20representa%20li%20absentie%20de%20un%20articul%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20SacSinFunde%20%7B%0A%20%20%20%20articul%3A%20Articul%2C%0A%7D%0A
    pt-br:
      title: Representando o Nada
      content_markdown: |
        Em outras linguagens, a palavra-chave `null` é usada para representar a ausência de um valor.
        Isso cria dificuldades nas linguagens de programação, porque possibilita que o nosso programa
        possa falhar ao interagir com uma variável/campo.

        O Rust não tem `null`, mas não ignora a importância de representar o *nada*! Considere uma
        representação ingênua usando uma ferramenta que já conhecemos.

        Esse padrão para fornecer uma representação alternativa ao `None` por um ou vários valores
        alternados é muito comum em Rust devido à falta de um valor `null`. Os tipos genéricos 
        ajudam a resolver esse desafio.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventario(String)%2C%0A%20%20%20%20%2F%2F%20None%20representa%20a%20aus%C3%AAncia%20de%20um%20item%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20Sacola%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A
  - en:
      title: Option
      content_markdown: |
        Rust has a built in generic enum called `Option` that allows us to represent nullable values 
        without using `null`.

         ```
        enum Option<T>{
          Some(T),
          None
        }
        ```

        This enum is so common, instances of the enum can be created anywhere with the keyword `Some` and `None`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20A%20partially%20defined%20struct%20type%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Our%20parameter%20type%20T%20can%20be%20handed%20to%20others%0A%20%20%20%20item%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Note%3A%20A%20bag%20for%20i32%2C%20holding%20nothing!%20We%20have%20to%20specify%20the%20type%0A%20%20%20%20%2F%2F%20because%20otherwise%20Rust%20would%20not%20know%20what%20type%20of%20bag%20it%20is.%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20nothing%20in%20the%20bag!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20something%20in%20the%20bag!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20something%20in%20the%20bag!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20nothing%20in%20the%20bag!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20match%20lets%20us%20deconstruct%20Option%20elegantly%20and%20ensure%20we%20handle%20all%20cases!%0A%20%20%20%20match%20i32_bag.item%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22found%20%7B%7D%20in%20bag!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22found%20nothing%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Option
      content_markdown: |
        Rust possede ja un enum géneric nominat `Option` quel lassa nos posser representar valores nullabil
        sin li usation de `null.`

        ```
        enum Option<T>{
          Some(T),
          None
        }
        ```

        Ti enum es tam frequent que on posse crear instanties de it úcunc con li clave-paroles `Some` e `None`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Un%20partialmen%20definit%20tip%20de%20un%20struct%0Astruct%20SacSinFunde%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Our%20parameter%20type%20T%20can%20be%20handed%20to%20others%0A%20%20%20%20articul%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20A%20notar%3A%20un%20sac%20por%20i32%2C%20possedente%20nullcos!%20Noi%20deve%20specificar%20li%20tip%0A%20%20%20%20%2F%2F%20pro%20que%20altrimen%20Rust%20ne%20vell%20saver%20pri%20quel%20tip%20de%20sac%20it%20acte%20se.%0A%20%20%20%20let%20sac_i32%20%3D%20SacSinFunde%3A%3A%3Ci32%3E%20%7B%20articul%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20sac_i32.articul.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20nequo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20alquo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20sac_i32%20%3D%20SacSinFunde%3A%3A%3Ci32%3E%20%7B%20articul%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20sac_i32.articul.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20alquo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20nequo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20con%20match%20noi%20posse%20elegantmen%20deconstructer%20Option%20e%20esser%20cert%20que%0A%20%20%20%20%2F%2F%20omni%20casus%20es%20tractat!%0A%20%20%20%20match%20sac_i32.articul%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22Trovat%20%7B%7D%20in%20li%20sac!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22Nequo%20trovat%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    pt-br:
      title: Option
      content_markdown: |
        O Rust possui uma enumeração genérica embutida chamada `Option` que nos permite representar valores 
        nulos sem precisar usar o `null`.

         ```
        enum Option<T>{
          Some(T),
          None
        }
        ```

        Essa enumeração é tão comum que as suas instâncias podem ser criadas em qualquer lugar com a 
        palavra-chave `Some` e `None`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Um%20tipo%20struct%20parcialmente%20definido%0Astruct%20Sacola%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Nosso%20par%C3%A2metro%20T%20pode%20ser%20entregue%20a%20outros%0A%20%20%20%20item%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Nota%3A%20Uma%20sacola%20para%20i32%2C%20contendo%20nada!%20Precisamos%20especificar%20o%20tipo%0A%20%20%20%20%2F%2F%20porque%20sen%C3%A3o%20o%20Rust%20n%C3%A3o%20saber%C3%A1%20qual%20o%20tipo%20que%20sacola%20%C3%A9.%0A%20%20%20%20let%20i32_sacola%20%3D%20Sacola%3A%3A%3Ci32%3E%20%7B%20item%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20i32_sacola.item.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22n%C3%A3o%20h%C3%A1%20nada%20na%20sacola!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tem%20alguma%20coisa%20na%20sacola!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i32_sacola%20%3D%20Sacola%3A%3A%3Ci32%3E%20%7B%20item%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20i32_sacola.item.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tem%20alguma%20coisa%20na%20sacola!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22n%C3%A3o%20h%C3%A1%20nada%20na%20sacola!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20match%20lets%20us%20deconstruct%20Option%20elegantly%20and%20ensure%20we%20handle%20all%20cases!%0A%20%20%20%20match%20i32_sacola.item%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22encontrei%20%7B%7D%20na%20sacola!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22n%C3%A3o%20encontrei%20nada%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Result
      content_markdown: |
        Rust has a built in generic enum called `Result` that allows us to return a value that has the possibility of failing.
        It is the idiomatic way in which the language does error handling.

         ```
        enum Result<T,Q>{
          Ok(T),
          Err(Q)
        }
        ```

        Note that our generics type has multiple *parameterized types* separated by a comma.

        This enum is so common, instances of the enum can be created anywhere with the keyword `Ok` and `Err`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20%2F%2F%20match%20lets%20us%20deconstruct%20Result%20elegantly%20and%20ensure%20we%20handle%20all%20cases!%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22found%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Error%3A%20%7B%7D%22%2Ce)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Result
      content_markdown: |
        Rust possede su propri enum géneric nominat `Result` (resultate) quel lassa nos posser retornar un valore quel posse fallir.
        To es li maniere idiomatic in ti lingue por tractar errores.

        ```
        enum Result<T,Q>{
          Ok(T),
          Err(Q)
        }
        ```

        A notar que nor tip géneric possede pluri *tipes parametrisat* separat per commas.

        Ti enum es tam frequent que on posse crear instanties de it úcunc con li clave-paroles `Ok` e `Err`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20far_alquo_quel_posse_fallir(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22Li%20numer%C3%B3%20ne%20es%20just%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20far_alquo_quel_posse_fallir(12)%3B%0A%0A%20%20%20%20%2F%2F%20con%20match%20noi%20posse%20elegantmen%20deconstructer%20Result%20e%20tracter%20pri%0A%20%20%20%20%2F%2F%20omni%20possibil%20casus!%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22%7B%7D%20trovat%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Errore%3A%20%7B%7D%22%2C%20e)%2C%0A%20%20%20%20%7D%0A%7D%0A
    pt-br:
      title: Result
      content_markdown: |
        O Rust possui uma enumeração genérica chamada `Result` que nos permite retornar um valor que 
        tem a possibilidade de falhar.

        Esta é a maneira idiomática pela qual a linguagem faz a manipulação de erros.

        ```
        enum Result<T,Q>{
          Ok(T),
          Err(Q)
        }
        ```

        Observe que os nosso tipos genéricos possuem vários *tipos parametrizados* separados por
        vírgula.

        Esta enumeração é tão comum que instâncias dela podem ser criadas em qualquer lugar com
        as palavras-chave `Ok` e `Err`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20faz_alguma_coisa_que_pode_falhar(12)%3B%0A%0A%20%20%20%20%2F%2F%20o%20match%20nos%20permite%20desconstruir%20o%20Result%20elegantemente%20%0A%20%20%20%20%2F%2F%20e%20garante%20que%20lidemos%20com%20todos%20os%20casos!%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22encontrei%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Erro%3A%20%7B%7D%22%2C%20e)%2C%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Failable Main
      content_markdown: |
        `main` has the capability of returning a `Result`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Main%20returns%20no%20value%2C%20but%20could%20return%20an%20error!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22found%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20handle%20this%20error%20gracefully%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20return%20a%20new%20error%20from%20main%20that%20said%20what%20happened!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22something%20went%20wrong%20in%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Notice%20we%20use%20a%20unit%20value%20inside%20a%20Result%20Ok%0A%20%20%20%20%2F%2F%20to%20represent%20everything%20is%20fine%0A%20%20%20%20Ok(())%0A%7D%0A
    ie:
      title: Un Main Fallibil
      content_markdown: |
        Anc `main` posse retornar un `Result`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20far_alquo_quel_posse_fallir(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22Li%20numer%C3%B3%20ne%20es%20just%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Main%20retorna%20null%20valore%2C%20ma%20posse%20retornar%20un%20errore!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20far_alquo_quel_posse_fallir(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22%7B%7D%20trovat%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20tractar%20ti-ci%20errore%20gracilmen%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20retornar%20un%20nov%20errore%20de%20main%20quel%20informar%20pri%20quo%20ha%20evenit!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22alquo%20fals%20ha%20evenit%20in%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20A%20notar%20que%20noi%20usa%20in%20valore%20unit%20intra%20un%20Result%20Ok%0A%20%20%20%20%2F%2F%20por%20monstrar%20que%20omnicos%20standa%20bon%0A%20%20%20%20Ok(())%0A%7D%0A
    pt-br:
      title: Main Falível
      content_markdown: |
        O `main` tem a capacidade de retornar um `Result`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20o%20Main%20n%C3%A3o%20retorna%20um%20valor%2C%20mas%20pode%20retornar%20um%20erro!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20faz_alguma_coisa_que_pode_falhar(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22encontrei%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20lida%20com%20o%20erro%20normalmente%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20retorna%20um%20novo%20erro%20do%20main%20que%20nos%20informa%20o%20que%20houve!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22alguma%20coisa%20deu%20errado%20em%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Observe%20que%20usamos%20um%20valor%20unit%20dentro%20de%20um%20Result%20Ok%0A%20%20%20%20%2F%2F%20para%20representar%20que%20est%C3%A1%20tudo%20bem%0A%20%20%20%20Ok(())%0A%7D%0A
  - en:
      title: Graceful Error Handling
      content_markdown: |
        `Result` is so common that Rust has a powerful operator `?` for working with them. These two statements are equivalent:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
          Ok(v) => v,
          Err(e) => { return e; },
        }
        ```

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20Look%20at%20how%20much%20code%20we%20saved!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42)%3F%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
    ie:
      title: Gracil Tractation de Errores
      content_markdown: |
        `Result` es tam frequent que Rust possede li potent operator `?` por tractar con ili. Ti du declarationes es egal:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
          Ok(v) => v,
          Err(e) => { return e; },
        }
        ```
    pt-br:
      title: Manipulação de Erros Elegantes
      content_markdown: |
        O `Result` é tão comum que o Rust tem o poderoso operador `?` para trabalhar com ele. 
        Estas duas declarações são equivalentes:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
          Ok(v) => v,
          Err(e) => { return e; },
        }
        ```

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20Olha%20quanto%20c%C3%B3digo%20n%C3%B3s%20salvamos!%0A%20%20%20%20let%20v%20%3D%20faz_alguma_coisa_que_pode_falhar(42)%3F%3B%0A%20%20%20%20println!(%22encontrei%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
  - en:
      title: Ugly Option/Error Handling
      content_markdown: |
        Working with `Option`/`Result` can be tedious when you are just trying to write some quick code.  Both `Option` and `Result` have a 
        function called `unwrap` that can be useful for getting a value in a quick and dirty manner.  `unwrap` will:
         
        1. Get the value inside Option/Result
        2. If the enum is of type None/Err, `panic!`

        These two pieces of code are equivalent:

        ```
        my_option.unwrap()
        ```

        ```
        match my_option {
          Some(v) => v,
          None => panic!("some error message generated by Rust!")
        }
        ```

        Similarly:

        ```
        my_result.unwrap()
        ```

        ```
        match my_result {
          Ok(v) => v,
          Err(e) => panic!("some error message generated by Rust!")
        }
        ```

        Be a good rustacean and properly use `match` when you can!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20concise%20but%20assumptive%20and%20gets%20ugly%20fast%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20will%20panic!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(1).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A

    ie:
      title: Desbell Tractation de Errores
      content_markdown: |
        Sempre usar `Option`/`Result` posse devenir íncomod quande on simplicmen vole scrir un poc code. Ambi `Option` e `Result`
        have un metode nominat `unwrap` (aperter) quel es comod por strax obtenir un valore ma con un poc desbellesse. `unwrap` va:

        1. trovar li valore intra Option/Result
        2. si li valore es de tip None/Err, `panic`!

        Ti du pezzes de code es egal:

        ```
        mi_option.unwrap()
        ```

        ```
        match mi_option {
          Some(v) => v,
          None => panic!("alquel erra-missage generat de Rust!")
        }
        ```

        Similmen:

        ```
        mi_result.unwrap()
        ```

        ```
        match mi_result {
          Ok(v) => v,
          Err(e) => panic!("alquel erra-missage generat de Rust!")
        }
        ```

        Esse un bon Rustaceane e usa `match` sempre quande tu posse!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20far_alquo_quel_posse_fallir(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22Li%20numer%C3%B3%20ne%20es%20just!%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20concis%20ma%20basat%20pri%20assumptiones%20e%20strax%20desbell%0A%20%20%20%20let%20v%20%3D%20far_alquo_quel_posse_fallir(42).unwrap()%3B%0A%20%20%20%20println!(%22%7B%7D%20trovat%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20to-ci%20va%20generar%20un%20panic!%0A%20%20%20%20let%20v%20%3D%20far_alquo_quel_posse_fallir(1).unwrap()%3B%0A%20%20%20%20println!(%22%7B%7D%20trovat%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A
    pt-br:
      title: Manipulação de Option/Erros Deselegante
      content_markdown: |
        Trabalhar com `Option`/`Result` pode ser entediante quando você está apenas tentando escrever
        um código rápido. Tanto `Option` quanto `Result` têm uma função chamada `unwrap` que pode ser
        útil para obter um valor de maneira rápida e *feia*. `unwrap` irá:
         
        1. Obter o valor de Option/Result
        2. Se a enumeração for do tipo None/Err, `panic!`

        Esses dois trechos de código são equivalentes:

        ```
        my_option.unwrap()
        ```

        ```
        match my_option {
          Some(v) => v,
          None => panic!("alguma mensagem de erro gerada pelo Rust!")
        }
        ```

        Similarmente:

        ```
        my_result.unwrap()
        ```

        ```
        match my_result {
          Ok(v) => v,
          Err(e) => panic!("alguma mensagem de erro gerada pelo Rust!")
        }
        ```

        Seja um bom rustáceo e use `match` apropriadamente quando puder!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20conciso%2C%20mas%20pretencioso%20e%20falha%20r%C3%A1pido%0A%20%20%20%20let%20v%20%3D%20faz_alguma_coisa_que_pode_falhar(42).unwrap()%3B%0A%20%20%20%20println!(%22encontrei%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20erro%20de%20panic!%0A%20%20%20%20let%20v%20%3D%20faz_alguma_coisa_que_pode_falhar(1).unwrap()%3B%0A%20%20%20%20println!(%22encontrei%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A
  - en:
      title: Vectors
      content_markdown: |
        Some of the most useful generic types are collection types. A vector is a variably sized list of items
        represented by the struct `Vec`.

        The macro `vec!` lets us easily create a vector rather than manually constructing one.

        `Vec` has the method `iter()` which creates an iterator from a vector, allowing us to easily
        put a vector into a `for` loop.

        Memory Details:
        * `Vec` is a struct, but internally it contains a reference to a fixed list of its items on the heap.
        * A vector starts with a default capacity, when more items are added than it has capacity for, it 
          reallocates its data on the heap to have a new fixed list with large capacity.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20We%20can%20be%20explicit%20with%20type%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbofish%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20But%20look%20how%20clever%20Rust%20is%20about%20determining%20the%20type%20automatically%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20That's%20a%20beautiful%20macro!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Hello%22)%2C%20String%3A%3Afrom(%22World%22)%5D%3B%0A%0A%20%20%20%20for%20word%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20word)%3B%0A%20%20%20%20%7D%0A%7D%0A

    ie:
      title: Vectors
      content_markdown: |
        Li tipes por colectiones es un del max util tipes géneric. Un vector es un variabilmen mesurat 
        liste de articules representat per li struct `Vec`.

        Li macro `vec!` lassa nos facilmen crear un vector vice crear un manualmen.

        `Vec` have li metode `iter()` quel crea un iterator de un vector, con quel noi posse facilmen
        plazzar un vector in un loop `for`.

        Detallies pri memorie:
        * `Vec` es un struct, ma internmen it contene un referentie a un fix liste de su articules sur li heap.
        * Un vector comensa con un capacitá decidet, ma quande on adjunte coses a it queles superpassa su capacitá, it
        realoca li data sur li heap por haver un nov liste fix con un plu grand capacitá
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Noi%20posse%20esser%20explicit%20pri%20tipes%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbopisc%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20Ma%20vide%20quam%20inteligent%20es%20Rust%20pri%20automaticmen%20determinar%20li%20lip%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20Quam%20bell%20macro!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Salute%22)%2C%20String%3A%3Afrom(%22Munde%22)%5D%3B%0A%0A%20%20%20%20for%20parol%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20parol)%3B%0A%20%20%20%20%7D%0A%7D%0A

    pt-br:
      title: Matrizes
      content_markdown: |
        Alguns dos tipos genéricos mais úteis são os tipos de coleção. Uma matriz é uma lista de itens 
        de tamanho variável representada pela estrutura `Vec`.

        A macro `vec!` nos permite criar facilmente uma matriz ao invés de contruir uma manualmente.

        `Vec` possui o método `iter()` o qual cria um iterador a partir de uma matriz, permitindo-nos 
        facilmente usr uma matriz em um loop `for`.

        Detalhes da Memória:
        * `Vec` é um struct, mas internamente contém uma referência a uma lista fixa de seus itens no heap.
        * Uma matriz começa com uma capacidade padrão. Quando são adicionados mais itens do que a capacidade
          inicial, ele realoca seus dados no heap para ter uma nova lista fixa com capacidade maior.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Podemos%20ser%20expl%C3%ADcitos%20com%20o%20tipo%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbofish%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20Veja%20qu%C3%A3o%20esperto%20o%20Rust%20%C3%A9%20determinando%20o%20tipo%20automaticamente%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20Olha%20que%20macro%20linda!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Ol%C3%A1%22)%2C%20String%3A%3Afrom(%22Mundo%22)%5D%3B%0A%0A%20%20%20%20for%20word%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20word)%3B%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Chapter 4 - Conclusion
      content_markdown: |
        In one chapter we've learned how much power generic types give us! Don't worry if you don't 
        know fully how to use everything, right now it's just good to be aware of the major ideas you will
        see again and again in code. Our functions are getting quite lengthy! In our next chapter we will 
        spend talk about an important concept in Rust: data ownership.

    ie:
      title: Capitul 4 - Conclusion
      content_markdown: |
        In un sol capitul noi ha aprendet pri li potentie quel li tipes géneric da nos! Ne sucia te si tu ancor
        ne save qualmen usar omnicos. Por li moment, it es plu important solmen esser conscient pri li grand
        idés queles tu va vider denov e denov in code. Nor functiones ha tam agrandat se! In li capitul a sequer
        noi va transpassa li tot capitul per discusser qualmen passar data inter functioner por que noi mey posser
        vider li detallies e devenir plu clar pri qualmen Rust regarda memorie.
    pt-br:
      title: Capítulo 4 - Conclusão
      content_markdown: |
        Em um capítulo aprendemos quanta força os tipos genéricos nos dão! Não se preocupe se você não 
        souber como usar tudo, porque agora é bom estar ciente das principais idéias que você verá 
        repetidas vezes no código. Nossas funções estão ficando muito longas! No próximo capítulo,
        falaremos sobre um conceito importante no Rust: propriedade de dados.
  - beta: true
    chapter: 5
    en:
      title: Chapter 5 - Ownership & Borrowing Data
      content_markdown: |
        Rust has a unique paradigm for managing memory compared to other programming languages. We're going to look at
        the behaviors and validations of the compiler one by one so it's not overwhelming. It's important to remember that 
        ultimately the rules we show don't exist to make your life hard, but to help you make your code less error-prone!
  - beta: true
    en:
      title: Ownership
      content_markdown: |
        Instantiating a type and **binding** it to a variable name creates a memory resource that the Rust compiler will validate
        through its whole **lifetime**.  The bound variable is called the resource's **owner**.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20We%20instantiate%20structs%20and%20bind%20to%20variables%0A%20%20%20%20%2F%2F%20to%20create%20memory%20resources%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20the%20owner%0A%7D%0A
  - beta: true
    en:
      title: Scope-Based Resource Management
      content_markdown: |
        Rust uses the last place of usage or end of function scope as the place to deconstruct and deallocate a resource.

        The term for this deconstruction and deallocation is called a **drop**.

        Memory detail:
        * Rust does not have garbage collection.
        * This is also called Resource Aquisition Is Initialization ( RAII ) in C++.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20it's%20no%20longer%0A%20%20%20%20%2F%2F%20used%20to%20after%20this%20location%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%20because%20of%20the%20end%0A%20%20%20%20%2F%2F%20of%20the%20function%20scope%0A%7D%0A
  - beta: true
    en:
      title: Dropping is Heirarchal
      content_markdown: |
        When a struct is dropped it's child elements are dropped first.

        Memory Details:
        * By automically freeing memory Rust helps ensure that there are less memory leaks 
        * Memory resources can only be dropped once.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo.bar%20is%20dropped%20first%0A%20%20%20%20%2F%2F%20then%20foo%20is%20dropped%0A%7D%0A
  - beta: true
    en:
      title: Moving Ownership
      content_markdown: |
        When a owner is passed as an argument to a function, ownership is moved to the function parameter.

        After a **move** the variable in the original function can no longer be used.

        Memory details:
        * During a **move** the stack memory of the owners value is copied to the function call's parameter stack memory.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20moved%20to%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20can%20no%20longer%20be%20used%0A%7D%0A
  - beta: true
    en:
      title: Returning Ownership
      content_markdown: |
        Ownership can also be returned from a function.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20ownership%20is%20moved%20out%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20becomes%20the%20owner%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20because%20of%20end%20of%20function%20scope%0A%7D%0A
  - beta: true
    en:
      title: Borrowing Ownership with References
      content_markdown: |
        References allow us borrow access to a resource with the `&` operator.

        References are also dropped like other resources.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
  - beta: true
    en:
      title: Borrowing Mutable Ownership with References
      content_markdown: |
        We can also borrow mutable access to a resource with the `&mut` operator.

        A resource owner cannot be moved or modified while mutably borrowed.

        Memory detail:
        * Rust prevents having two ways to mutate an owned value because it introduces the possibility of a data race.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20do_something(foo)%20would%20fail%20because%0A%20%20%20%20%2F%2F%20foo%20cannot%20be%20moved%20while%20mutably%20borrowed%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20foo.x%20%3D%2013%3B%20would%20fail%20here%20because%20because%0A%20%20%20%20%2F%2F%20foo%20is%20not%20modifiable%20while%20mutably%20borrowed%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%20because%20its%20no%20longer%20used%20after%20this%20point%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20works%20now%20because%20there%20all%20mutable%20references%20were%20dropped%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20move%20foo's%20ownership%20to%20a%20function%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A

  - beta: true
    en:
      title: Dereferencing
      content_markdown: |
        Using references, you can set the owner's value using the `*` operator.

        You can also get a copy of owned value using the `*` operator (If the value can be copied. We will discuss copyable types in later chapters).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20get%20a%20copy%20of%20the%20owner's%20value%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20set%20the%20reference's%20owner's%20value%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A

  - beta: true
    en:
      title: Passing Around Borrowed Data
      content_markdown: |
        Rust's rules for references might best be summarized by:

        * Rust only allows there to be one mutable reference **or** multiple non-mutable references **but not both**
        * A reference must never **live longer** than it's owner.

        This doesn't tend to be a problem when passing around references to functions.

        Memory details:
        * The first rule of references prevents data races. What's a data race? A data race when reading from data has the possibility of being out of sync due to the existance of a writer to the data at the same time. This happens often in multi-threaded programming.
        * The second rule of references prevents the misuse of references that refer to non-existant data ( called dangling pointers in C ).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20mutable%20reference%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20because%20all%20mutable%20references%20are%20dropped%20within%0A%20%20%20%20%2F%2F%20the%20function%20do_something.%20We%20can%20create%20another.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A

  - beta: true
    en:
      title: References Of References
      content_markdown: |
        References can even be used on pieces of references.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A

  - beta: true
    en:
      title: Explicit Lifetimes
      content_markdown: |
        Even though Rust doesn't always show it in code, the compiler understands the lifetime of every variable and will attempt
        to validate a reference never exists longer than it's owner.

        Functions can be explicit by parameterizing the function signature with symbols that help identify 
        which parameters and return values share the same lifetime.

        Lifetime specifiers always start with a `'` (e.g. `'a`, `'b`, `'c`)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20the%20parameter%20foo%20and%20return%20value%20share%20the%20same%20lifetime%0Afn%20do_something%3C'a%3E(foo%3A%20%26'a%20Foo)%20-%3E%20%26'a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A

  - beta: true
    en:
      title: Multiple Lifetimes
      content_markdown: |
        Lifetime specifiers allow us to be explicit with certain scenarios the compiler cannot resolve itself 
        by distinguishing all of a function signature component's lifetimes.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20and%20the%20return%20value%20share%20the%20same%20lifetime%0A%2F%2F%20foo_a%20has%20an%20unrelated%20lifetime%0Afn%20do_something%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20only%20foo_b's%20lifetime%20exist%20beyond%20here%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%0A%7D%0A

  - beta: true
    en:
      title: Static Lifetimes
      content_markdown: |
        A **static** variable is a memory resource created at compile-time that exists through a program start to 
        finish. They must have their types explicitly specified.

        A **static lifetime** is a memory resource that lasts indefinitely to the end of a program.  Note that by this definition
        some static lifetime resources can be created at runtime.

        Resources with static lifetimes have a special lifetime specifier `'static`.

        `'static` resources will never **drop**

        If static lifetime resources contain references they must all be `'static` (anything less would not live long enough).

        Memory detail:

        * Modifying static variables is inherently dangerous because they are globally accessable to be read from by anyone
          introducing the possibility of a data race. We'll talk about the challenges of global data later.
        * Rust allows the use of `unsafe { ... }` block to perform some operations that the compiler cannot make memory gaurantees about. The [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/) should not be talked about casually.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20static%20variables%20can%20also%20be%20scoped%20to%20a%20function%0A%20%20%20%20static%20mut%20SECRET%3A%20%26'static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20string%20literals%20have%20a%20'static%20lifetime%0A%20%20%20%20let%20msg%3A%20%26'static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26'static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20You%20can%20break%20some%20rules%2C%20but%20you%20must%20be%20explicit%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20set%20SECRET%20to%20a%20string%20literal%20because%20it%20is%20also%20%60static%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A

  - beta: true
    en:
      title: Lifetimes In Data Types
      content_markdown: |
        Similarly to functions, data types can be parameterized with lifetime specifiers of it's members.

        Rust validates that the containing data structure of the references never lasts longer than the owners it's references point to.

        We can't have structs running around with references pointing to nothingness!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A

  - beta: true
    en:
      title: Chapter 5 Conclusion
      content_markdown: |
        Whew, congrats for making it through! I know it's alot to take in but you are well
        under way to becoming a Rustacean. Hopefully it's clear how Rust as a language aims to 
        solve many of these common challenges in systems programming:

        * Unintentional modification of resources
        * Forgetting to deconstruct resources 
        * Resources accidently being deconstructed twice
        * Using resources after they have been deconstructed 
        * Data races caused by writing to resources while others are reading from resources 
        * Seeing clearly areas of the code where compiler can’t make guarantees

        In the next chapter we'll apply some of this knowledge as we look how Rust handles text.
  - beta: true
    chapter: 6
    en:
      title: Chapter 6 - Text
      content_markdown: |
        TODO
  - beta: true
    chapter: 7
    en:
      title: Chapter 7 - Object Oriented Programming
      content_markdown: |
        TODO
  - beta: true
    chapter: 7
    en:
      title: Chapter 8 - Smart Pointers
      content_markdown: |
        TODO
  - beta: true
    chapter: 9
    en:
      title: Chapter 9 - Project Organization and Structure
      content_markdown: |
        So far all of our code examples have been a single file. Let's discuss how our code structures and functions can be organized and shared others!
  - beta: true
    en:
      title: Modules
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
      content_markdown: |
        Every Rust program or library is a **crate**.

        Every crate is made of a heirarchy of **modules**.

        Programs start running in the root module of a crate at the `main()` function in a file
        called `main.rs`.

        Libraries have a root module in the file `lib.rs` and export useful members.

        To prevent typing out full paths like `std::f64::consts::PI`.
        The **use** keyword allows us to specify particular items from modules we want
        to use throughout our code without a full path. For instance `use std::f64::consts::PI`
        allows me to just use the identifier `PI` in my main function.

        **std** is the crate of the **standard library** of Rust which is full of useful data
        structures and functions for interacting with your operating system.

        A searchable directory of crates created by the community can be found at [https://crates.io](https://crates.io/)
    de:
      title: Module
      content_html:
        <p>Jedes Programm bzw. jede Bibliothek in Rust ist ein <b>crate</b>
        (Kiste).</p><p>Jedes crate besteht aus einer hierarchischen Ansammlung von <b>modules</b>.</p><p>Programme
        werden aus einem root module (Wurzelelement) eines crates gestartet, Startpunkt
        bildet hierbei die Funktion <code>main()</code> in einer Datei namens
        `main.rs`.<p></p><p>Bibliotheken haben ein root module in der Datei `lib.rs` und
        exportieren nützliche Elemente.</p><p>Um komplette Namespaces wie <code>std::f64::consts::PI</code>
        nicht austippen zu müssen, wurde das <b>use</b> Schlüsselwort eingeführt. Beispielsweise
        erlaubt <code>use std::f64::consts::PI</code> uns den Identifier <code>PI</code>
        in der main-Funktion einfach zu verwenden.</p><p><b>std</b> ist das crate der
        <b>Standardbibliothek</b> von Rust, das allerlei nützliche Datenstrukturen und
        Funktionen beinhalten, durch welche wir mit dem Betriebssystem kommunizieren können.</p><p>Die
        Fanbase von Rust hält die Seite <a href="https://crates.io/">https://crates.io</a>
        am Laufen, auf der es sämtliche crates im Überblick zu finden gibt.</p>
    ie:
      title: Modules
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20println!(%22Benevenit%20al%20lud-terren!%22)%3B%0A%20%20println!(%22Yo%20tant%20desira%20un%20tranche%20de%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
      content_html:
        <p>Chascun programma o biblioteca in Rust es un <b>crate</b> (significant
        un corbe o un chest).</p><p>Chascun crate es composit ex un hierarchie de <b>modules</b>.</p><p>Programmas
        comensa functionar in li module radical de un crate in li function <code>main()</code>
        in un archive nominat `main.rs`.<p></p><p>Bibliotecas have un module radical in
        li archive `lib.rs` e exporta membres util.</p><p>Por prevenir li tipada de plen
        percurses quam <code>std::f64::consts::PI</code>, li clave-parol <b>use</b>
        fa it possibil por nos specificar li articules particulari in modules queles noi
        vole usar tra nor code sin un plen percurse. Por exemple, <code>use std::f64::consts::PI</code>
        possibilisa li sol usation de  <code>PI</code> in mi function main.</p><p><b>std</b>
        es li nómine del biblioteca standard (<b>standard library</b>) de Rust quel es
        plen de util data-structuras e functiones por interacter con tui sistema de operation.</p><p>Un
        searchabil directoria de crates creat per li comunité trova se sur <a href="https://crates.io/">https://crates.io</a></p>
    ru:
      title: Модули
      content_markdown: |
        Каждая программа или библиотека на Rust это **crate**.

        Каждый crate сделан из иерархии *модулей*.

        Программы начинают работать в корневом(root) модуле крейта(crate) в `main()` функции с файла "main.rs".

        Библиотеки имеют корневой модуль в файле "lib.rs" и  экспортируют полезные элементы.

        Для того, чтобы не писать полные пути, например `std::f64::consts::PI`,
        существует ключевое слово *use*. Оно позволяет нам указать отдельные элементы
        с модулей, которые мы хотим использовать в коде без указания полного пути. Например,
        `use std::f64::consts::PI` позволяет просто использовать идентификатор `PI` 
        в главной функции.

        **std** это крейт **стандартной библиотеки** Rust(a), который полон полезных структур данных
        и функций для взаимодействия с операционной системой.

        Регистр крейтов, созданный сообществом, находится на [https://crates.io](https://crates.io/)
    es:
      title: Módulos
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%C2%A1Bienvenido%20al%20%C3%A1rea%20de%20pruebas!%22)%3B%0A%20%20%20%20println!(%22%C2%A1Quiero%20un%20trozo%20de%20%7B%7Dzza!%22%2C%20PI)%3B%0A%7D%0A
      content_html: >
        <p>Cada programa o librería en Rust es un <b>crate</b>.</p><p>Cada crate
        está compuesto por una jerarquía de <b>módulos</b>.</p><p>Los programas comienzan su ejecución en el
        módulo raíz de un crate en la función <code>main()</code> en un fichero llamado
        `main.rs`.<p></p><p>Las librerías tienen un módulo raíz en el archivo `lib.rs` que
        proporciona elementos útiles.</p><p>Para evitar escribir rutas completas como <code>std::f64::consts::PI</code>.
        La palabra reservada <b>use</b> nos permite especificar qué elementos de los módulos queremos
        usar en nuestro código sin especificar una ruta completa. Por ejemplo, el uso de <code>use std::f64::consts::PI</code>
        me permite referenciar el valor de <code>PI</code> en mi función principal.</p><p><b>std</b>
        es el crate de la <b>librería estándar</b> de Rust que contiene estructuras de datos
        y funciones útiles para interactuar con tu sistema operativo.</p><p>Aquí encontrarás
        un repositorio de crates creado por la comunidad Rust: <a href="https://crates.io/">https://crates.io</a></p>
  - beta: true
    en:
      title: Exporting
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=pub%20fn%20everyone_can_use_this_function()%20%7B%0A%20%20%20%20println!(%22do%20something%22)%0A%7D%0A
      content_markdown: |
        By default members of a module are not accessible from outside of the module. We make members 
        of a module accessible using the `pub` keyword.

        By default members of a crate are not accessible outside of the crate. We make members of
        a crate accessible by marking them as `pub` in the *root module* of your crate (`lib.rs` or `main.rs`).

        We will talk more about modules later, for now, just know that `pub` gives you control
        of the visibility of your functions and data structures.
    de:
      title: Export
      content_markdown: |
        Die Inhalte eines Moduls sind außerhalb des Moduls nicht automatisch zugänglich.
        Stattdessen müssen die Teile, die im Modul erreichbar sein sollen, durch das `pub` Schlüsselwort *exportiert* werden.

        Die Inhalte einer Kiste (crate) sind ebenfalls außerhalb des Crates nicht automatisch zugänglich.
        Die zu exportierenden Teile werden im *root Modul* (`lib.rs` oder `main.rs`) durch das `pub` Schlüsselwort exportiert.

        Mehr dazu später, für jetzt reicht es zu wissen, dass durch `pub` die Sichtbarkeit
        von Funktionen und Attributen gesteuert werden kann.
    ie:
      title: Exportation
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=mod%20mi_sub_module%20%7B%0A%20%20fn%20far_alquo()%20%7B%0A%20%20%20%20println!(%22fant%20alquo%22)%0A%20%20%7D%0A%0A%20%20pub%20fn%20far_alquo_in_plu()%20%7B%0A%20%20%20%20println!(%22fant%20alquo%20in%20plu%22)%0A%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20mi_sub_module%3A%3Afar_alquo()%3B%0A%20%20mi_sub_module%3A%3Afar_alquo_in_plu()%3B%0A%7D%0A
      content_html:
        "<p>In Rust, noi exporta membres de un module usante li clave-parol
        <b>pub</b>.</p><p>Quande on usa un module, sive in su propri code sive in un crate
        extern, on posse solmen aluder a membres possedent li marcation public.</p><p>Li
        code in ti-ci exemple es ruptet; ples adjunter li clave-parol <b>pub</b> in li
        loc necessi por reparar it.</p>"
    ru:
      title: Экспорт
      content_markdown: |
        По умолчанию элементы модуля недоступны вне этого модуля. Их можно сделать "видимыми" или 
        доступными, используя ключевое слово `pub`.

        Также элементы крейта(crate) недоступны по умолчанию вне этого крейта. Но их можно 
        сделать доступными ключевым словом `pub` в **корневом модуле** крейта (`lib.rs` или `main.rs`).

        Мы поговорим о модулях в деталях позже, сейчас знайте, что `pub` контролирует видимость
        функций или структур данных.
    es:
      title: Exportar
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=mod%20mi_sub_modulo%20%7B%0A%20%20%20%20fn%20haz_algo()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22haciendo%20algo%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20haz_algo_mas()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22haciendo%20algo%20m%C3%A1s%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20mi_sub_modulo%3A%3Ahaz_algo()%3B%0A%20%20%20%20mi_sub_modulo%3A%3Ahaz_algo_mas()%3B%0A%7D%0A
      content_html:
        "<p>En Rust, exportamos elementos de un módulo usando la palabra reservada <b>pub</b>.</p><p>Cuando
        se utiliza un módulo dentro de su propio código o en un crate externo, sólo se
        permiten referencias a aquellos elementos que hayan sido marcados como públicos.</p><p>El código en este ejemplo
        da error, añade la palabra reservada <b>pub</b> en el lugar apropiado para arreglarlo.</p>"
  - beta: true
    en:
      title: Structure Visibility
      content_markdown: |
        Just like functions structures can declare what they want exposed outside of their module using `pub`.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20SeaCreature%20struct%20will%20be%20usable%20outside%20of%20our%20module%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20let's%20keep%20our%20weapon%20private%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
    de:
      title: Struktursichtbarkeit
      content_markdown: |
        Genau wie bei Funktionen kann in Strukturen angegeben werden, welche Felder nach außen hin sichtbar sein sollen.
        Diese sind wieder mit dem Schlüsselwort `pub` versehen.
    ie:
      title: Visibilitá de Structuras
      content_markdown: |
        Just quam functiones, structuras posse usar `pub` por declarar to quo ili desira esser exposit éxter su modul.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Li%20struct%20CreaturaMarin%20va%20esser%20usabil%20%C3%A9xter%20nor%20modul%0Apub%20struct%20CreaturaMarin%20%7B%0A%20%20%20%20%2F%2F%20String%20es%20un%20struct%0A%20%20%20%20pub%20tip_de_animale%3A%20String%2C%0A%20%20%20%20pub%20nomine%3A%20String%2C%0A%20%20%20%20pub%20brasses%3A%20i32%2C%0A%20%20%20%20pub%20jambes%3A%20i32%2C%0A%20%20%20%20%2F%2F%20ma%20noi%20vole%20que%20li%20arme%20mey%20esser%20privat%0A%20%20%20%20arme%3A%20String%2C%0A%7D
    ru:
      title: Область видимости структур
      content_markdown: |
        Структуры могут объявлять поля ключевым словом `pub`, открывая к ним доступ для внешних модулей.
  - chapter: 10
    en:
      title: The End
      content_markdown: |
        That's all for now. Stay tuned for new content. I hope you enjoy the journey ahead!
    es:
      title: Fin
      content_markdown: |
        Esto es todo por ahora, pero aún quedan más capítulos, así que ¡muy atento! Esperamos que disfrutes del viaje.
