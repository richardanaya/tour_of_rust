---
common_words:
  en:
    chapter: Chapter
    tor: Tour of Rust
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
    welcometothe: "Welcome to the"
    presstocontinue: "Press to Continue"
  fr:
    chapter: Chapitre
    tor: Tour de Rust
    next: Suivant
    previous: Précédent
    toc: Table des matières
    lessons: Leçons
    untranslated: Non traduit
    welcometothe: "Bienvenue au"
    presstocontinue: "Clique pour continuer"
  de:
    tor: Tour zu Rust
    next: Weiter
    previous: Zurück
    toc: Inhaltsverzeichnis
    lessons: Kapitel
    chapter: Kapitel
    untranslated: Noch nicht übersetzt
  ie:
    tor: Tur de Rust
    next: Sequent
    previous: Precedent
    toc: Tabelle de contenete
    lessons: Lectiones
    chapter: Capitul
    untranslated: Untranslated
  ru:
    chapter: Глава
    tor: Тур по Rust
    next: Далее
    previous: Назад
    toc: Содержание
    lessons: Занятия
    untranslated: Не переведено
  es:
    chapter: Capítulo
    tor: Tour de Rust
    next: Siguiente
    previous: Anterior
    toc: Tabla de Contenidos
    lessons: Unidades
    untranslated: Untranslated
    welcometothe: "Bienvenido al"
    presstocontinue: "Haz clic para continuar"
  pt-br:
    chapter: Capítulo
    tor: Um tour por Rust
    next: Próximo
    previous: Anterior
    toc: Índice
    lessons: Unidades
    untranslated: Untranslated
  zh-cn:
    chapter: 章
    tor: Rust 语言之旅
    next: 下一页
    previous: 上一页
    toc: 目录
    lessons: 课程
    untranslated: 未翻译
  ja:
    chapter: 章
    tor: Rust ツアー
    next: 次
    previous: 前
    toc: 目次
    lessons: レッスン
    untranslated: 未翻訳
pages:
  - en:
      title: "Hello, <img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Welcome to the *Tour of Rust*. This is meant to be a step by
        step guide through the features of the Rust programming language.  Rust is often
        considered a language with a steep learning curve, I hope I can convince you there's
        a lot to explore before we even get to complex parts.</p><p>You can find this
        guide in these languages:

        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Français](00_fr.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)

        If you have suggestions on content
        or would like to contribute to translations, checkout out Tour of Rust's 
        [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with keyboard <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>

        In this classic example we show Rust's support for unicode
        strings.
    fr:
      title: "Bonjour, <img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Bonjour%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Bienvenue au *Tour de Rust*. Celui-ci a pour but de te guider pas à
        pas au travers des fonctionnalités du language de programmation Rust. Rust est souvent
        considéré comme difficile et il y a beaucoup à explorer avant d'aborder
        les choses complexes.

        Tu peux trouver ce guide dans les languages suivants:

        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Français](00_fr.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)

        Si tu as des suggestions sur le contenu
        ou si tu souhaites contribuer aux traductions, rends-toi sur le
        [dépôt github](https://github.com/richardanaya/tour_of_rust).

        Tu peux naviguer au fil du site avec <span class="emoji">⬅️</span> et <span class="emoji">➡️</span>

        Dans cet exemple classique nous te montrons le support des caractères unicode par Rust.
    de:
      title: "Hallo, <img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Hallo%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Willkommen auf der *Tour zu Rust*. Hier werden die Features
        aus der Programmiersprache Rust Schritt für Schritt eingeführt. Rust wird oft
        mit einer steilen Lernkurve in Verbindung gebracht - allerdings gibt es schon
        zu Beginn viele spannende Besonderheiten zu entdecken, die hoffentlich dein Interesse
        wecken werden!

        In diesem klassischen Beispiel sehen wir Rust's Unterstützung
        von Unicode Strings.

        Du kannst mittels der rechten <span class="emoji">➡️</span> und linken <span class="emoji">⬅️</span> Pfeiltaste durch die Tour navigieren.

        Wenn du dieses Projekt mit Übersetzungen
        (wie diese hier) oder anderweitig unterstützen willst, wirf einen Blick auf die
        [Github Repository](https://github.com/richardanaya/tour_of_rust).

        Translations:
        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)
    ie:
      title: "Salute, <img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20println!(%22Salute%2C%20%F0%9F%A6%80%22)%3B%0A%7D
      content_html:
        <p>Benevenit al <b>Tur de Rust</b>. Li tur intente esser un guide explicat
        passu a passu al caracteristicas trovat in li lingue de programmation Rust. On
        considera Rust un lingue complex con un scarp curve de aprension, ma yo espera
        convicter te que hay multcos a explorar e aprender ante que veni li complexitá.</p>
        <p>In ti-ci exemple on vide li exemple classic de programmation quel monstra li
        subtention de strings (catenes) unicode in Rust.</p><p>Translations:<ul><li><a
        href="00_de.html">Deutsch</a></li><li><a href="00_en.html">English</a></li><li><a href="00_es.html">Español</a></li><li><a
        href="00_ie.html">Interlingue</a></li><li><a href="00_ru.html">Русский</a></li><li><a href="00_zh-cn.html">简体中文</a></li><li><a
        href="00_ja.html">日本語</a></li></ul></p>
        <p>Si tu have suggestiones pri contenete o vole contribuer un traduction, ples visitar
        li <a href="https://github.com/richardanaya/tour_of_rust">repositoria github</a>
        del Tur de Rust.</p>
    ru:
      title: "Привет, <img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      content_markdown: |
        Добро пожаловать в **Тур по Rust**. Это пошаговое руководство
        по возможностям языка программирования Rust. Rust часто ассоциируется как язык,
        который сложен в обучении, я надеюсь, что смогу объяснить многое до того,  как
        мы перейдём к более сложным частям.

        Тур доступен на таких языках:
        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Français](00_fr.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)

        Если у вас есть предложения по содержимому или вы бы хотели помочь с переводом, проверьте
        Тур по Rust [github репозиторий](https://github.com/richardanaya/tour_of_rust).

        В этом классическом примере мы показываем поддержку юникод строк в Rust.
    es:
      title: "Hola, <img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Hola%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Bienvenido al *Tour de Rust*. Esta es una guía paso a
        paso de las características del lenguaje de programación Rust. Rust está considerado
        como un lenguaje con una elevada curva de aprendizaje, por lo que hay mucho que explorar
        antes de llegar a las partes complejas.</p><p>Puedes encontrar esta
        guía en los siguientes idiomas:

        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Français](00_fr.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)

        Si tienes alguna sugerencia sobre el contenido
        o quieres contribuir a las traducciones, puedes encontrar el repositorio del 
        Tour de Rust en [github](https://github.com/richardanaya/tour_of_rust).

        Puedes navegar por el curso usando <span class="emoji">⬅️</span> y <span class="emoji">➡️</span>

        En este clásico ejemplo te mostramos el uso de cadenas unicode con Rust.
    pt-br:
      title: "Olá, <img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Ol%C3%A1%2C%20%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        Bem-vindo ao *Tour por Rust*. Este é um guia passo-a-passo pelas características da
        linguagem de programação Rust. Como ela é considerada uma linguagem com uma curva de 
        aprendizado elevada espero convencê-lo que há muito a explorar antes de chegar 
        às partes complexas.

        Você pode ver este guia nestes idiomas:

        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Français](00_fr.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)

        Caso tenha alguma sugestão a respeito do conteúdo ou queira contribuir com as
        traduções, veja o repositório do Tour por Rust no 
        [github](https://github.com/richardanaya/tour_of_rust).

        Você pode navegar pelo curso usando <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>

        Neste exemplo clássico mostramos o suporte de strings Unicode em Rust.
    zh-cn:
      title: "你好，<img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22%E4%BD%A0%E5%A5%BD%EF%BC%8C%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        欢迎来到 *Rust 语言之旅*。本教程旨在逐步介绍 Rust 编程语言的特性。Rust 通常被认为是一门学习曲线陡峭的语言，
        我希望能说服你，在我们开始学习复杂的部分之前，还有很多东西需要探索。

        你可以通过以下这些语言来阅读本教程：

        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Français](00_fr.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)

        如果你对内容有任何建议，或者想参与翻译做出贡献，请查看 Rust 语言之旅的 [github 代码库](https://github.com/richardanaya/tour_of_rust)。

        你可以使用 <span class="emoji">⬅️</span> 和 <span class="emoji">➡️</span> 浏览整个教程。

        在这个经典的例子中，我们展示了 Rust 对 Unicode 字符串的支持。
    ja:
      title: "こんにちは、<img src=\"/favicon-32x32.png\" style=\"display:inline; vertical-align:bottom\">"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22%E3%81%93%E3%82%93%E3%81%AB%E3%81%A1%E3%81%AF%E3%80%81%F0%9F%A6%80%22)%3B%0A%7D%0A
      content_markdown: |
        *Rust ツアー*へようこそ。
        これはプログラミング言語 Rust の機能を段階的にガイドすることを目的としています。
        Rust は学習曲線が急な言語だと見なされることが多いですが、
        複雑な事項に進む前に探ることがたくさんあると納得していただければと思います。

        このガイドは以下の言語で見ることができます。

        * [Deutsch](00_de.html)
        * [English](00_en.html)
        * [Español](00_es.html)
        * [Français](00_fr.html)
        * [Interlingue](00_ie.html)
        * [Português Brasileiro](00_pt-br.html)
        * [Русский](00_ru.html)
        * [简体中文](00_zh-cn.html)
        * [日本語](00_ja.html)

        コンテンツへの提案や翻訳に貢献したい場合、
        Rust ツアーの [github リポジトリ](https://github.com/richardanaya/tour_of_rust)をチェックしてください。

        キーボードの <span class="emoji">⬅️</span> と <span class="emoji">➡️</span> でツアーをナビゲートできます。

        この古典的な例では、Rust が Unicode 文字列をサポートしていることを示します。
  - chapter: 1
    en:
      title: Chapter 1 - The Basics
      content_markdown: |
        In this first chapter we're going to be exploring the very basics
        with functions, variables, and the most primitive types. Glad to have you on board!

        Also! In case you are wondering who this adorable crab is speaking to you, I am **Ferris**,
        the unofficial mascot for the Rust programming language. Nice to meet you.
    fr:
      title: Chapitre 1 - Les fondamentaux
      content_markdown: |
        Dans ce premier chapitre, nous allons explorer les fondamentaux
        avec les fonctions, les variables et les types primitifs. Bienvenue à bord!

        Et si tu te demandes qui est cet adorable crabe qui te parle, sache que je m'appelle **Ferris**,
        la mascotte non officielle du language de programmation Rust. Heureux de te renconter!
    de:
      title: Kapitel 1 - Die Basics
      content_html:
        "<p>Im ersten Kapitel werden grundlegende Eigenschaften von Funktionen,
        Variablen und (fast) allen primitiven Datentypen präsentiert. Willkommen an Board!</p><p>Ach
        ja! Falls du dich fragst, wer diese süße sprechende Krabbe ist, das ist <b>Ferris</b>,
        das inoffizielle Maskottchen der Programmiersprache Rust. Sag hallo!</p>"
    ie:
      title: Capitul 1 - Coses Simplic
      content_html:
        "<p>Ci in li unesim capitul, noi va explorar li max simplic coses in
        li lingue, includente functiones, variabiles, e li tipes max primitiv. Felici
        a haver te con noi!</p><p>Hay alquo in plu! Un brevi introduction por li casu
        in quel tu questiona te qui es ti-ci amabil crabe quel parla te: yo nomina me
        <b>Ferris</b>, li mascote ínoficial por li lingue de programmation Rust. Felici
        a incontrar te.</p>"
    ru:
      title: Глава 1 - Основы
      content_markdown: |
        В первой главе мы узнаем основы функций, переменных и примитивных
        типов. Рад видеть вас на борту!

        Также! Если вам интересно, кто этот восхитительный краб, говорящий с вами,
        Я **Феррис** - неофициальный маскот языка программирования Rust. 
        Приятно познакомиться.
    es:
      title: Capítulo 1 - Lo Básico
      content_html:
        "<p>En este primer capítulo vamos a ver lo más básico respecto a funciones, variables y los tipos de datos primitivos.
        ¡Bienvenido a bordo!</p><p>Y por si te estas preguntando quién es el adorable cangrejo parlante, me llamo <b>Ferris</b>,
        y soy la mascota no oficial del lenguaje de programación Rust. Encantado de conocerte.</p>"
    pt-br:
      title: Capítulo 1 - O Básico
      content_markdown: |
        Neste primeiro capítulo iremos explorar o mais básico sobre funções, variáveis e os
        tipos de dados mais primitivos. Bem-vindo a bordo!

        E se por acaso você está se perguntando quem é este adorável caranguejo falante, eu me 
        chamo **Ferris** e sou o mascote não oficial da linguagem de programação Rust.
        Prazer em conhecê-lo.
    zh-cn:
      title: 第一章 - 基础知识
      content_markdown: |
        在第一章中，我们将探讨函数、变量和最基本的类型等基本知识。欢迎入坑！

        并且~ 以防你好奇这个跟你说话的螃蟹是谁，我是 **Ferris**，一个非官方的 Rust 语言的吉祥物。
        很高兴认识你！
    ja:
      title: 第 1 章 - 基礎
      content_markdown: |
        最初の章では、関数、変数、プリミティブ型などの基本的なことを探っていきます。皆さんのご参加をお待ちしております。

        また、あなたに話し掛けているこの愛らしいカニが誰なのか気になるかもしれません。私は Rust プログラミング言語の非公式マスコット **Ferris** です。はじめまして。
  - en:
      title: The Rust Playground
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%20You%20can%20modify%20the%20code%20in%20here.%22)%3B%0A%7D%0A
      content_markdown: |
        This tour uses an interactive coding tool from [Rust Playground](https://play.rust-lang.org)

        It's a great way to play around with Rust and show others your creativity and challenges!
    fr:
      title: Le terrain de jeu de Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Bienvenue%20au%20terrain%20de%20jeu%20Rust!%20Tu%20peux%20modifer%20le%20code%20ici.%22)%3B%0A%7D%0A
      content_markdown: |
        Ce tour utilise l'outil de code interactif [Rust Playground](https://play.rust-lang.org)

        C'est un excellent moyen d'expérimenter avec Rust et de montrer aux autres ta créativité et tes challenges!
    de:
      title: The Rust Playground
      content_html:
        <p>Diese Tour macht sich das interaktive Coding Tool von <a href="https://play.rust-lang.org/">https://play.rust-lang.org</a>
        zu Nutze.</p><p>Beispiele in Rust lassen sich so spielend leicht testen. Hierbei
        sind deiner Kreativität auch keine Grenzen gesetzt. Ändere Codeschnipsel, teste
        Funktionen, lass deiner Fantasie freien Lauf!</p>
    ie:
      title: Li Lud-terren Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20println!(%22Benevenit%20al%20lude-terren!%20Tu%20posse%20modificar%20li%20code%20ci.%22)%3B%0A%7D
      content_html:
        <p>Ti-ci tur usa un instrument interactiv por codar quel trova se a
        <a href="https://play.rust-lang.org/">https://play.rust-lang.org</a></p><p>It
        es un bonissim metode por luder con Rust e monstrar li altres tui creativitá e
        defís!</p>
    ru:
      title: The Rust Playground
      content_markdown: |
        Этот тур использует интерактивный компилятор [Rust playground](https://play.rust-lang.org/)

        Это хороший способ попробовать Rust, показать другим вашу креативность и сложные задачи!
    es:
      title: Familiarízate con Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22%C2%A1Bienvenido%20al%20%C3%A1rea%20de%20pruebas!%20Puedes%20modificar%20tu%20c%C3%B3digo%20aqu%C3%AD.%22)%3B%0A%7D%0A
      content_html: |
        <p>En el tour usaremos la siguiente herramienta de programación interactiva: <a href="https://play.rust-lang.org/">https://play.rust-lang.org</a>
        </p><p>De esta manera podrás trastear con Rust y demostrar tu creatividad y aptitudes.</p>
    pt-br:
      title: O Playgroung do Rust
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Bem-vindo%20%C3%A0%20%C3%A1rea%20de%20testes!%20Voc%C3%AA%20pode%20modificar%20seu%20c%C3%B3digo%20aqui.%22)%3B%0A%7D%0A
      content_markdown: |
        Este tour usa a ferramenta de codificação interativa [Rust Playground](https://play.rust-lang.org)

        É uma boa maneira de brincar com Rust e mostrar aos outros a sua criatividade e desafios!
    zh-cn:
      title: Rust 练习场
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E7%BB%83%E4%B9%A0%E5%9C%BA%EF%BC%81%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E8%BF%99%E5%84%BF%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%22)%3B%0A%7D%0A
      content_markdown: |
        本教程使用一个来自 [Rust 练习场](https://play.rust-lang.org) 的交互代码工具。

        这是一个玩转 Rust 并且向别人展示你的创造力和挑战性的好方法。
    ja:
      title: Rust Playground
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Playground%20%E3%81%B8%E3%82%88%E3%81%86%E3%81%93%E3%81%9D%E3%80%82%E3%81%93%E3%81%93%E3%81%A7%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E4%BF%AE%E6%AD%A3%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%22)%3B%0A%7D%0A
      content_markdown: |
        このツアーでは、[Rust Playground](https://play.rust-lang.org) のインタラクティブなコーディングツールを使用します。

        Rust で遊んで、あなたの創造性と挑戦を他の人に見せるのに最適な方法です。
  - en:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20infers%20the%20type%20of%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20be%20explicit%20about%20the%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20can%20also%20declare%20and%20initialize%20later%2C%20but%20this%20is%20rarely%20done%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Variables are declared using the **let** keyword.

        When assigning a value, Rust will be able to infer the type of your variable 99% of
        the time. If it cannot you may add the type to your variable declaration.

        Notice how we can assign to the same variable name multiple times. This is called variable
        shadowing and the type can be changed for subsequent references to that name.

        Variable names are always in `snake_case`
    fr:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20inf%C3%A8re%20le%20type%20de%20la%20variable%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20on%20peut%20%C3%A9galement%20sp%C3%A9cifier%20explicitement%20le%20type%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20on%20peut%20aussi%20d%C3%A9clarer%20une%20variable%20et%20l%27initialiser%20plus%20tard%2C%20%0A%20%20%20%20%2F%2F%20bien%20qu%27ici%20il%20n%27y%20ait%20pas%20d%27int%C3%A9r%C3%AAt%20%C3%A0%20utiliser%20deux%20lignes%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Les variables sont déclarées en utilisant le mot clé **let**.

        Lorsqu'on assignera une valeur, Rust sera capable d'inférer le type de la variable (99% du
        temps). Si pour quelques raisons que ce soit cela n'est pas possible, on peut toujours ajouter le type
        à la déclaration de la variable.

        Remarque comment on peut déclarer la même variable plusieurs fois. Ceci est appelé **shadowing**
        et le type peut être modifié pour les prochaines références à ce nom de variable.

        Les nom de variables sont toujours en `snake_case`
    de:
      title: Variablen
      content_html: <p>Variablen werden mit dem Schlüsselwort <code>let</code>
        deklariert.</p><p>Im Regelfall sollte man Rust die Entscheidung überlassen, um
        welchen Datentypen es sich handelt. In Sonderfällen kann der Typ explizit angegeben
        werden.</p><p>Huch, was ist denn bei dem Beispiel los? Die Variable <code>x</code>
        wird mehrmals deklariert?</p><p>Das ist kein Fehler - Rust erlaubt sogenanntes
        <b>variable shadowing</b> (Variable überschatten). Bei Neudeklaration "verfällt"
        die vorige Deklaration und wir können mit der Variable arbeiten, als ob es sie
        davor noch nie gegeben hätte. Der Datentyp darf sich dabei auch ändern.</p><p>Variablennamen
        werden ebenfalls in <code>snake_case</code> geschrieben.</p>
    ie:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%2F%2F%20rust%20infere%20li%20tip%20de%20x%0A%20%20let%20x%20%3D%2013%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%0A%20%20%2F%2F%20rust%20posse%20anc%20specificar%20li%20tip%20explicitmen%0A%20%20let%20x%3Af64%20%3D%203.14159%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%0A%20%20%2F%2F%20rust%20posse%20anc%20declarar%20in%20prim%2C%20poy%20inicialisar%2C%20ma%20ti-ci%20metode%0A%20%20%2F%2F%20es%20rarmen%20usat%0A%20%20let%20x%3B%0A%20%20x%20%3D%200%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%7D
      content_html:
        ' <p>On declara variabiles con li clave-parol <b>let</b>.</p><p>Quande
        on assigna un valore, Rust va posser inferer li tip del variabile con un certitá
        de 99%. Si it ne posse, tu posse adjunter li tip al declaration por li variabile.</p><p>A
        notar es qualmen noi posse assignar li sam nómine por un variabile plu quam un
        vez. Ti-ci metode es nominat variable shadowing ("variabil-ombration") in quel
        li tip va posser changear se por referenties sequent por ti nómine.</b></p><p>Nómines
        por variabiles sempre usa <code>snake_case</code> (minuscules con infra-strecs)</p>'
    ru:
      title: Переменные
      content_markdown: |
        Переменные объявляются с помощью ключевого слова **let**.

        Когда ей присваивается значение, Rust в состоянии вывести тип переменной в 99% случаях.
        Если вывод невозможен, вы можете добавить тип в объявлении переменной.

        Заметьте, как мы можем присвоить значение одной и той же переменной несколько раз. Это называется
        сокрытие переменной (variable shadowing), её тип может быть изменен в последующих
        присваиваниях.

        Название переменных всегда `snake_case`
    es:
      title: Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Rust%20deduce%20el%20tipo%20de%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tambi%C3%A9n%20puede%20ser%20expl%C3%ADcito%20con%20el%20tipo%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tambi%C3%A9n%20puede%20declarar%20primero%20e%20inicializar%20despu%C3%A9s%2C%20pero%20es%20poco%20com%C3%BAn%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Las variables se declaran usando la palabra reservada **let**.

        Al asignar un valor, Rust podrá deducir el tipo de la variable el 99% de las veces.
        Si no puede, tú mismo podrás especificar el tipo al declarar una variable.

        Fíjate en cómo podemos declarar variables con el mismo nombre varias veces. Esto se llama
        sombreado (shadowing) de variables y se puede modificar el tipo para futuras referencias a ese nombre.

        Los nombres de las variables se escriben siempre en `snake_case`
    pt-br:
      title: Variáveis
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Rust%20infere%20o%20tipo%20de%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tamb%C3%A9m%20pode%20ser%20expl%C3%ADcito%20com%20o%20tipo%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20Rust%20tamb%C3%A9m%20pode%20declarar%20primero%20e%20inicializar%20depois%2C%20mas%20%C3%A9%20incomum%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Variáveis são declaradas usando a palavra-chave **let**.

        Quando atribuimos um valor, o Rust poderá inferir o tipo da sua variável em 99% dos casos.
        Se não for possível, você poderá especificar o tipo ao declarar a variável.

        Veja que podemos atribuir valores à mesma variável várias vezes. Isto é chamado
        *sobreamento* de variáveis (shadowing) e podemos mudar o seu tipo para referências
        futuras a esse nome.

        Os nomes das variáveis são sempre em `snake_case`.
    zh-cn:
      title: 变量
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20%E6%8E%A8%E6%96%AD%E5%87%BAx%E7%9A%84%E7%B1%BB%E5%9E%8B%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20%E4%B9%9F%E6%94%AF%E6%8C%81%E5%85%88%E5%A3%B0%E6%98%8E%E5%90%8E%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%BD%86%E5%BE%88%E5%B0%91%E8%BF%99%E6%A0%B7%E5%81%9A%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        变量使用 **let** 关键字来声明。

        在赋值时，Rust 能够在 99% 的情况下推断变量类型。如果不能，你可以将类型添加到变量声明中。

        注意，我们如何多次分配相同的变量名。这被称为变量隐藏，可以更改变量类型以实现对该变量名的后续使用。

        变量名总是遵循 `蛇形命名法` (snake_case)。
    ja:
      title: 変数
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20x%20%E3%81%AE%E5%9E%8B%E3%82%92%E6%8E%A8%E8%AB%96%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20x%20%E3%81%AE%E5%9E%8B%E3%82%92%E6%8C%87%E5%AE%9A%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20%E5%AE%A3%E8%A8%80%E3%81%AE%E5%BE%8C%E3%81%A7%E5%88%9D%E6%9C%9F%E5%8C%96%EF%BC%88%E3%81%82%E3%81%BE%E3%82%8A%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%BE%E3%81%9B%E3%82%93%EF%BC%89%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        変数は **let** キーワードを使用して宣言します。

        値を割り当てる際、Rust は 99% のケースで変数の型を推論できます。それができない場合、変数宣言に型を追加できます。

        同じ変数名に複数回割り当てできることに注目してください。
        これは変数のシャドウイングと呼ばれるもので、型を変更して後でその名前で参照できます。

        変数名にはスネークケース `snake_case` を使用します。
  - en:
      title: Changing Variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Rust cares a great deal about what variables are modifiable. Values
        fall into two types:

        * **mutable** - the compiler will allow the variable to be written to and read from.
        * **immutable** - the compiler will only allow the variable to be read from.

        Mutable values are denoted with a **mut** keyword.

        We will have more to say on this concept later, but for now just keep an eye out for this keyword.
    fr:
      title: Modification des variables
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Rust prend très au sérieux le fait de savoir si une variable est modifiable ou non.
        Les variables peuvent être de deux types:

        * **mutable** - la variable peut être modifiée et sa valeur lue
        * **immutable** - seule la valeur de la variable peut être lue

        Les variables modifiables sont préfixées du mot clé **mut**.

        Nous aurons plus à dire à ce sujet par la suite.
    de:
      title: Variablenwerte ändern
      content_markdown: |
        Rust sorgt sich sehr darum, welche Variablen verändert werden können
        und welche nicht. Daher gibt es die folgende Unterscheidung:

        * **mutable** - der Speicherort der Variable kann beschrieben und gelesen werden
        * **immutable** - der Compiler lässt nur das Lesen des Speicherortes zu

        Variablen, die verändert werden können, werden mit einem extra `mut`
        Schlüsselwort gekennzeichnet.

        Auf dieses Konzept wird im späteren Verlauf noch mehr eingegangen, für jetzt ist es wichtig
        zu wissen, dass "mutable" die Veränderbarkeit einer Variablen bestimmt.
    ie:
      title: Changear valores
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%20%20x%20%3D%2013%3B%0A%20%20println!(%22%7B%7D%22%2Cx)%3B%0A%7D
      content_html:
        " <p>Rust sucia se mult pri li valores queles es modificat. Valores
        possede du tipes:</p><ul><li><b>mutabil</b> - li loc in memorie posse esser inscrit
        e leet</li><li><b>ínmutabil</b> - li loc in memorie posse esser solmen leet</li></ul><p>On
        denota sempre li valores mutabil con li clave-parol <b>mut</b></p><p>Pri to noi
        va parlar plu con detallies, ma por li momente ples solmen atenter pri ti-ci parol-clave
        quel monstra que un cose es modificabil</p>"
    ru:
      title: Изменение переменных
      content_markdown: |
        Rust уделяет много внимания тому, какие значения могут быть изменены.
        Значения (переменные) делятся на два типа:

        * **mutable** - область памяти, в которую можно записать и считать
        * **immutable** - область памяти, с которой можно только считать

        Mutable значения всегда каким-то образом обозначены с помощью ключевого слова **mut**.

        Мы поговорим об этом позже, сейчас просто следите за этим ключевым словом и тем, какие элементы
        могут быть изменены.
    es:
      title: Modificar Variables
      content_markdown: |
        En Rust es importante tener en cuenta qué valores se modifican.
        Los valores se dividen en dos tipos:

        * **mutables** - la ubicación en memoria puede ser escrita y leída
        * **inmutables** - la ubicación en memoria sólo puede ser leída

        Los valores mutables siempre se denotan con la palabra reservada **mut**.

        Hay mucho más que explicar aún sobre este concepto, pero de momento presta atención solamente a la palabra reservada.
        We will have more to say on this concept later, but for now just keep an eye out for this keyword.
    pt-br:
      title: Modificando valores
      content_markdown: |
        Em Rust é importante levar em consideração quais valores serão alterados. Os valores
        se dividem em dois tipos:

        * **mutáveis** - o compilador permitirá que a variável seja lida e gravada.
        * **imutáveis** - o compilador permitirá apenas a leitura da variável.

        Valores mutáveis são marcados com a palavra-chave **mut**.

        Temos muito a explicar ainda sobre este conceito, mas por enquanto apenas preste atenção 
        nesta palavra-chave.
    zh-cn:
      title: 修改变量
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Rust 非常关心哪些变量是可修改的。值分为两种类型：

        * **可变的** - 编译器允许对变量进行写入和读取。
        * **不可变的** - 编译器只允许对变量进行读取。

        可变值用 **mut** 关键字表示。

        关于这个概念，我们以后还会有更多的内容，但是目前请注意这个关键字即可。
    ja:
      title: 変数の変更
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
      content_markdown: |
        Rustは変数の変更についてとても配慮しています。値は 2 種類に分類されます。

        * **可変** - コンパイラは変数の書き込みと読み込みを許可します。
        * **不変** - コンパイラは変数の読み込みだけを許可します。

        可変値は **mut** キーワードで表します。

        この概念については後で詳しく説明しますが、今のところはこのキーワードに注意してください。
  - en:
      title: Basic Types
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20by%20default%20this%20is%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20by%20default%20this%20is%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rust has a variety of familiar types:

        * booleans - `bool` for representing true/false
        * unsigned integers - `u8` `u32` `u64` `u128` for representing positive whole numbers
        * signed integers - `i8` `i32` `i64` `i128` for representing positive/negative whole numbers
        * pointer sized integers - `usize` `isize` for representing indexes
        and sizes of things in memory
        * floating point - `f32` `f64`
        * tuple - `(value, value, ...)` for passing fixed sequences of values on the stack
        * arrays - a collection of similar elements with fixed length known at compile time
        * slices - a collection of similar elements with length known at runtime
        * `str`(string slice) - text with a length known at runtime

        Text might be more complex than you are used to in other languages,
        since Rust is a system programming language, it cares about memory 
        issues you might not be used to. We will be going into this in detail later.

        Numeric types can be explicitly specified by appending the type to the end of the number (e.g. `13u32`, `2u8`)
    fr:
      title: Types primitifs
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20par%20d%C3%A9faut%20c%27est%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20par%20d%C3%A9faut%20c%27est%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rust possède une variété de types primitifs dont certains te seront certainement famillier:

        * booléens - `bool` pour représenter vrai/faux
        * entiers non signés - `u8` `u32` `u64` `u128` pour représenter les entiers positifs
        * entiers signés - `i8` `i32` `i64` `i128` pour représenter les entiers positifs et négatifs
        * entiers de taille de pointeur - `usize` `isize` pour représenter les indices
        et tailles des éléments en mémoire
        * nombre réel à virgule flottante - `f32` `f64` pour représenter notamment les nombres rationnels
        * tuple - `(valeur, valeur, ...)` pour passer une séquence finie de valeurs sur la pile
        * tableaux - `[valeur, valeur, ...]` une collection d'éléments de même type dont la taille est
        fixe (déterminée à la compilation)
        * slices - similaire aux tableaux à l'exception que la taille est redimensionable
        * chaîne de caractères - `str` pour représenter une suite de caractères

        Les chaînes de caractères peuvent être plus complexes comparées aux autres languages de programmation,
        étant donné que Rust est un language de programmation système, il est sensible aux problèmes
        de mémoire que tu n'es peu-être pas habitué à traiter. Nous reviendrons sur ce sujet un peu plus tard.

        Les types numériques peuvent être explicitement spécifiés en ajoutant le type après
        le nombre (ex. `13u32`, `2u8`)
    de:
      title: Basistypen
      content_html:
        "<p>Rust besitzt eine vielzahl an bekannten Datentypen <ul><li>booleans
        - <code>bool</code> für true/false bzw. wahr/falsch Werte</li><li>unsigned
        integers - <code>u8</code><code>u32</code><code>u64</code>
        für positive Ganzzahlen (inkl. 0 für die Mathematiker)</li><li>signed integers
        - <code>i8</code><code>i32</code><code>i64</code>
        für vorzeichenbehaftete Ganzzahlen</li><li>pointer sized integers - <code>uint</code><code>isize</code>
        für Indizes und Größen im Speicher</li><li>floating point - <code>f32</code><code>f64</code>
        für Dezimalzahlen</li><li>text zeug - <code>str</code><code>char</code></li><li>tuple
        - <code>(value,value,...)</code> zum Übergeben von Wertsequenzen auf
        dem Stack<li>slices - <code>&[T]</code> um Views in Sequenzen zu referenzieren
        (hier evt bessere Übersetzung finden)</ul></p><p>Wir sehen schon, dass es einiges
        zum Anpacken geben wird!</p><p>Eine Warnung vorweg: text-Zeug wird etwas komplexer
        sein als du es vielleicht von anderen Programmiersprachen gewohnt bist, da Rust
        eine Systemprogrammiersprache ist und daher mehr auf effektives Speichermanagement
        fokussiert. Keine Panik auf der Titanic aber, wir werden unser Bestes geben, dich
        darauf vorzubereiten!</p><p>Noch ein Hinweis: Numerische Datentypen können auch
        nach dem Zahlenliteral spezifiziert werden (z.B. <code>13u32</code>)</p>"
    ie:
      title: Basic tipes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%0A%20%20%20%20let%20c%20%3D%204.3f64%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20frase%20%3D%20%22salute%20munde!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20frase%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Rust possede un varietá de tipes familiari <ul><li>booleanes - <code>bool</code>
        por representar true/false (ver/fals)</li><li>unsigned integers (integrales ínsignat)
        - <code>u8</code><code>u32</code><code>u64</code><code>u128</code>
        por representar integrales positiv</li><li>signed integers (integrales signat)
        - <code>i8</code><code>i32</code><code>i64</code><code>i128</code>
        por representar integrales sive positiv sive negativ</li><li>pointer sized integers
        (integrales con puntator-mesurat grandore) - <code>usize</code><code>isize</code>
        por representar indexes e grandores de coses in memorie</li><li>floating point
        (punctu flottant) - <code>f32</code><code>f64</code></li><li>con
        relation a textu - <code>str</code><code>char</code></li><li>tuple
        - <code>(value, value,...)</code> por passar fixat sequenties de valore
        sur li stack (li cumul)<li>slices (tranches) - <code>&[T]</code> por
        referer visus ad-in sequenties de valores in memorie</ul></p><p>Noi va parlar
        pri alcunes ex ili plu detalliatmen plu tard.</p><p>Un avise in prim: textu va
        posser esser plu complicat quam tui experientie con altri lingues, pro que Rust
        es un lingue de programmation por sistemas quel orienta se pri problemas de memorie
        con quel fórsan tu ne ha experientie. Noi va parlar plu detalliatmen pri textu
        plu tard.</p><p>Nota qualmen on posse explicitmen specificar tipes numeric per
        afixar li tip directmen pos li numeró (p.e. <code>13u32</code>)</p>"
    ru:
      title: Базовые типы
      content_markdown: |
        Rust имеет много знакомых типов: 

        * булевые - `bool` представляет true/false
        * беззнаковые целочисленные - `u8`, `u32`, `u64`, `u128` представляют положительные числа
        * знаковые целочисленные - `i8`, `i32`, `i64`, `i128` представляют положительные/отрицательные числа 
        * целочисленные размером указателя - `usize`, `isize` представляют индексы и размеры
        * числа с плавающей точкой - `f32`, `f64`
        * относятся к тексту - `str`, `char`
        * кортежи - `(значение,значение,...)` представляют фиксированную последовательность
        значений, размещаются на стеке
        * слайсы (slices) - `&[T]` представляют указатель на последовательность значений в памяти

        Мы поговорим о нескольких из пунктов в деталях чуть позже.

        Справедливое предупреждение: текст может быть более сложным, чем вы привыкли на 
        других языках, поскольку Rust является языком системного программирования,
        он ориентирован на решение проблем, свясвязанных с памятью, с которыми вы,
        возможно, не сталкивались. Мы поговорим о текстовых данных позже.
         
        Заметьте, как числа могут быть приведены к определенному типу, если явно указать 
        тип в конце числа (пример `13u32`)
    es:
      title: Tipos básicos
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20Por%20defecto%20es%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20Por%20defecto%20es%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22%C2%A1Hola%2C%20mundo!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Rust tiene una variedad de tipos que puede que te resulten familiares: <ul><li>booleanos - <code>bool</code>
        para representar verdadero/falso</li><li>números enteros sin signo - <code>u8</code><code>u32</code><code>u64</code><code>u128</code>
        para representar números enteros positivos</li><li>números enteros con signo - <code>i8</code><code>i32</code><code>i64</code><code>i128</code>
        para representar números enteros positivos y negativos</li><li>números enteros de tamaño de puntero
        - <code>usize</code><code>isize</code> se usan para representar índices y tamaños de elementos en memoria
        </li><li>números en coma flotante - <code>f32</code><code>f64</code></li>
        <li>En relación a textos - <code>str</code><code>char</code></li><li>tuplas
        - <code>(valor,valor,...)</code> para pasar secuencias fijas de valores en la pila
        <li>slices - <code>&[T]</code> para referenciar “vistas” en
        secuencias de valores en la memoria</ul></p><p>Profundizaremos en algunos más adelante.</p>
        <p>Advertencia: los formatos de texto pueden ser más complejos de lo que estás acostumbrado
        en otros lenguajes, ya que Rust es un lenguaje de programación de sistemas, está orientado
        a gestionar los problemas de la memoria, algo a lo que puedes no estar acostumbrado.
        Entraremos en detalles sobre los textos más tarde.</p><p>Observa cómo los tipos numéricos pueden especificarse
        explícitamente añadiendo el tipo al final del número (por ejemplo, <code>13u32</code>)</p>"
    pt-br:
      title: Tipos básicos
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20infere%20o%20tipo%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20infere%20o%20tipo%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22Ol%C3%A1%2C%20mundo!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rust tem uma variedade tipos que lhe serão familiares:

        * booleanos - `bool` para representar verdadeiro/falso
        * números inteiros sem sinal - `u8` `u32` `u64` `u128` para representar números inteiros positivos
        * números inteiros com sinal - `i8` `i32` `i64` `i128` para representar números inteiros positivos e negativos
        * ponteiros de números inteiros - `usize` `isize` para representar índices e o comprimento de coleções em memória
        * números de ponto flutuante - `f32` `f64`
        * tuplas - `(value, value, ...)` para passar sequências de valores fixas para a pilha
        * matriz - uma coleção de elementos similares com comprimento fixo conhecidos em tempo de compilação
        * slices - uma coleção de elementos similares com comprimento conhecido em tempo de execução
        * `str` (string slice) - texto com comprimento conhecido em tempo de execução

        Textos podem ser mais complexos do que você está acostumado com outras linguagens. Uma vez que o Rust 
        é uma linguagem de programação de sistemas, ele cuida do gerenciamento de memória de uma maneira que
        pode não estar familiarizado. Entraremos em detalhes mais adiante.

        Tipos numéricos podem ser especificados explicitamente adicionando o tipo ao final do 
        número (por exemplo: `13u32`, `2u8`)
    zh-cn:
      title: 基本类型
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%BF%99%E6%98%AFi32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%BF%99%E6%98%AFf64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rust 有多种常见的类型：

        * 布尔型 - `bool` 表示 true 或 false
        * 无符号整型- `u8` `u32` `u64` `u128` 表示正整数
        * 有符号整型 - `i8` `i32` `i64` `i128` 表示正负整数
        * 指针大小的整数 - `usize` `isize` 表示内存中内容的索引和大小
        * 浮点数 - `f32` `f64`
        * 元组（tuple） - `(value, value, ...)` 用于在栈上传递固定序列的值
        * 数组 - 在编译时已知的具有固定长度的相同元素的集合
        * 切片（slice） - 在运行时已知长度的相同元素的集合
        * `str`(string slice) - 在运行时已知长度的文本

        文本可能比你在其他语言中学到的更复杂，因为 Rust 是一种系统编程语言，它关心的是你可能不太习惯的内存问题。
        我们稍后将详细讨论这个问题。

        可以通过将类型附加到数字的末尾来明确指定数字类型（如 `13u32`, `2u8`）
    ja:
      title: 基本的な型
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%81%A7%E3%81%AF%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%81%A7%E3%81%AF%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22hello%20world!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Rustにはよく知られた様々な型があります。

        * ブール型 - `bool` は true または false を表します
        * 符号なし整数型 - `u8` `u32` `u64` `u128` は正の整数を表します
        * 符号付き整数型 - `i8` `i32` `i64` `i128` は正と負の整数を表します
        * ポインタサイズ整数型 - `usize` `isize` はメモリ内のインデックスとサイズを表します
        * 浮動小数点数型 - `f32` `f64`
        * タプル型 - `(value, value, ...)` スタック上の固定された値の組を渡すために使用されます
        * 配列型 - コンパイル時に長さが決まる同じ要素のコレクション
        * スライス型 - 実行時に長さが決まる同じ要素のコレクション
        * `str`(string slice) - 実行時に長さが決まるテキスト

        Rust はシステムプログラミング言語であるため、他の言語よりも複雑かもしれません。あまり意識しなかったようなメモリの問題を扱います。
        これについては後ほど詳しく説明します。

        数値型は、数値の最後に型を付加することで明示的に指定できます。（例: `13u32`, `2u8`）
  - en:
      title: Basic Type Conversion
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
      content_markdown: |
        Rust requires explicitness when it comes to numeric types. One cannot
        use a `u8` for a `u32` casually without
        error.

        Luckily rust makes numeric type conversions very easy with the **as** keyword.
    fr:
      title: Conversion des types primitifs
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
      content_markdown: |
        Avec Rust, l'utilisation des types est stricte. On ne peut pas
        utiliser une variable de type `u8` et la faire passer pour une variable de type `u32`.

        Heureusement, Rust rend la conversion de type très facile grâce au mot clé **as**.
    de:
      title: Basistypen konvertieren
      content_html:
        "<p>Rust vordert explizite Konvertierungen, wenn es um Zahlentypen geht.
        Ein <code>u8</code> (8-bit unsigned integer) kann nicht mit einem <code>u32</code>
        locker aus dem Handgelenk zusammengerechnet werden ohne das Programm zum Absturz
        zu bringen.</p><p>Glücklicherweise ist auf die Konvertierung mit dem <code>as</code>
        Schlüsselwort Verlass.</p>"
    ie:
      title: Conversion de basic tipes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20let%20a%20%3D%2013u8%3B%0A%20%20let%20b%20%3D%207u32%3B%0A%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20let%20t%20%3D%20true%3B%0A%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D
      content_html:
        "<p>Rust exige explicitá quande it acte se pri tipes numeric. On ne
        posse usar un <code>u8</code> hasardalmen por un <code>u32</code>
        sin un erra.</p><p>Felicimen, conversiones de tipes numeric es facil in Rust con
        li clave-parol <b>as</b>.</p>"
    ru:
      title: Преобразование базовых типов
      content_markdown: |
        Rust требует явности, когда речь идет о числовых типах. Нельзя использовать
        `u8` вместо `u32` случайно, это ошибка.

        К счастью, Rust имеет ключевое слово **as**, которое позволяет очень легко преобразовывать
        типы.
    es:
      title: Conversión de tipos básica
      content_html:
        "<p>Rust requiere ser explícito cuando se trata de tipos numéricos. No se
        puede usar un <code>u8</code> cuando necesitemos un <code>u32</code> sin que se produzca
        un error.</p><p>Por suerte, Rust hace que las conversiones de tipos numéricos sean
        muy fáciles con la palabra reservada <b>as</b>.</p>"
    pt-br:
      title: Conversão de tipos básica
      content_markdown: |
        O Rust requer que sejamos explícitos quando se trata de tipos numéricos. Não podemos
        usar um `u8` quando precisamos usar um `u32` sem que se produza um erro.

        Por sorte o Rust faz com que as conversões de tipos numéricos sejam muito siples usando 
        a plavra-chave **as**.
    zh-cn:
      title: 基本类型转换
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
      content_markdown: |
        当涉及到数字类型时，Rust 要求明确。一个人不能把“u8”用在“u32”上而不出错。

        幸运的是，使用 **as** 关键字，rust 使数字类型转换非常容易。
    ja:
      title: 基本型の変換
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
      content_markdown: |
        Rust で数値型を扱う際、型を明示する必要があります。`u8` と `u32` を混ぜるとエラーになります。

        幸い、Rust は **as** キーワードで数値型を簡単に変換できます。
  - en:
      title: Constants
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Constants allow us to specify a common value that's used through
        out our code many times efficiently.  Instead of copying values like variables
        where they are used, constants directly replace the text identifier where they
        are used with their value at compile time.

        Unlike variables, constants must always have explicit types

        Constant names are always in `SCREAMING_SNAKE_CASE`
    fr:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%CF%80%20est%20le%20rapport%20de%20la%20circonf%C3%A9rence%20d%E2%80%99un%20cercle%20%C3%A0%0A%20%20%20%20%20%20%20%20son%20diam%C3%A8tre%20et%20sa%20valeur%20approximative%20est%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        Les constantes permettent de spécifier une valeur qui sera utilisée
        à plusieurs endroits du code et de manière efficiente. A la différence des variables, 
        rust remplace le nom des constantes par leur valeur lors de la compilation.

        Le type des constantes doit être explicitement déclaré, ce qui n'est pas le cas pour
        les variables.

        Les noms de constantes sont toujours de la forme `SCREAMING_SNAKE_CASE`.
    de:
      title: Konstanten
      content_html: "<p>Konstanten (<code>const</code>) erlauben uns einen Wert
        in der Kompilierzeit zu setzen, die in unserem Code eingesetzt werden. Kompilierzeit
        ist hier das Stichwort: anstelle von Variablen sitzen dann an Orten, an denen
        Konstanten eingestetzt werden, die Werte selbst.</p><p>Anders als bei Variablen
        muss bei Konstanten der Datentyp explizit angeben werden.</p><p>Die Namensgebung
        erfolgt generell in <code>SCREAMING_SNAKE_CASE</code>.</p>"
    ie:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Por%20crear%20un%20%7B%7D%20de%20pom%20desde%20li%20comense%2C%20on%20deve%20in%20prim%20crear%20un%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Constantes possibilisa li specification de valores comun quel noi
        usa tra nor code con un eficientie mult vezes plu grand.  Vice copiar valores
        quam variabiles chascun vez ú ili es usat, constantes remplazza li textu-identificator
        directmen con lor valore in li locs ú on usa les.</p><p>In contraste a variabiles,
        constantes deve sempre posseder un tip explicit</p><p>Nómines de constantes es
        sempre in <code>SCREAMING_SNAKE_CASE</code> (majuscules con infra-strecs)</p>"
    ru:
      title: Константы
      content_markdown: |
        Константы (**const**) позволяют нам указать неизменяемую переменную,
        которую можно использовать много раз. Вместо того, чтобы копировать значение,
        как делают переменные, имя константы заменяется на значение во время компиляции.

        В отличии от переменных, константам нужно явно обозначать их тип.

        Имена констант всегда пишутся в верхнем регистре `SCREAMING_SNAKE_CASE`
    es:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Vamos%20de%20paseo%2C%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20PI%2C%20PI%2C%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_html:
        "<p>Las constantes nos permiten especificar un valor común que se utiliza
        muchas veces a lo largo de nuestro código de manera eficiente. En vez de copiar valores
        como variables en el lugar donde se usan, las constantes reemplazan directamente el
        identificador de texto (donde se haya usado) por su valor en tiempo de compilación.</p>
        <p>A diferencia de las variables, el tipo de las constantes se debe especificar explícitamente.</p>
        <p>Los nombres de las constantes se escriben siempre en <code>SCREAMING_SNAKE_CASE</code></p>"
    pt-br:
      title: Constantes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Para%20fazer%20uma%20%7B%7Dzza%2C%20voc%C3%AA%20deve%20primeiro%20criar%20o%20Universo.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        As constantes nos permitem especificar um valor comum que pode ser usado
        muitas vezes por todos o nosso código de maneira eficiente. Ao invés de
        copiar os valores como variáveis onde serão utilizadas, as constantes substituirão
        o identificador de texto pelo seu valor onde quer que estejam sendo usadas em tempo
        de compilação.

        Diferentemente das variáveis, o tipo das constantes devem ter sempre declarados.

        Os nomes das constantes são sempre em `SCREAMING_SNAKE_CASE`.
    zh-cn:
      title: 常量
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22To%20make%20an%20apple%20%7B%7D%20from%20scratch%2C%20you%20must%20first%20create%20a%20universe.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        常量允许我们指定一个在代码中多次有效使用的公共值。常量在编译时直接用它们的值替换文本标识符，
        而不是复制变量之类的值。

        不同于变量，常量必须始终具有显式类型。

        常量名总是遵循 `全大写蛇形命名法（SCREAMING_SNAKE_CASE）`。
    ja:
      title: 定数
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%83%E3%83%81%E3%81%8B%E3%82%89%20%7B%7D%20%E3%81%AE%E3%83%AA%E3%83%B3%E3%82%B4%E3%82%92%E4%BD%9C%E3%82%8B%E3%81%AB%E3%81%AF%E3%80%81%E3%81%BE%E3%81%9A%E5%AE%87%E5%AE%99%E3%82%92%E5%89%B5%E9%80%A0%E3%81%99%E3%82%8B%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
      content_markdown: |
        定数を使用すると、コード全体で何度も使用される共通の値を効率的に指定できます。
        定数は、変数のように値が使われる場所でコピーするのではなく、コンパイル時に値が使われる場所の識別子を直接置き換えます。

        変数とは異なり、定数は明示的な型指定が必要です。

        定数名には大文字のスネークケース `SCREAMING_SNAKE_CASE` を使用します。
  - en:
      title: Arrays
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
      content_markdown: |
        An *array* is a fixed length collection of data elements all of the same type.

        The data type for an *array* is `[T;N]` where T is the elements' type, and N is the fixed length known at compile-time.

        Individual elements can be retrieved with `[x]` operator where *x* is a *usize* index (starting at 0) of the element you want.
    fr:
      title: Tableaux
      content_markdown: |
        Un *tableau* est une collection de taille fixe (celle-ci doit être
        connue à la compilation) contenant des éléments du même type.

        Le type d'un *tableau* est `[T;N]` où T est le type de l'élément
        et N est la taille du tableau.

        Chaque élément du tableau peut être récupéré avec la syntaxe `[x]` où *x* est
        l'index de type *usize* (commençant à 0) de l'élément à récupérer.
    de:
      title: Arrays
      content_markdown: |
        Need translation
    ie:
      title: Arrays
      content_markdown: |
        Un *array* (un arangeament o un tabló) es un colection de longore fixat con data-elementes con li sam tip.

        Li tip de data por un *array* es `[T;N]` ú T es li tip del elementes, e N es li longore fixat quel on save quande on compila.

        Singul elementes posse esser retrovat con li operator `[x]` ú *x* es un index de *usize* (comensant con 0) del element quel
        on desira accesser.
    ru:
      title: Массивы
      content_markdown: |
        *Массив* это коллекция с фиксированным количеством элементов и все одного типа.  

        Что бы создать *массив* нужно написать `[T; N]` где T - тип элементов и N - количество элементов в массиве,
        заранее известное перед компиляцией. 

        Получить доступ к элементам массива можно с помощью `[x]` где **x** индекс типа **usize** (начинается с 0).
    es:
      title: Arrays
      content_markdown: |
        Un *array* es una colección de longitud fija de elementos de datos del mismo tipo.

        El tipo de datos para un *array* es `[T;N]` siendo T el tipo del elemento, y N la longitud fija conocida en tiempo de compilación.

        Los elementos individuales se pueden recuperar con el operador `[x]`, siendo *x* un índice de tipo *usize* (empezando por 0) del elemento que quieras.
    pt-br:
      title: Matrizes
      content_markdown: |
        Uma *matriz* é uma coleção de elementos de tamanho fixo todos os seu valores do mesmo tipo.

        O tipo de dado para uma *matriz* é `[T;N]`, onde T é o tipo dos valores e
        N é o comprimento fixo conhecido em tempo de compilação.

        Os elementos podem ser recuperados individualmente com o operador `[x]`, onde *x* 
        é o índice do tipo *usize* (começando de 0) do elemento que deseja recuperar.
    zh-cn:
      title: 数组
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
      content_markdown: |
        *数组* 是所有相同类型数据元素的固定长度集合。

        一个 *数组* 的数据类型是 `[T;N]`，其中T是元素的类型，N是编译时已知的固定长度。

        可以使用 `[x]` 运算符检索单个元素，其中 *x* 是所需元素的 *usize* 索引(从0开始)。
    ja:
      title: 配列
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
      content_markdown: |
        *配列*は、データ要素がすべて同じ型の固定長コレクションです。

        *配列*のデータ型は `[T;N]` であり、T は要素の型、N はコンパイル時に決まる固定長です。

        個々の要素は `[x]` 演算子によって取得できます。ここで *x* は取り出そうとする要素の *usize* 型のインデックス（0 始まり）です。
  - en:
      title: Functions
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
      content_markdown: |
        A function has zero or more parameters.

        In this example, add takes two arguments of type `i32` (integer of 32-bit
        length).

        Function names are always in `snake_case`.
    fr:
      title: Fonctions
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
      content_markdown: |
        Une fonction peut posséder 0 à plusieurs paramètres.

        Dans cet exemple, la fonction `add` accepte 2 arguments de type `i32` (entier
        de longueur 32-bit).

        Les noms de fonctions sont toujours de la forme `snake_case`.
    de:
      title: Funktionen
      content_html:
        "<p>Eine Funktion kann eine beliebige (nicht-negative) Anzahl an Argumenten
        bzw. Parametern aufnehmen.</p><p>In diesem Beispiel verlangt die Funktion <code>add</code>
        zwei Parameter vom Typ <code>i32</code> (32 Bit Ganzzahl).</p><p>Funktionsnamen
        sollten im <code>snake_case</code> Format vergeben werden.</p>"
    ie:
      title: Functiones
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20adddir(x%3Ai32%2C%20y%3Ai32)%20-%3E%20i32%20%7B%0A%09return%20x%20%2B%20y%20%2F%2F%20Ci%20on%20utilisa%20return%20por%20monstrar%20que%20anc%20Rust%20possede%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20ti%20clave-parol%20comun%20in%20altri%20lingues%20de%20programmation%2C%20%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20ma%20li%20plu%20idiomatic%20metode%20por%20retornar%20un%20valore%20in%20Rust%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20es%20simplicmen%20scrir%20x%20%2B%20y%20sin%20un%20punctu-comma%20(%3B)%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Dunc%3A%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20return%20x%20%2B%20y%20%3C--%20retorna%20un%20valore%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20x%20%2B%20y%20%3C--%20retorna%20un%20valore%0A%09%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20x%20%2B%20y%3B%20%3C--%20retorna%20null%20valore%20(nota%20li%20%3B%20pos%20x%20%2B%20y)%0A%7D%0A%0Afn%20main()%20%7B%0A%09println!(%22%7B%7D%22%2Cadddir(42%2C%2013))%3B%0A%7D
      content_html:
        "<p>Un function posse prender null o plu argumentes.</p><p>In ti-ci
        exemple, adddir prende du parametres del tip <code>i32</code> (integer
        (númere integrale) del longore 32-bit).</p><p>Nómines de functiones es sempre
        in <code>snake_case</code> (minuscules con infra-strecs)</p>"
    ru:
      title: Функции
      content_markdown: |
        Функция может принимать ноль или больше аргументов.

        В этом примере, функция **add** принимает два аргумента типа `i32`
        (целочисленное, длиной в 32 бита).

        Имена функций всегда пишутся в `snake_case`.
    es:
      title: Funciones
      content_markdown: |
        Una función tiene cero o más parámetros.

        En este ejemplo, "add" recibe dos argumentos de tipo `i32` (entero de 32 bits).

        Los nombres de las funciones se escriben siempre en `snake_case`.
    pt-br:
      title: Funções
      content_markdown: |
        Uma função pode receber zero ou mais parâmetros.

        Neste exemplo, *add* recebe dois parâmetros do tipo `i32` (número inteiro de 32 bits).

        Os nomes das funções são sempre em `snake_case`.
    zh-cn:
      title: 函数
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
      content_markdown: |
        函数有0个或者多个参数。

        在这个例子中，add 接受类型为 `i32` (32位长度的整数)的两个参数。

        函数名总是遵循 `蛇形命名法` (snake_case)。
    ja:
      title: 関数
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
      content_markdown: |
        関数には 0 個以上の引数があります。

        この例では、add は `i32` 型（32 ビット長の整数）の引数を 2 つ取ります。

        関数名にはスネークケース `snake_case` を使用します。
  - en:
      title: Multiple Return Values
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20return%20a%20tuple%20of%20return%20values%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructure%20the%20tuple%20into%20two%20variables%20names%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Functions can return multiple values by returning a **tuple**
        of values.

        Tuple elements can be referenced by their index number.

        Rust supports various kinds of destructuring that we will see in many forms, allowing
        us to extract sub-pieces of data structures in ergonomic ways. Be on the lookout!
    fr:
      title: Multiple valeurs de retour
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20la%20variable%20result%20est%20un%20tuple%20qui%20contient%0A%20%20%20%20%2F%2F%20deux%20entiers%20de%20type%20%60i32%60%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20la%20destructuration%20permet%20d%27affecter%20directement%0A%20%20%20%20%2F%2F%20les%20valeurs%20aux%20variables%20a%20et%20b%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Une fonction peut retourner plusieurs valeurs en retournant un *tuple* de valeurs.

        Les éléments du tuple peuvent être référencés par leur index.

        Rust nous donne la possibilité d'extraire simplement certaines parties de structures de données,
        c'est la destructuration. Nous en verrons d'autres formes par la suite. Garde l'oeil ouvert!
    de:
      title: Mehrere return-Variablen
      content_html:
        <p>Funktionen können mehrere Variablen auf einmal zurückgeben mittels
        eines <b>tuples</b>.</p><p>Die Werte können danach über einen Index gelesen werden.</p><p>Rust
        unterstützt verschiedene Formen von "destructuring", wodurch sich Wertepaare auf
        einzelne Variablen aufteilen lassen. Halte Ausschau danach!</p>
    ie:
      title: Multiplic retorn-valores
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20interchangear(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20retorna%20un%20tuple%20de%20retorn-valores%0A%20%20%20%20let%20resulta%20%3D%20interchangear(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20resulta.0%2C%20resulta.1)%3B%0A%0A%20%20%20%20%2F%2F%20destructura%20li%20tuple%20in%20du%20n%C3%B3mines%20de%20variabiles%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20interchangear(resulta.0%2C%20resulta.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_html:
        "<p>Functiones posse retornar multiplic valores per retornar un <b>tuple</b>
        de valores. (N.B. un tuple es parent con -tuplic in Interlingue-Occidental)</p><p>On
        posse referer al valores per lor position in li tuple.</p><p>Rust subtene varie
        tipes de destructuration quel noi va vider in pluri formes. To possibilisa li
        extraction de sub-pezzes de data ergonomicmen. Esse atentiv por it!</p>"
    ru:
      title: Возвращение нескольких значений
      content_markdown: |
        Функции могут возвращать несколько значений с помощью **кортежа** (tuple)
        значений.

        Доступ к значениям осуществляется по их позиции в кортеже.

        Rust поддерживает разные виды деструктуризации, которые вы увидите в разных формах.
        Это позволяет нам извлекать частички структур данных удобным способом. Смотрите
        внимательно!
    es:
      title: Múltiples variables de retorno
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20intercambiar(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Devuelve%20una%20tupla%20de%20valores%0A%20%20%20%20let%20result%20%3D%20intercambiar(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20Desestructura%20la%20tupla%20en%20dos%20variables%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20intercambiar(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_html:
        "<p>Las funciones pueden devolver múltiples valores utilizando una <b>tupla</b>
        de valores.</p><p>Los valores se pueden referenciar por su posición en la tupla.</p><p>Rust
        soporta varios modos de desestructuración que veremos en diferentes formas, esto nos
        permite extraer subconjuntos de estructuras de datos de manera práctica.
        ¡Presta mucha atención!</p>"
    pt-br:
      title: Retorno de Múltiplos Valores
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20devolve%20uma%20tupla%20de%20valores%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20desestrutura%20a%20tupla%20para%20duas%20vari%C3%A1veis%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Funções podem devolver múltiplos valores retornando uma **tupla** de valores.

        Os elementos da tupla podem ser referenciados pelo seu índice.

        O Rust suporta vários modos de desestruturação que veremos em diferentes formas, 
        permintindo extrair subconjuntos de dados de maneira prática.
    zh-cn:
      title: 多个返回值
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%85%83%E7%BB%84%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20%E5%B0%86%E5%85%83%E7%BB%84%E8%A7%A3%E6%9E%84%E4%B8%BA%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        函数可以通过 **元组** 来返回多个值。

        元组元素可以通过他们的索引来获取。

        Rust 支持我们后续将看到的各种形式的解构，允许我们以符合人类工程学的方式提取数据结构的子片段。注意！
    ja:
      title: 複数の戻り値
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E6%88%BB%E3%82%8A%E5%80%A4%E3%82%92%E3%82%BF%E3%83%97%E3%83%AB%E3%81%A7%E8%BF%94%E3%81%99%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20%E3%82%BF%E3%83%97%E3%83%AB%E3%82%922%E3%81%A4%E3%81%AE%E5%A4%89%E6%95%B0%E3%81%AB%E5%88%86%E8%A7%A3%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        関数は、値を**タプル**で返すことによって、複数の値を返せます。

        タプルの要素はインデックス番号で参照できます。

        Rust はデータ構造の一部を抽出する機能を提供します。これについては後ほど他の方法も見ていきます。
  - en:
      title: Returning Nothing
      content_markdown: |
        If no return type is specified for a function, it returns an empty tuple, also known as a *unit*

        An empty tuple is represented by `()`

        Using `()` is uncommon, but will come up often enough that it's good to know whats happening.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20the%20return%20type%20is%20implied%20as%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20this%20function%20will%20return%20()%20if%20nothing%20is%20specified%20to%20return%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Printing%20a%20debug%20string%20for%20a%20and%20b%0A%20%20%20%20%2F%2F%20Because%20it's%20hard%20to%20print%20nothingness%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    fr:
      title: Ne rien retourner
      content_markdown: |
        Si une fonction ne spécifie aucun type de retour, celle-ci retourne un tuple vide,
        également appelé *unité*.

        Un tuple vide est représenté par `()`.

        Il est rare d'utiliser `()`, mais cela arrive et il est bon de le savoir.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20le%20type%20de%20retour%20est%20implicitement%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20cette%20fonction%20retournera%20()%0A%20%20%20%20%2F%2F%20si%20rien%20n'est%20sp%C3%A9cifi%C3%A9%20en%20retour%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20le%20symbole%20%3A%3F%20signifie%20qu'on%20souhaite%20utiliser%0A%20%20%20%20%2F%2F%20un%20formatage%20sp%C3%A9cial%20de%20debug%20qui%20affichera%0A%20%20%20%20%2F%2F%20notamment%20le%20type%20des%20variables%20a%20et%20b%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    de:
      title: Keine return-Variablen
      content_markdown: |
        Wenn kein Variablentyp als Rückgabewert einer Funktion angegeben wird, gibt die Funktion ein leeres Tupel zurück, auch bekannt als *unit*.

        Ein leeres Tupel wird durch ein `()` repräsentiert.

        Die leeren Klammern werden selten verwendet, finden trotzdem an manchen Orten ihren Platz, weshalb wir diese hier kurz zum Vorschein bringen wollen.
    ie:
      title: Retornar necos
      content_markdown: |
        Si null tip de retorn es specificat por un function, it retorna un vacui tuple, anc conosset quam un *unit* (li tal-nominat tip unitic)

        On representa un vacui tuple per `()`

        In Rust it passa presc ínvisibil por que on ne mey esser distractet de it, ma it es bon a saver que un functiona retornant necos retorna un fact un vacui tuple.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20crear_necos()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20li%20tip%20de%20retorn%20es%20implicat%20quam%20()%0Afn%20crear_necos2()%20%7B%0A%20%20%20%20%2F%2F%20ti-ci%20functiona%20va%20retornar%20()%20si%20on%20specifica%20nullcos%20a%20retornar%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20crear_necos()%3B%0A%20%20%20%20let%20b%20%3D%20crear_necos2()%3B%0A%0A%20%20%20%20%2F%2F%20Printant%20un%20string%20(catene)%20debug%20por%20a%20e%20b%0A%20%20%20%20%2F%2F%20Pro%20que%20printar%20%27necosit%C3%A1%27%20es%20desfacil%0A%20%20%20%20println!(%22Li%20valore%20de%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22Li%20valore%20de%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    ru:
      title: Возврат пустого значения
      content_markdown: |
        Если в функции не указан возвращаемый тип, она возвратит пустой кортеж, также известный как **юнит**

        Пустой кортеж представлен `()`

        Использование `()` немного необычно, но вы будете часто это замечать, поэтому хорошо знать, что это такое.

    es:
      title: No devolver nada
      content_markdown: |
        Si no se especifica un tipo de retorno para una función, esta devuelve una tupla vacía, también conocida como *unidad*.

        Una tupla vacía se representa mediante `()`

        El uso de `()` es poco común, pero es necesario saber su significado ya que aparecerá de vez en cuando.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20no_hagas_nada()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20El%20valor%20de%20retorno%20es%20impl%C3%ADcitamente%20()%0Afn%20no_hagas_nada2()%20%7B%0A%20%20%20%20%2F%2F%20Esta%20funci%C3%B3n%20devuelve%20()%20si%20no%20se%20especifica%20nada%20que%20devolver%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20no_hagas_nada()%3B%0A%20%20%20%20let%20b%20%3D%20no_hagas_nada2()%3B%0A%0A%20%20%20%20%2F%2F%20Mostrando%20una%20sentencia%20de%20depuraci%C3%B3n%20para%20a%20y%20b%0A%20%20%20%20%2F%2F%20porque%20es%20dif%C3%ADcil%20no%20mostrar%20nada%0A%20%20%20%20println!(%22El%20valor%20de%20a%20es%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22El%20valor%20de%20b%20es%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
    pt-br:
      title: Retornando nada
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_nada()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20o%20tipo%20de%20retorno%20%C3%A9%20implicitamente%20()%0Afn%20faz_nada2()%20%7B%0A%20%20%20%20%2F%2F%20esta%20fun%C3%A7%C3%A3o%20ir%C3%A1%20devolver%20()%20se%20nada%20for%20especificado%20para%20retornar%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20faz_nada()%3B%0A%20%20%20%20let%20b%20%3D%20faz_nada2()%3B%0A%0A%20%20%20%20%2F%2F%20Exibindo%20uma%20string%20de%20depura%C3%A7%C3%A3o%20para%20a%20e%20b%0A%20%20%20%20%2F%2F%20Porque%20%C3%A9%20dif%C3%ADcil%20n%C3%A3o%20mostrar%20nada%0A%20%20%20%20println!(%22O%20valor%20de%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22O%20valor%20de%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Se nenhum tipo for especificado para o retorno de uma função, ele devolve uma tupla vazia,
        também conhecida como *unit*.

        Uma tupla vazia é representada por `()`.

        O uso de `()` é incomum, mas é necessário saber o seu significado uma vez que aparecerá de vez em quando.
    zh-cn:
      title: 返回空
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%90%AB%E4%B8%BA%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E5%B0%86%E4%BC%9A%E8%BF%94%E5%9B%9E%20()%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20%E6%89%93%E5%8D%B0a%E5%92%8Cb%E7%9A%84debug%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%BE%88%E9%9A%BE%E5%8E%BB%E6%89%93%E5%8D%B0%E7%A9%BA%0A%20%20%20%20println!(%22The%20value%20of%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22The%20value%20of%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        如果没有为函数指定返回类型，它将返回一个空的元组，也称为 *单元*。

        一个空的元组用 `()` 表示。

        明确的使用 `()` 是不常见的，但作为函数返回值会经常出现。
    ja:
      title: 空の戻り値
      content_markdown: |
        関数に戻り値の型が指定されていない場合、*unit* と呼ばれる空のタプルを返します。

        空のタプルは `()` と表記します。

        `()` はあまり使われませんが、時々出てくるので意味は知っておく必要があります。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%AF%20()%20%E3%81%A8%E6%8E%A8%E8%AB%96%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20%E3%81%93%E3%81%AE%E9%96%A2%E6%95%B0%E3%81%AF%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%8C%E6%8C%87%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%20()%20%E3%82%92%E8%BF%94%E3%81%99%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20%E7%A9%BA%E3%82%92%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8B%E3%81%AE%E3%81%AF%E9%9B%A3%E3%81%97%E3%81%84%E3%81%AE%E3%81%A7%E3%80%81%0A%20%20%20%20%2F%2F%20a%20%E3%81%A8%20b%20%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%96%87%E5%AD%97%E5%88%97%E3%82%92%E8%A1%A8%E7%A4%BA%0A%20%20%20%20println!(%22a%20%E3%81%AE%E5%80%A4%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22b%20%E3%81%AE%E5%80%A4%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A
  - en:
      title: Chapter 1 - Conclusion
      content_markdown: |
        Nice job so far! The basics of Rust aren't so bad, right?  We're
        getting a peek into how the Rust compiler thinks.  As a system programming language 
        it cares a lot about the size  of values in memory, whether things can be modified or not, 
        and making sure your math is what you want it to be. Next up we'll be looking at some old friends 
        `if` and `for` loops.

        More Resources:
        [Youtube: Rust Cast - A deeper dive on Rust's primitive number types](https://www.youtube.com/watch?v=n5TRBkbystY)
        [Website: Rust Book 2018 - A deeper description on basic data types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)
        [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
    fr:
      title: Chapitre 1 - Conclusion
      content_markdown: |
        Bon travail! Les fondamentaux de rust ne sont pas si dûr que ça, n'est-ce pas? Nous avons
        commençé à voir comment le compilateur de Rust fonctionne. Celui-ci fait attention à la taille
        des éléments en mémoires, s'assure si les choses peuvent êtres modifiées ou non, et fait en sorte
        qu'on ne se mélange pas les pinceaux dans les types de variables. Par la suite, nous allons voir
        de vieux amis : les structures de contrôles `if` et les boucles `for`.

        
        Plus de ressources (en anglais):
          [Youtube: Rust Cast - A deeper dive on Rust's primitive number types](https://www.youtube.com/watch?v=n5TRBkbystY)
          [Website: Rust Book 2018 - A deeper description on basic data types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)
          [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
    de:
      title: Kapitel 1 Fazit
      content_html:
        <p>Puh! Das wäre schon mal geschafft! War nicht so übel, oder? Wir wissen
        schon ein wenig, wie der Compiler denkt. Er setzt viel Wert auf Speichermanagement,
        wie groß Variablen sind, ob diese "mutable" sind oder nicht, und ob du garantiert
        weißt, welche Datentypen zusammenaddiert werden. Das sind erste kleine Einblicke
        in die <b>Sicherheit</b>, die sich durch die gesamte Rustsprache hindurchzieht
        - nicht unbedingt die Sicherheit des Systems, aber die Sicherheit, dass du weißt,
        was du tust.</p><p>Im nächsten Kapitel werden wir uns mit den altbekannten Datenkontrollstrukturen
        <code>if</code> und <code>for</code> Schleifen beschäftigen!
        Worauf wartest du noch!</p>
    ie:
      title: Capitul 1 - Conclusion
      content_html:
        "<p>Bon labor til nu! Li coses basic in Rust ne es tam mal, ne ver?
        Vi til nu un curt regarde pri qualmen pensa li compilator Rust. It sucia se mult
        pri li grandore de valores in memorie, qualmen on posse modificar un cose o ne,
        e si tui matematica es vermen to quel tu intente scrir o ne. Tis-ci es micri previsiones
        del principie de <b>safety</b> (securitá) quel prevale tra Rust. Li compilator
        solmen intente far cert que tui code fa to quo tu intente que it fa! A sequer
        noi va vider li old amics <code>if</code> (si) e cicles usant <code>for</code>
        (por).</p>"
    ru:
      title: Раздел 1 - Заключение
      content_markdown: |
        Хорошая работа! Основы Rust не так уж и плохи, правда?  Мы получили
        представление о том, как думает компилятор Rust. Ему очень важно знать размер
        значений в памяти, могут ли значения изменятся или нет, и делает необходимое для
        того, чтобы математические операции вели себя так, как вы предполагали. Это маленькое
        превью принципов **безопасности**(safety), которые так распространены в Rust.
        Компилятор всего лишь хочет, что бы ваш код делал то, что вы ожидаете! Далее мы
        рассмотрим конструкцию `if` и цикл `for`.
    es:
      title: Capítulo 1 - Conclusión
      content_html:
        "<p>¡Buen trabajo! No ha sido tan complicado, ¿verdad? Esta ha sido
        una visión general de cómo trabaja el compilador de Rust. Como ya has comprobado,
        hay que tener muy en cuenta el tamaño de los valores en memoria, las cosas que se
        pueden modificar y las que no, y asegurarse de que tu código de el resultado que esperas.
        Estos son pequeños avances de un principio de <b>seguridad</b> que prevalece a través
        de Rust. Este compilador pretende asegurarse de que tu código hace lo que esperas.
        A continuación echaremos un vistazo a algunos viejos conocidos: <code>if</code>
        y <code>for</code>.</p>"
    pt-br:
      title: Capítulo 1 - Conclusão
      content_markdown: |
        Bom trabalho! O básico do Rust não foi tão ruim, não é? Este foi só o
        comecinho de como o compilador Rust trabalha. Por ser uma linguagem de
        programação de sistemas, ele se importa muito com o tamanho dos valores
        na memória, se as coisas podem ser modificadas ou não, e garantir que sua
        matemática seja o que você quer que seja. A seguir veremos alguns velhos
        amigos: `if` e `for`.
    zh-cn:
      title: 第一章总结
      content_markdown: |
        到目前为止做得很好！ Rust 的基础知识还不错，对吧？ 我们将看到 Rust 编译器是如何思考的。
        作为一种系统编程语言，它非常关心内存中值的大小，是否可以修改内容，并确保数值符合你的预期。
        接下来，我们将看一些老朋友 `if` 和 `for` 循环。
    ja:
      title: 第 1 章 - まとめ
      content_markdown: |
        ここまでお疲れ様でした。Rust の基本はそれほど難しくなかったですよね？
        Rust のコンパイラがどのように考えているのかを覗いてみました。
        システムプログラミング言語として、メモリ内の値のサイズ、変更が可能かどうか、計算を確実にすることを重視しています。
        次はお馴染みの `if` と `for` ループについて見ていきます。

        その他の資料:

        * [Youtube: Rust Cast - A deeper dive on Rust's primitive number types](https://www.youtube.com/watch?v=n5TRBkbystY)
        * [Website: Rust Book 2018 - A deeper description on basic data types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)
        * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
  - chapter: 2
    en:
      title: Chapter 2 - Basic Control Flow
      content_markdown: |
        In this chapter let's talk about basic control flow methods in Rust.
        If you are familiar with C based languages you'll feel right at home and maybe
        enjoy a surprise or two.
    fr:
      title: Chapitre 2 - Structures de contrôle basiques
      content_markdown: |
        Dans ce chapitre, nous allons aborder les structures de contrôle basiques de Rust.
        Si tu es déjà familer avec les languages de programmation inspirés du C alors
        tu ne sera pas perdu et tu y découvrira même quelques bonnes surprises.
    de:
      title: Kapitel 2 - Ein bisschen Kontrollfluss
      content_html:
        "<p>In diesem Kapitel werden wir Kontrollflussmethoden in Rust angehen
        (engl. control flow methods). Wenn du ein bisschen Erfahrung in C-verwandten Sprachen
        hast, dürftest du dich hier wie zu Hause fühlen - die ein oder andere Überraschung
        sei dennoch zu erwarten.</p>"
    ie:
      title: Chapter 2 - Basic Control-flution
      content_html:
        "<p>Lass nos in ti-ci capitul parlar pri li metodes de basic control-flution
        in Rust. Si tu ha ja conossentat te con lingues basat sur C tu va trovar it tre
        familiari, ma con un o du plesent surprises.</p>"
    ru:
      title: Глава 2 - Управление потоком исполнения
      content_markdown: |
        В этой главе мы поговорим про базовые методы управления потоком
        исполнения в Rust. Если вы знакомы с Си-подобными языками вы будете чувствовать
        себя как дома и может быть встретите пару сюрпризов.
    es:
      title: Capítulo 2 - Estructuras de control básicas
      content_html:
        "<p>En este capítulo hablaremos de las estructuras de control básicas en Rust.
        Si estás familiarizado con lenguajes basados en C, te sentirás como en casa y quizá
        te lleves alguna que otra sorpresa.</p>"
    pt-br:
      title: Capítulo 2 - Controle de Fluxo Básico
      content_markdown: |
        Neste capítulo falaremos das estruturas de controle de fluxo básicas em Rust.
        Se você está familiarizado com linguagens baseadas em C, se sentirá em casa
        e, quem sabe, algumas agradáveis surpresas.
    zh-cn:
      title: 第二章 - 基本控制流
      content_markdown: |
        在本章中，我们将讨论 Rust 中的基本控制流方法。 如果你熟悉类 C 的语言，你会感到宾至如归，可能会感到惊讶。
  - en:
      title: if/else if/else
      content_markdown: |
        Code branching in Rust is not surprising.

        Conditions don't have parentheses! Did we ever really need them? Our logic now looks nice and clean.

        All your usual logical operators still work: `!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22less%20than%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22is%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22greater%20than%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
    fr:
      title: if/else if/else
      content_markdown: |
        L'embranchement de code en Rust n'est pas une surprise.

        Les conditions n'ont pas de parenthèses! En a-t-on réellement besoin?
        Sans elles notre code est plus joli et plus lisible.

        Les opérateurs logiques usuels sont disponibles: `!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22plus%20petit%20que%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%2242%20tout%20rond%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22plus%20grand%20que%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
    de:
      title: if/else if/else
      content_html:
        "<p>Codeverzweigungen (branching) bieten viel bekanntes.</p><p>Außer
        den fehlenden Klammern! Wer braucht die schon? Logik war noch nie so sauber.</p><p>Die
        üblichen logischen Operatoren funktionieren noch: <code>!</code><code>!=</code><code>||</code><code>&&</code><code>&lt;</code><code>&gt;</code><code>&lt;=</code><code>&gt;=</code></p><p>Versuch
        ein paar von den Operatoren in dem Code einzubauen.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20age%20%3D%2017%3B%0A%20%20%20%20%0A%20%20%20%20if%20age%20%3C%2016%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Keine%20alkoholischen%20Getr%C3%A4nke%22)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%7D%20else%20if%20age%20%3E%3D%2016%20%26%26%20age%20%3C%2018%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20checking%20(age%20%3E%3D%2016)%20could%20have%20been%20omitted%20here%0A%20%20%20%20%20%20%20%20println!(%22Darf%20Bier%2C%20Wein%20und%20Sekt%20kaufen.%20Keine%20Spirituosen%22)%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Darf%20alles%20kaufen%22)%3B%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: if/else if/else
      content_html:
        "<p>Code-ramification in Rust ne es surprisant.</p><p>Conditiones ne
        prende parentheses! Esque noi vermen alquande besonat les? Nu nor logica sembla
        nett e clar.</p><p>Omni tui usual operatores logical functiona quam sempre: <code>!</code><code>!=</code><code>||</code><code>&&</code><code>&lt;</code><code>&gt;</code><code>&lt;=</code><code>&gt;=</code></p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20exemple()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20return%20-1%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20return%200%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20return%201%3B%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: if/else if/else
      content_markdown: |
        Ветвление кода в Rust не особо отличается от того, к чему вы привыкли.

        Условия не оборачиваются в круглые скобки! Разве они нам действительно нужны? Теперь условные
        конструкции выглядят красиво и чисто.

        Все логические операторы, к которым вы так привыкли, всё еще работают: 
        `!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`.
    es:
      title: if/else if/else
      content_html:
        "<p>La ramificación de código en Rust te resultará familiar.</p><p>Las condiciones no
        van entre paréntesis, ¿acaso son necesarios? De esta manera nuestra lógica se ve más limpia y sencilla.</p>
        <p>Los demás operadores lógicos conocidos siguen funcionando: <code>!</code><code>!=</code><code>||</code><code>&&</code><code>&lt;</code><code>&gt;</code><code>&lt;=</code><code>&gt;=</code></p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22es%20menor%20que%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22es%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22es%20mayor%20que%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
    pt-br:
      title: if/else if/else
      content_markdown: |
        A ramificação de código em Rust não tem nenhuma novidade.

        Não há parêntesis nas condições! Realmente precisamos deles? Assim a nossa
        lógica fica mais simples e limpa.

        Todos os nossos operadores lógicos habituais continuam funcionando: 
        `!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22menor%20que%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22igual%20a%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22maior%20que%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
    zh-cn:
      title: if/else if/else
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22less%20than%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22is%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22greater%20than%2042%22)%3B%0A%20%20%20%20%7D%0A%7D
      content_markdown: |
        Rust 中的代码分支不足为奇。

        条件判断没有括号！我们真的需要它们吗？我们的逻辑现在看起来很清晰。

        你所有常用的逻辑运算符仍然适用：`!`, `!=`, `||`, `&&`, `<`, `>`, `<=`, `>=`
  - en:
      title: loop
      content_markdown: |
        Need an infinite loop?

        Rust makes it easy.

        `break` will escape a loop when you are ready.</p><p>`loop` has a secret we'll talk about soon.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
    fr:
      title: loop
      content_markdown: |
        Besoin d'une boucle infinie?

        Avec Rust, c'est facile!

        `break` permet de sortir de la boucle à tout moment.</p><p>Quand à
        l'instruction `loop`, celle-ci possède un secret dont nous parlerons plus tard.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
    de:
      title: loop
      content_html: "<p>Unendliche Schleifen gefällig? <code>loop</code> macht
        es möglich!</p><p>Mit <code>break</code> kann diese Schleife unterbrochen
        werden.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20print!(%22%7B%7D%20%22%2C%20x)%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
    ie:
      title: loop (cicle)
      content_html:
        "<p>Tu besona un cicle ínfinit?</p><p>Con Rust it es simplic.</p><p>Con
        <code>break</code> on exea un cicle quande on es pret.</p><p><code>loop</code>
        have un secrete pri quel noi va parlar max bentost.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
    ru:
      title: loop
      content_markdown: |
        Нужен бесконечный цикл?

        В Rust есть такой.

        `break` прервёт цикл, когда вам будет нужно.

        `loop` имеет секрет, о котором мы вскоре поговорим.
    es:
      title: loop
      content_html:
        "<p>¿Necesitas un bucle infinito?</p><p>Con Rust es muy sencillo.</p><p><code>break</code>
        nos permite salir de un bucle cuando lo indiquemos.</p><p><code>loop</code> guarda un
        secreto del que te hablaremos más adelante.</p>"
    pt-br:
      title: loop
      content_markdown: |
        Precisando de um loop infinito?

        Rust faz isso fácil.

        O `break` nos permite sair de um loop quando precisar.

        O `loop` tem um segredo do qual falaremos em breve.
    zh-cn:
      title: 循环
      content_markdown: |
        需要一个无限循环？

        使用 Rust 很容易实现。

        `break` 会退出当前循环。</p><p>`loop` 有个秘密，我们很快讲到。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  - en:
      title: while
      content_markdown: |
        `while` lets you easily add a condition to a loop.

        If the condition evaluates to `false`, the loop will exit.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A
    fr:
      title: while
      content_markdown: |
        `while` permet d'ajouter facilement une condition à une boucle.

        Si la condition est évaluée à `faux`, alors la boucle s'arrête.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: while
      content_html: "<p><code>while</code> Schleifen werden so lange ausgeführt,
        bis aus der angegeben Kondition <code>false</code> evaluiert wird.</p>"
    ie:
      title: while (durant)
      content_html: "<p><code>while</code> possibilisa te adjunter un condition
        a un cicle.</p><p>Si li condition evalua se a <code>false</code>, li
        cicle va exear.</p>"
      code-ie: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: while
      content_markdown: |
        `while` это тот же `loop`, только с условием.

        Если условие будет `false`, цикл закончится.
    es:
      title: while
      content_html:
        "<p><code>while</code> permite añadir fácilmente una condición
        al bucle.</p><p>El bucle terminará cuando la condición se evalúe a <code>false</code></p>"
    pt-br:
      title: while
      content_markdown: |
        O `while` permite que você estabeleça facilmente uma condição no loop.

        Se a condição avaliar `falso`, o loop terminará.
    zh-cn:
      title: while
      content_markdown: |
        `while` 允许你轻松地向循环添加条件。

        如果条件变为 `false`，循环退出。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: for
      content_markdown: |
        Rust's `for` loop is a powerful upgrade. It
        iterates over values from any expression that evaluates into an iterator. What's
        an iterator? An iterator is an object that you can ask the question "What's the
        next item you have?" until there are no more items.

        We'll explore this more in a future chapter, in the meantime just know Rust makes 
        it easy to create iterators that generate a sequence of integer numbers.

        The `..` operator creates an iterator that generates numbers from a start number up to
        but not including an end number.

        The `..=` operator creates an iterator that generates numbers from a start number up to 
        and including an end number.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
    fr:
      title: for
      content_markdown: |
        La boucle `for` de Rust est une mise à niveau puissante qui permet
        d'itérer sur les valeurs d'une expression en créant un itérateur.
        Qu'est-ce qu'un itérateur? Un itérateur est un objet auquel tu peux demander
        "quel est l'élément suivant?" jusqu'à ce qu'il n'y en ait plus.

        Nous donnerons plus d'explications sur les itérateurs dans un futur chapitre. Quoi qu'il en soit,
        retiens qu'avec Rust il est facile de créer des itérateurs qui génèrent une séquence de nombres entiers.

        L'opérateur `..` crée un itérateur qui génère une suite de nombres depuis la première valeur incluse
        jusqu'à la dernière valeur excluse.
        L'opérateur `..=` crée un itérateur qui génère une suite de nombres depuis la première valeur incluse
        jusqu'à la dernière valeur incluse.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: for
      content_html:
        <p><code>for</code>-Schleifen in Rust sind ein großes Upgrade.
        Wird ein Ausdruck (expression) in einen Iterator evaluiert, kann dieser in eine
        for-Schleife eingebaut werden.</p><p>Was ist ein Iterator? Ein Iterator ist ein
        Objekt, dem die Frage "Was kommt als nächstes?" gestellt werden kann. Sind keine
        Elemente mehr vorhanden, wird die Schleife abgebrochen.</p><p>In diesem Beispiel
        sehen wir, wie in Rust eine Zahlensequenz erstellt wird, über die wir iterieren
        können. Hierbei gibt es zwei unterschiedliche Notationen:</p><p><ul><li><code>x..y</code>
        erstellt einen Iterator, der bei <code>x</code> anfängt und <b>vor</b>
        <code>y</code> aufhört (exklusives <code>y</code> also)</li><li><code>x..=y</code>
        erstellt einen Iterator, der bei <code>x</code> anfängt und <b>mit</b>
        <code>y</code> aufhört (inklusives <code>y</code>)</li></ul></p>
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20print!(%220..5%20%3A%22)%3B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%20%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20print!(%22%5Cn0..5%3D%3A%22)%3B%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20print!(%22%20%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: for (por)
      content_html:
        '<p>Li cicle <code>for</code> de Rust es un potent amelioration.
        It itera sur valores de quelcunc expression queles evalua se ad-in un iterator.
        Quo es un iterator? Un iterator es un object a quel on posse demandar: "Quo es
        li cose sequent quel tu possede?" til quande ti coses es exhaustet.</p><p>Noi
        va explorar pri to in plu detallie in un capitul futuri, ma por li moment it mey
        suficer a saver que in Rust it es facil crear iteratores queles genera un sequentie
        de ciffres integral.</p><p>Li operator <code>..</code> crea un iterator
        quel genera ciffres ex un comensant ciffre til, ma ne includent, un final ciffre.</p><p>Con
        li operator <code>..=</code> on crea un iterator quel genera ciffres
        ex un comensant ciffre til, e includent, un final ciffre.</p>'
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: for
      content_markdown: |
        Rust(овый) цикл `for`, очень мощное средство.
        Он перебирает значения из любого выражения, которое вычисляется в итератор. А
        что такое итератор? Итератор - это обьект, которому вы можете сказать "Дай мне
        свой следующий элемент!" и так до тех пор, пока в нём не останется элементов.

        Мы посмотрим на это в следующей главе, между прочим Rust позволяет очень легко перебирать
        последовательности целых чисел.

        Оператор `..` создает структуру, которая итерируется с первого числа включительно по второе, в математике
        это называют полуинтервалом [0..5).

        Оператор `..=` делает то же самое, но итерируется по замкнутому интервалу [0..5]. Разница между
        ними в том что в первом случае не проитерируем пятёрку, а втором да.
    es:
      title: for
      content_html: >
        <p>El bucle <code>for</code> en Rust es una gran mejora, ya que
        itera sobre valores en cualquier expresión que se evalúe como un iterador. ¿Qué
        es un iterador? Un iterador es un objeto al que le puedes hacer la pregunta: "¿Cuál es el
        siguiente elemento?" hasta que ya no queden más elementos.</p><p>Nos centraremos más en esto
        en próximos capítulos, mientras tanto, sólo necesitas saber que en Rust es sencillo crear iteradores
        que generen secuencias de números enteros.</p><p>El operador <code>..</code>
        crea un iterador que genera números a partir de un número inicial
        pero sin incluir el número final.</p><p>El operador <code>..=</code> crea
        un iterador que genera números a partir de un número inicial, incluyendo el número final.</p>
    pt-br:
      title: for
      content_markdown: |
        O loop `for` do Rust é uma grande melhoria, uma vez que ele itera
        sobre valores de qualquer expressão que se avalie como um iterador.
        O que é um iterador? Um iterador é um objeto ao qual você pode perguntar
        "qual o seu próximo item?" até que não haja mais itens.

        Iremos explorar mais isso em um capítulo futuro, mas por enquanto basta
        saber que em Rust é fácil criar iteradores que geram uma seqüência de
        números inteiros.

        O operador `..` cria um iterador que gera uma seqüência a partir de um 
        número inicial até, mas não incluso, um número final.

        O operador `..=` cria um iterador que gera uma seqüência a partir de um 
        número inicial até um número final, inclusive.
    zh-cn:
      title: for
      content_markdown: |
        Rust的 `for` 循环是一个强大的升级。它遍历来自计算结果为迭代器的任何表达式的值。
        迭代器是什么？迭代器是一个你可以询问“下一项是什么？”直到没有其他项的对象。

        我们将在以后的章节中进一步探讨这一点，与此同时，我们知道 Rust 使创建生成整数序列的迭代器变得容易。

        `..` 运算符创建一个可以生成包含起始数字、但不包含末尾数字的数字序列的迭代器。

        `..=` 运算符创建一个可以生成包含起始数字、且包含末尾数字的数字序列的迭代器。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: match
      content_markdown: |
        Miss your switch statement? Rust has an incredibly useful keyword
        for matching all possible conditions of a value and executing a code path if the
        match is true. Let's see how this works for numbers. We will have more to say
        in future chapters on pattern matching more complex data, I promise you it will
        be worth the wait.

        `match` is exhaustive so all cases
        must be handled.

        Matching combined with destructuring is by far one of the
        most common patterns you will see in all of Rust.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20multiple%20values%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%201%20or%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20match%20against%20iterators%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20a%20number%203%20to%209%20inclusively%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20bind%20the%20matched%20number%20to%20a%20variable%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20%7B%7D%20number%20between%2010%20to%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20this%20is%20the%20default%20match%20that%20must%20exist%20if%20not%20all%20cases%20are%20handled%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20something%20else!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    fr:
      title: match
      content_markdown: |
        La structure de contrôle `switch` te manque? Rust possède un mot clé similaire
        extrêmement puissant pour comparer une valeur à un motif et permet de déclencher soit
        une exécution conditionelle soit la récupération d'une valeur (le terme anglais est
        pattern matching). Regardons un exemple pour les nombres. Nous aurons plus à dire
        dans les chapitres à venir lorsque nous l'appliquerons à des données plus complexes,
        je te promets que cela vaut la peine d'attendre.

        `match` est exhaustif donc tous les cas doivent être pris en compte.

        La destructuration combinée avec `match` fournit un des patterns les plus utilisé de Rust. Tu pourra le constater par toi même.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22C%27est%20certainement%20zero!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20on%20peut%20comparer%20%C3%A0%20plusieurs%20valeurs%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22C%27est%20soit%201%20soit%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20on%20peut%20comparer%20%C3%A0%20un%20it%C3%A9rateur%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22C%27est%20un%20nombre%20compris%20entre%203%20et%209%20inclus!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20on%20peut%20r%C3%A9cup%C3%A9rer%20la%20valeur%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22L%27entier%20%7B%7D%20est%20compris%20entre%2010%20et%20100%20inclus!%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20C%27est%20le%20cas%20par%20d%C3%A9faut.%0A%20%20%20%20%20%20%20%20%2F%2F%20Celui-ci%20doit%20%C3%AAtre%20pr%C3%A9sent%20si%20tous%20les%20cas%0A%20%20%20%20%20%20%20%20%2F%2F%20ne%20sont%20pas%20pr%C3%A9sent.%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20something%20else!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: match
      content_html:
        <p>Du vermisst dein Switch Statement? Rust lässt dich nicht im Stich!</p><p>Mittels
        <code>match</code> können Werte mit allen möglichen Konditionen und
        Werten verglichen werden. Konditionen ist hier vielleicht das interessanteste.
        Kein stupides Vergleichen, ob zwei Werte eins zu eins übereinstimmen.</p><p>Hier
        sehen wir das "matching" auf die Zahl <code>x</code> angewandt.</p><p><code>match</code>
        in Rust ist <b>exhaustive</b> (erschöpfend). Das bedeuted, dass jeder mögliche
        Wert getested werden muss, den die Variable annehmen kann. Was in manchen Programmiersprachen
        als <b>default</b> bekannt ist, ist hier durch ein einfaches Unterstrich gegeben.</p><p>Hier
        sei schon mal erwähnt, dass ein destructuring in Kombination mit match unglaublich
        viel Anwendung in der Sprache findet. Zu viel für ein Einführungskapitel leider,
        weshalb wir uns dafür etwas gedulden müssen.</p>
    ie:
      title: match
      content_html:
        "<p>Tui declaration 'switch' te manca? In Rust trova se un íncredibilmen
        util clave-parol por verificar li corespondentie de omni possibil conditiones
        de un valore e executer li code si on trova paritá. Lass nos vider qualmen it
        functiona por ciffres. In li capitules a sequer noi va parlar plu detalliatmen
        con data con plu complexitá, e yo promesse te que it va valer li pena atender
        un poc.</p><p><code>match</code> es exhaustiv, significante que omni
        possibil casus mey esser inscrit.</p><p>Serchar coresponses poy destructurar les
        es un modelle quel es de long li max comun inter tis queles on va vider in Rust.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20noi%20posse%20controlar%20li%20corespondentie%20de%20valores%20multiplic%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%201%20o%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20e%20noi%20posse%20controlar%20ti%20contra%20iteratores%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20un%20ciffre%20inter%203%20e%209%20inclusivmen%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20noi%20posse%20ligar%20li%20corespondent%20ciffre%20a%20un%20variabile%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20li%20ciffre%20%7B%7D%20inter%2010%20til%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20ti-ci%20es%20li%20coresponse%20predefenit%20quel%20deve%20exister%20si%20ne%20omni%20casus%0A%20%20%20%20%20%20%20%20%2F%2F%20es%20inscrit%3B%20pro%20que%20noi%20compara%20contra%20un%20ciffre%20quel%20posse%20esser%0A%20%20%20%20%20%20%20%20%2F%2F%20presc%20quelcunc%20valore.%20T%C3%A1men%20p.ex.%20si%20on%20vell%20comparar%20contra%20un%20bool%0A%20%20%20%20%20%20%20%20%2F%2F%20on%20vell%20besonar%20solmen%20li%20casus%20true%20e%20false%3B%20null%20_%20es%20besonat%20nam%0A%20%20%20%20%20%20%20%20%2F%2F%20li%20possibil%20coresponses%20es%20solmen%20du.%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22trovat%20alquicos%20diferent!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: match
      content_markdown: |
        Хм, а где же оператор switch? Rust имеет очень полезный оператор
        `match` - он позволяет сравнивать значение с серией шаблонов
        и затем выполнять код в зависимости от того, какое значение совпало. Давайте посмотрим,
        как это работает с числами. Я расскажу больше в будущих главах, когда мы будем
        **match**(ить) более комплексные данные, и я обещаю, что вы не зря будете ждать.

        `match` требует обработки всех возможных случаев.

        Match(ить), используя деструктуризацию, один из самых распространенных паттернов в Rust.
    es:
      title: match
      content_html:
        "<p>¿Echas de menos el “switch”? Rust tiene una palabra reservada muy útil
        para hacer coincidir (matching) todas las condiciones posibles de un valor y ejecutar una ruta
        de código si la condición es verdadera. Veamos cómo funciona esto para los números. Nos centraremos en
        los patrones de coincidencia con datos más complejos en próximos capítulos, te prometo
        que valdrá la pena la espera.</p><p><code>match</code> es exhaustivo, así que todos los
        casos deben ser evaluados.</p><p>El emparejamiento (matching) combinado con la desestructuración es uno de los
        patrones más comunes que verás en Rust</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%200%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20hacer%20comparaciones%20con%20m%C3%BAltiples%20valores%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%201%20o%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20hacer%20comparaciones%20con%20iteradores%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%20un%20numero%20entre%203%20y%209%2C%20ambos%20incluidos%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20asignar%20el%20valor%20encontrado%20a%20una%20variable%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%20%7B%7D%2C%20un%20n%C3%BAmero%20entre%2010%20y%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20esta%20es%20la%20condici%C3%B3n%20por%20defecto%20que%20debe%20existir%20%0A%20%20%20%20%20%20%20%20%2F%2F%20si%20no%20se%20han%20evaluado%20todos%20los%20casos%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontr%C3%A9%20otra%20cosa!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    pt-br:
      title: match
      content_markdown: |
        Sentiu falta do operador *switch*? O Rust tem uma palavra-chave muito
        útil para comparar um valor com todas as condições possíveis e executar
        um bloco de código se a condição for verdadeira. Vejamos como isso funciona
        com números. Falaremos mais a respeito de padrões de correspondência com dados 
        mais complexos em capítulos futuros. Prometo que a espera valerá a pena.

        O `match` é exaustivo, então todos os casos devem ser avaliados.

        Correspondências (matching) combinado com desestruturação é um dos padrões mais comuns
        que você verá no Rust.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20o%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20comparar%20com%20m%C3%BAltiplos%20valores%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%201%20ou%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20comparar%20com%20iteradores%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20um%20n%C3%BAmero%20entre%203%20e%209%2C%20inclusive%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20vincular%20a%20uma%20vari%C3%A1vel%20o%20n%C3%BAmero%20a%20ser%20comparado%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20o%20n%C3%BAmero%20%7B%7D%20entre%2010%20e%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20esta%20%C3%A9%20a%20correspond%C3%AAncia%20padr%C3%A3o%20que%20deve%20existir%20se%20nenhum%20caso%20for%20correspondido%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22encontrei%20outra%20coisa!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
    zh-cn:
      title: match
      content_markdown: |
        想念你的 switch 语句吗？Rust有一个非常有用的关键字，用于匹配值的所有可能条件，
        并在匹配为真时执行相应代码。我们来看看对数字的使用。在未来章节中，我们将有更多
        更复杂的数据模式匹配的说明，我向你保证，它将值得等待。

        `match` 是穷尽性的，所以必须处理所有情况。

        匹配与解构相结合是迄今为止你在 Rust 中看到的最常见的模式之一。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20zero%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%80%BC%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%201%20or%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%8C%B9%E9%85%8D%E8%BF%AD%E4%BB%A3%E5%99%A8%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20a%20number%203%20to%209%20inclusively%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%8C%B9%E9%85%8D%E6%95%B0%E5%80%BC%E7%BB%91%E5%AE%9A%E5%88%B0%E5%8F%98%E9%87%8F%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20%7B%7D%20number%20between%2010%20to%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E6%98%AF%E9%BB%98%E8%AE%A4%E5%8C%B9%E9%85%8D%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%A4%84%E7%90%86%E6%89%80%E6%9C%89%E6%83%85%E5%86%B5%EF%BC%8C%E5%88%99%E5%BF%85%E9%A1%BB%E5%AD%98%E5%9C%A8%E8%AF%A5%E5%8C%B9%E9%85%8D%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22found%20something%20else!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Returning Values From loop
      content_markdown: |
        `loop` can break to return a value.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22found%20the%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    fr:
      title: Retourner des valeurs avec loop
      content_markdown: |
        L'instruction `loop` peut s'arrêter pour retourner une valeur.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22J%27ai%20trouv%C3%A9%20le%2013!%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22La%20boucle%20dit%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    de:
      title: Rückgabewerte aus loop
      content_markdown: |
        In einem `loop` kann durch das Schlüsselwort `break` ein Wert zurückgegeben werden.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%2213%20gefunden!%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22aus%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    ie:
      title: Retornar valores de loop
      content_markdown: |
        `loop` posse exear (break) por retornar un valore.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22trovat%20li%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22del%20loop%20(cicle)%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    ru:
      title: Возвращение значений из loop
      content_markdown: |
        Прерывая `loop`, вы можете возвратить значение.
    es:
      title: Devolviendo valores en loop
      content_markdown: |
        Podemos devolver un valor en un `loop` cuando usamos `break`
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22encontr%C3%A9%20el%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Del%20bucle%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    pt-br:
      title: Retornando Valores de um loop
      content_markdown: |
        `loop` podem ser interrompidos para retornar um valor.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22encontrei%20o%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22do%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
    zh-cn:
      title: 从循环中返回值
      content_markdown: |
        `loop` 可以中断以返回一个值。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22found%20the%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A
  - en:
      title: Returning Values From Block Expressions
      content_markdown: |
        `if`,`match`,functions, and scope blocks all have a unique way of returning values in Rust.

        If the last statement in an `if`, `match`, function, or scope block is an expression without
        a `;`, Rust will return it as a value from the block. This
        is a great way to create concise logic that returns a value that can be put into
        a new variable.

        Notice that it also allows an `if` statement to operate like a concise ternary expression.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22from%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22is%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22is%20not%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifying%20food%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22from%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    fr:
      title: Retourner des valeurs avec des blocs d'instructions
      content_markdown: |
        `if`,`match`, les fonctions et les blocs d'instructions ont tous
        une manière unique de retourner des valeurs avec Rust.

        Si la dernière instruction d'un `if`, d'un `match`, d'une fonction ou d'un bloc d'instructions
        se termine sans `;`, alors Rust retournera le résultat de l'exécution de cette dernière ligne
        en tant que valeur. C'est un moyen élégant de créer une logique conçise qui retourne
        une valeur qu'on pourra ensuite stocker dans une variable.

        Note que cela permet également l'instruction `if` de se comporter comme une expression ternaire.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20expression%20ternaire%20avec%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22depuis%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22est%20un%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20note%20que%20les%20accolades%20sont%20optionnelles%20lorsqu'il%20n'y%20a%0A%20%20%20%20%20%20%20%20%2F%2F%20qu'un%20seul%20cas%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22n'est%20pas%20un%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22un%20%7B%7D%20%7B%7D%22%2C%20food%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20ce%20bloc%20de%20code%20nous%20permet%20d'obtenir%20un%20r%C3%A9sultat%0A%20%20%20%20%20%20%20%20%2F%2F%20sans%20d%C3%A9finir%20de%20fonction%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22depuis%20le%20bloc%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20c'est%20la%20mani%C3%A8re%20typique%20de%20Rust%20pour%20retourner%0A%20%20%20%20%2F%2F%20une%20valeur%20depuis%20une%20fonction%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22depuis%20la%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    de:
      title: Rückgabewerte aus Blockausdrücken
      content_html:
        "<p>Als <b>Block</b> wird in Rust ein Codestück zwischen zwei geschweiften
        Klammern bezeichnet (<code>{ /* code block */ }</code>).</p><p>Hier
        ist eine Besonderheit in Rust: Blockausdrücke, die in <code>if</code>,
        Funktionen etc. zu finden sind, können Werte zurückgeben (return).</p><p>Noch etwas
        idiomatisches in Rust: wenn die letzte Zeile in einem solchen Codeblock ein Ausdruck
        (expression) ohne <code>;</code> am Ende ist, interpretiert Rust dies
        als den Rückgabewert.</p><p>Für Leute, die ein Fan von ternary Operatoren sind
        und das Fragezeichensymbol in Rust vermissen, <code>if</code> Statements
        bilden dazu die Alternative.</p>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust's%20ternary%20expression%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22aus%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22nutella%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22nutella%22%20%3D%3E%20%22ist%20nutella%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20notice%20the%20braces%20are%20optional%20when%20its%20just%20a%20single%20return%20expression%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22nein%2C%20das%20ist%20keine%20nutella%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Essen%20identifizieren%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20scope%20block%20lets%20us%20get%20a%20result%20without%20polluting%20function%20scope%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22aus%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20The%20idiomatic%20way%20to%20return%20a%20value%20in%20rust%20from%20a%20function%20at%20the%20end%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22aus%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    ie:
      title: Retornar valores de bloc-expressiones
      content_html: "<p><code>if</code>,<code>match</code>,
        functiones, e cadre-blocs omni possede un maniere unic por retornar valores in
        Rust.</p><p>Si
        li ultim declaration in un bloc <code>if</code>,
        functiones, o cadre-bloc es un expression sin un <code>;</code>, Rust
        va retornar it quam un valore ex li bloc. To-ci es un bonissim maniere de crear
        logic concis quel retorna un valore quem on posse plazzar in un nov variabile.</p><p>Ples
        notar que to possibilisa que un declaration <code>if</code> opera quam
        un expression ternari concis.</a>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20exemple()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Li%20expression%20ternari%20de%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22de%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20manjage%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20resultate%20%3D%20match%20manjage%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22es%20un%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20nota%20que%20li%20inbrassamentes%20es%20optional%20quande%20hay%20solmen%20un%0A%20%20%20%20%20%20%20%20%2F%2F%20expression%20de%20retorna%20simplic%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22ne%20es%20un%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifcante%20li%20manjage%3A%20%7B%7D%22%2C%20resultate)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Ti-ci%20cadre-bloc%20fa%20it%20possibil%20por%20nos%20a%20trovar%20un%20resultate%20sin%0A%20%20%20%20%20%20%20%20%2F%2F%20polluer%20li%20cadre%20del%20function%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22del%20bloc%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20Vi%20li%20metode%20idiomatic%20in%20Rust%20por%20retornar%20li%20valore%20de%20un%20function%0A%20%20%20%20%2F%2F%20al%20fine%20de%20it%20(quam%20monstrat%20un%20vez%20in%20Capitul%201)%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22del%20function%3A%20%7B%7D%22%2C%20exemple())%3B%0A%7D%0A
    ru:
      title: Возвращение значений из выражений-блоков
      content_markdown: |
        `if`, `match`, функции и блоки(scope blocks) - все имеют уникальный
        способ возвращать значение.

        Если последняя инструкция в `if`, `match`, функции или 
        блоке(scope block) не завершается `;`, Rust вернёт это значение 
        из данного блока. Это отличный способ создать краткую логику, которая
        возвращает какое-то значение, не создавая новую функцию, и сразу же присваивая
        это значение переменной.

        Примечание: если `if` имеет ветку `else`, его можно использовать как 
        тернарый оператор.
    es:
      title: Devolviendo valores en bloques de expresiones
      content_html:
        "<p>Las sentencias <code>if</code>,<code>match</code>, funciones
        y bloques de código presentan maneras únicas de devolver valores en Rust.</p>
        <p>Si la última sentencia de un <code>if</code>,
        <code>match</code>, función o bloque de código es una expresión sin
        <code>;</code>, Rust la devolverá como valor de retorno del bloque. Esta
        es una gran manera de crear una lógica concisa que devuelva un valor que pueda ser
        asignado a un nueva variable.</p><p>Ten en cuenta que también permite a una sentencia <code>if</code>
        operar como una expresión ternaria concisa.</a>"
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Expresi%C3%B3n%20ternaria%20en%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22Del%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburguesa%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22perrito%20caliente%22%20%3D%3E%20%22es%20un%20perrito%20caliente%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20los%20par%C3%A9ntesis%20son%20opcionales%20cuando%20hay%20una%20sola%20expresi%C3%B3n%20de%20retorno%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22no%20es%20un%20perrito%20caliente%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Identificando%20comida%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Este%20bloque%20de%20c%C3%B3digo%20nos%20permite%20obtener%20un%20resultado%0A%20%20%20%20%20%20%20%20%2F%2F%20sin%20tener%20que%20definir%20una%20funci%C3%B3n%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Del%20bloque%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20Esta%20es%20la%20forma%20de%20devolver%20un%20valor%20en%20Rust%20al%20final%20de%20una%20funci%C3%B3n%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22De%20la%20funci%C3%B3n%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    pt-br:
      title: Retornando Valores de um Bloco de Códígo
      content_markdown: |
        `if`, `match`, funções e blocos de código têm maneiras únicas de retornar
        valores em Rust.


        Se a última instrução de um `if`, `match`, função ou bloco de código 
        for uma expressão sem `;`, o Rust vai retorná-la como um valor do bloco.

        Esta é uma ótima maneira de criar uma lógica concisa que retorna um valor que
        pode ser atribuída a uma nova variável.

        Note isso também permite que o operador `if` funcione como uma expressão ternária concisa.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20express%C3%A3o%20tern%C3%A1ria%20em%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22do%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamb%C3%BArger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22cachorro-quente%22%20%3D%3E%20%22%C3%A9%20cachorro-quente%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20repare%20que%20as%20chaves%20s%C3%A3o%20opcionais%20quando%20o%20retorno%20%C3%A9%20s%C3%B3%20uma%20express%C3%A3o%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22n%C3%A3o%20%C3%A9%20cachorro-quente%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identificando%20o%20lanche%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Este%20bloco%20de%20c%C3%B3digo%20nos%20permite%20obter%20um%20resultado%20sem%20poluir%20o%20escopo%20da%20fun%C3%A7%C3%A3o%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22do%20bloco%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20Assim%20retornamos%20um%20valor%20en%20Rust%20no%20final%20de%20uma%20fun%C3%A7%C3%A3o%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22da%20fun%C3%A7%C3%A3o%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
    zh-cn:
      title: 从块表达式返回值
      content_markdown: |
        `if`，`match`，函数，以及作用域块都有一种返回值的独特方式。

        如果 `if`、`match`、函数或作用域块中的最后一条语句是不带 `;` 的表达式，
        Rust将把它作为一个值从块中返回。这是一种创建简洁逻辑的好方法，它返回一个
        可以放入新变量的值。

        注意，它还允许 `if` 语句像简洁的三元表达式一样操作。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Rust%E7%9A%84%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22from%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22hamburger%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22hotdog%22%20%3D%3E%20%22is%20hotdog%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20%E6%B3%A8%E6%84%8F%EF%BC%8C%E5%BD%93%E5%AE%83%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%97%B6%EF%BC%8C%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%98%AF%E5%8F%AF%E9%80%89%E7%9A%84%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22is%20not%20hotdog%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22identifying%20food%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%99%E4%B8%AA%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%9D%97%E8%AE%A9%E6%88%91%E4%BB%AC%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%93%E6%9E%9C%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22from%20block%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20%E5%9C%A8%E6%9C%80%E5%90%8E%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%83%AF%E7%94%A8%E6%96%B9%E6%B3%95%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22from%20function%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A
  - en:
      title: Chapter 2 - Conclusion
      content_markdown: |
        Hopefully I've shown a glimpse of Rust's power even in the most
        basic language features. We'll be talking about `for` and
        `match` even more in depth as we gain more knowledge that
        can utilize their capabilities. Next time we'll get into Rust's foundational data
        structures.
    fr:
      title: Chapitre 2 - Conclusion
      content_markdown: |
        J'espère avoir montré un aperçu des fonctionnalités basiques de Rust dont certaines
        se montrent très pratiques. Nous verrons plus en détails les instructions `for` et
        `match` à mesure que nos connaissances de Rust augmentent. Par la suite, nous verrons
        les structures de données fondamentales de Rust.
    de:
      title: Kapitel 2 Fazit
      content_html:
        "<p>Was? Das war's schon?</p><p>Keine Bange, es gibt noch viel zu erforschen!
        Insbesondere <code>match</code> wurde hier außer Acht gelassen, das
        viele mächtige Features beinhaltet, dementsprechend aber auch etwas mehr Hintergrundwissen
        erfordert.</p><p>Im nächsten Kapitel werden wir uns dafür ein bisschen in die
        Datenstrukturen (data structures) von Rust einarbeiten. Worauf warten wir noch?</p>"
    ie:
      title: Capitul 2 - Conclusion
      content_html:
        "<p>Vi li tot contenete til nu in li capitul! Yo espera har monstrat
        te un poc pri li potentie de Rust quel trova se mem in li declarationes max basic.
        Noi va parlar mem plu detalliatmen pri <code>for</code> e <code>match</code>
        durant que nor conossentie augmenta se pri qualmen utilisar lor capabilitás. Por
        li proxim vez, noi va conossentar nos pri li fundamental data-structuras de Rust.</p>"
    ru:
      title: Глава 2. Заключение
      content_markdown: |
        Надеюсь, я продемонстрировал силу Rust даже в самых основных возможностях
        языка. Мы будем говорить про `for` и `match` еще глубже, когда обретём больше
        знаний, которые позволят применить больше возможностей языка. В следующий раз
        мы перейдем к основополагающим структурам данных Rust.
    es:
      title: Capítulo 2 - Conclusión
      content_html:
        "<p>Con esto ya hemos echado un vistazo a las características más
        básicas del lenguaje Rust. Hablaremos de <code>for</code> y
        <code>match</code> en más profundidad a medida que aumentemos
        nuestro conocimiento sobre cómo aplicar sus capacidades.
        Lo siguiente será adentrarnos en las estructuras de datos fundamentales de Rust.</p>"
    pt-br:
      title: Capítulo 2 - Conclusão
      content_markdown: |
        Espero ter mostrado um vislumbre do poder de Rust, mesmo nos recursos
        mais básicos de linguagem. Nós iremos falar do `for` e
        `match` com mais profundidade à medida que formos adquirindo mais 
        conhecimento para aproveitar os seus recursos. A seguir entraremos nos 
        fundamentos das estruturas de dados do Rust.
    zh-cn:
      title: 第二章总结
      content_markdown: |
        希望我已经展示了 Rust 的强大功能，即使是在最基本的语言特性中。
        我们将更深入地讨论 `for` 和 `match`，因为我们将获得更多可以
        利用它们能力的知识。下次我们将讨论 Rust 的基础数据结构。
  - chapter: 3
    en:
      title: Chapter 3 - Basic Data Structure Types
      content_markdown: |
        It's time we explore beyond basic types! In this chapter we will look the most primitive 
        data structures in Rust, paying close attention to their representations in memory. I think 
        you will enjoy how little Rust hides from you how things work.
    fr:
      title: Chapitre 3 - Types basiques de structure de données
      content_markdown: |
        Il est temps d'explorer autre chose que les types basiques! Dans ce chapitre nous allons
        nous intéresser aux structures de données les plus primitives de Rust, en étudiant particulièrement
        de quelle manière celles-ci sont représentées en mémoire. Je pense que tu apprécieras le fait que
        Rust ne nous cache pas comment les choses fonctionnent.
    de:
      title: Kapitel 3 - Datenstrukturen
      content_markdown: |
        Zeit die Basisdatentypen zu erweitern! Hier werden wir leicht komplexere Datenstrukturen
        in Rust betrachten, speziell wie die Daten im Speicher verteilt werden. Alle low-level-Enthusiasten
        (mitunter dir) werden sicherlich Gefallen daran haben, wie wenig Rust vor einem versteckt.
    ie:
      title: Capitul 3 - Basic Tipes de Data-Structura
      content_markdown: |
        Li témpor ha venit por explorar ultra li tipes basic! In ti-ci capitul noi va vider li max primitiv 
        data-structuras in Rust, atentente pri qualmen ili representa se in li memorie. Yo crede que tu va 
        juir vider quant litt Rust oculta de te pri qualmen functiona li coses.
    ru:
      title: Глава 3 - Структуры данных
      content_markdown: |
        Время посмотреть на что-то помимо базовых типов! В этой главе мы посмотрим на самые примитивные структуры данных в Rust, уделив особое внимание их представлению в памяти. 
        Я думаю, вам понравится, что Rust так мало скрывает от вас то, как всё работает.
    es:
      title: Capítulo 3 - Tipos Básicos de Estructuras de Datos
      content_markdown: |
        ¡Ha llegado la hora de explorar más allá de los tipos básicos! En este capítulo veremos
        las estructuras de datos más primitivas de Rust, prestando mucha atención a sus representaciones en
        memoria. También te darás cuenta de lo poco que oculta Rust sobre cómo funcionan las cosas.
    pt-br:
      title: Capítulo 3 - Tipos Básicos de Estrutura de Dados
      content_markdown: |
        Chegou a hora de explorar além dos tipos básicos! Neste capítulo veremos as estruturas
        de dados mais primitivas do Rust, prestando muita atenção nas suas representações em
        memória. Acredito que você gostará do quão pouco o Rust esconde de você como as coisas 
        funcionam.
    zh-cn:
      title: 第三章 - 基本数据结构类型
      content_markdown: |
        现在是我们探索基本类型之外内容的时候了！在本章中，我们将查看 Rust 中最原始的数据结构，
        密切关注它们在内存中的表示。我想你们会喜欢上 Rust 是很少隐藏事情运作原理的。
  - en:
      title: Structures
      content_markdown: |
        A `struct` a collection of fields.

        A *field* is simply a data value associated with a data structure. Its value can be of a primitive type or a data structure.

        Its definition is like a blueprint for a compiler on how to layout the fields in memory nearby each other.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20String%20is%20a%20struct%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D
    fr:
      title: Structures
      content_markdown: |
        Une structure est une collection de champs. On crée une structure avec le mot clé `struct`.

        Un *champs* est simplement un élément contenant une valeur et qui est associé à une structure de données.
        Sa valeur peut être un type primitif ou une autre structure de données.

        Sa définition est comme un plan pour le compilateur sur l'agencement des données en mémoire.
        Celles-ci seront placées à proximité les unes des autres.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20String%20est%20%C3%A9galement%20une%20structure%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D
    de:
      title: Strukturen
      content_markdown: |
        Ein `struct` (dt. "Struktur") ist eine Ansammlung von fields (dt. Feldern).

        Ein *field* ist ein Wert, der mit einer Datenstruktur assoziiert wird. Dies kann ein primitiver Datentyp oder ein weiteres `struct` sein.

        Die Definition eines structs ist wie ein Entwurf für den Compiler, der ihm besagt, welche Felder im Speicher zueinander gehören.
    ie:
      title: Structuras
      content_markdown: |
        Un `struct` es un colection de fields (campes).

        Un *field* es simplicmen un valore de data asociat a un data-structura. Su valore posse esser un tip primitiv o un data-structura.

        Su definition es simil a un plan por li compilator pri qualmen plazzar li campes in memorie proxim unaltru.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20CreaturaMarin%20%7B%0A%20%20%20%20%2F%2F%20String%20es%20un%20struct%0A%20%20%20%20tip_de_animale%3A%20String%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20String%2C%0A%7D
    ru:
      title: Структуры
      content_markdown: |
        `struct` - это колекция полей.

        *field* (поле) - это просто какое-то значение, которое содержится в структуре. Значение поля может быть примитивным типом или другим типом, например структурой.

        Определение структуры - это как чертеж для компилятора, который указывает на то, как поля должны быть расположены в памяти.

        Поля в структуре расположены в памяти один за другим (компилятор может менять их местами для оптимизаций).
    es:
      title: Estructuras
      content_markdown: |
        Una estructura `struct` es una colección de campos.

        Un *campo* es simplemente un valor de datos asociado a una estructura de datos. Su valor puede ser de tipo primitivo o una estructura de datos.

        Su definición es como una plantilla para el compilador sobre cómo disponer los campos en memoria cerca unos de otros.
    pt-br:
      title: Estruturas
      content_markdown: |
        Uma estrutura `struct` é uma coleção de campos.

        Um *campo* é simplesmente um valor de dado associado a uma estrutura de dados. Seu valor pode
        ser um tipo primitivo ou uma estrutura de dados.

        Sua definição é como um modelo para o compilador sobre como organizar os campos na memória 
        próximos uns dos outros.
    zh-cn:
      title: 结构体
      content_markdown: |
        一个 `struct` 就是一些字段的集合。

        *字段* 是一个与数据结构相关联的数据值。它的值可以是基本类型或结构体类型。

        它的定义就像一个编译器的蓝图，告诉编译器如何在内存中布局彼此相邻的字段。

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20String%20%E6%98%AF%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D
  - en:
      title: Calling Methods
      content_markdown: |
        Unlike functions, methods are a function associated with a specific data type.

        **static methods** — methods that belong to a type itself are called using the `::` operator.

        **instance methods** — methods that belong to an instance of a type are called using the `.` operator.

        We will talk more on making your own methods in future chapters.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Using%20a%20static%20method%20to%20create%20an%20instance%20of%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20Using%20a%20method%20on%20the%20instance%0A%20%20%20%20println!(%22%7B%7D%20is%20%7B%7D%20characters%20long.%22%2C%20s%2C%20s.len())%3B%0A%7D%0A
    fr:
      title: Appel de méthodes
      content_markdown: |
        A la différence des fonctions que nous avons vu précédemment, les méthodes sont
        des fonctions associées à un type de donnée spécifique.

        **méthodes statiques** — méthodes qui appartiennent au type même et sont appelées avec l'opérateur `::`

        **méthodes d'instance** — méthodes qui appartiennent à l'instance d'un type et sont appelées avec l'opérateur `.`

        Nous verrons comment créer tes propres méthodes dans de futurs chapitres.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20On%20utilise%20une%20m%C3%A9thode%20statique%20pour%20cr%C3%A9er%20une%20instance%20de%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20On%20utilise%20ici%20une%20m%C3%A9thode%20directement%20sur%20l%27instance%0A%20%20%20%20println!(%22%7B%7D%20contient%20%7B%7D%20caract%C3%A8res.%22%2C%20s%2C%20s.len())%3B%0A%7D%0A
    de:
      title: Methoden aufrufen
      content_markdown: |
        Einen feinen Unterschied zu Funktionen bilden Methoden. Methoden sind Erweiterungen zu Datentypen,
        bzw. Funktionen die auf Datentypen anzuwenden sind.

        **statische Methoden** - Methoden, die zum Datentyp selber assoziiert sind. Werden mit dem `::` Operator aufgerufen.

        **instanz Methoden** (instance methods) - Methoden, die bei einer Instanz (oder Objekt) mit dem `.` Operator aufgerufen werden können.

        Wir werden im späteren Verlauf sehen, wie wir selber Methoden erstellen können.
    ie:
      title: Calling Methods
      content_markdown: |
        Need translation.
    ru:
      title: Вызов метода
      content_markdown: |
        Методы - это функции, ассоциированные с определенным типом данных.

        **статические методы** - принадлежат к типу и вызываются с помощью оператора `::`.

        **методы объектов** — это методы, что можно применить только на уже созданном объекте через оператор `.`.

        Мы поговорим о том, как создавать свои методы в следующих главах.
    es:
      title: Llamadas a Métodos
      content_markdown: |
        A diferencia de las funciones, los métodos son funciones asociadas con un tipo de datos específico.

        **Métodos estáticos** — los métodos que pertenecen a un tipo determinado se llaman usando el operador `::`.

        **Métodos de instancia** — los métodos que pertenecen a una instancia de un tipo se llaman usando el operador `.`.

        Hablaremos de cómo hacer tus propios métodos en próximos capítulos.
    pt-br:
      title: Chamando Métodos
      content_markdown: |
        Diferentemente das funções, os métodos são uma função associada a um tipo de dados específico.

        **Métodos estáticos** — os métodos que pertencem a um tipo determinado são chamados usando o operador `::`.

        **Métodos de instância** — os métodos que pertencem a uma instância de um tipo são chamados usando o operador `.`.

        Falaremos mais sobre como criar seus próprios métodos nos próximos capítulos.
    zh-cn:
      title: 方法调用
      content_markdown: |
        与函数（function）不同，方法（method）是与特定数据类型关联的函数。

        **静态方法** — 属于某个类型，调用时使用 `::` 运算符。

        **实例方法** — 属于某个类型的实例，调用时使用 `.` 运算符。

        我们将在后续章节中更多地讨论如何创建自己的方法。

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAString%E5%AE%9E%E4%BE%8B%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Hello%20world!%22)%3B%0A%20%20%20%20%2F%2F%20%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%9D%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%0A%20%20%20%20println!(%22%7B%7D%20is%20%7B%7D%20characters%20long.%22%2C%20s%2C%20s.len())%3B%0A%7D%0A
  - en:
      title: Memory
      content_markdown: |
        Rust programs have 3 memory regions where data is stored:
        * **data memory** - For data that is fixed in size and **static** (i.e always available through life of program). 
          Consider the text in your program (e.g. "Hello World!"), this text's bytes are only ever read from one place 
          and therefore can be stored in this region. Compilers make lots of optimizations 
          with this kind of data, they are generally considered very fast to use since
          locations are known and fixed.
        * **stack memory** - For data that is declared as variables within a function. 
          The location of this memory never changes for the duration of a function call, because of this compilers 
          can optimize code so stack data is very fast to access. 
        * **heap memory** - For data that is created while the application is running. 
          Data in this region may be added, moved, removed, resized, etc. Because of 
          its dynamic nature it's generally considered slower to use, but it allows 
          for much more creative usages of memory.  When data is added to this region we 
          call it an **allocation**. When data is removed from this section we call it a 
          **deallocation**.
    fr:
      title: Mémoire
      content_markdown: |
        Un programme Rust possède 3 régions de mémoire où les données sont stockées:
        * **data memory (le segment de données)** - Pour les données de taille fixe et **statiques** (i.e toujours
          disponible pendant la vie du programme). Par exemple, considère le texte "Hello World!"
          de ton tout premier programme Rust, les bytes représentant ce texte sont lu à un seul endroit
          et par conséquent ils sont placés dans cette région. Le compilateur utilise de
          nombreuses optimisations pour ce type de données, elles sont généralement
          considérées très rapide d'utilisation car leur position en mémoire est connue
          et fixe.
        * **stack memory (la pile)** - Pour les données qui sont déclarées comme variables dans une fonction.
          La position de cette mémoire ne change jamais pendant la durée d'appel de cette fonction,
          par conséquent les compilateurs peuvent optimiser le code pour rendre l'accès des données
          sur la pile très rapide.
        * **heap memory (le tas)** - Pour les données qui sont créées lorsque l'application est en train de s'exécuter. 
          Les données dans cette région peuvent être ajoutées, déplacées, supprimées, redimensionnées, etc.
          À cause de sa nature dynamique, c'est généralement considéré plus lent d'utilisation que la pile, mais
          donne plus de contrôle sur l'utilisation de la mémoire.
          On appelle **allocation** le fait d'ajouter des données à cette région et
          **désallocation** le fait de les supprimer.
    de:
      title: Speicher
      content_markdown: |
        In Rust gibt es 3 unterschiedliche Speicher-Regionen:
        * **data memory** (Datenspeicher) - Für Daten mit fester Größe und die **statisch** sind (zur Gesamtlebenszeit
          eines Programms verfügbar). Nehmen wir beispielsweise festen Text her (z.B. `"Hallo Welt"`). Die Bytes in
          diesem Schnipsel werden nur gelesen und sind bereits zur Kompilierzeit bekannt, daher kommen sie in den
          Datenspeicher. Compiler können dementsprechend den Code optimieren und sind in der Laufzeit am schnellsten
          "auszuwerten."
        * **stack memory** (Stackspeicher) - Variablen, die innerhalb einer Funktion deklariert werden. Während eines
          Funktionsaufrufs ändert sich der Standort nicht. Wird eine weitere Funktion aufgerufen, werden die von der
          Unterfunktion benötigen Variablen weiter auf den Stack gelegt. Erreicht man das Ende der Funktion, werden die
          entsprechenden Variablen wieder vom Stack runtergenommen.
        * **heap memory** (Heapspeicher) - Speicher, der zur Laufzeit für Daten reserviert wird. In dieser Region kann
          Speicher reserviert, bewegt, vergrößert, verkleinert und freigegeben werden. Dieses dynamische
          Speichermanagement kann etwas mehr Zeit in Anspruch nehmen. Beim Reservieren spricht man von **memory allocationt**
          (allozieren), beim Freigeben von **memory deallocation**.
    ie:
      title: Memorie
      content_markdown: |
        Programmas in Rust have 3 regiones de memorie ú es plazzat li data:
        * **data-memorie** - Por data con un grandore fix e **static** (a saver, sempre disponibil durant li vive del programma). 
        Ples considerar li textu in tui programma (p.ex. "Salute Munde!"); li bytes de ti-ci textu es solmen leet e pro to 
        on plazza les in ti-ci loc. Li compilatores sovente optimisa ti tip data, on considera les rapidissim a usar pro que 
        lor locs es conosset e fix.
        * **stack memory** (cumul-memorie) - Por data declarat quam variabiles intra un function. Li loc de ti-ci memorie 
        ne changea se durant li duration del vocation de un function, e pro to li compilatores posse optimisar li code 
        por far data in li cumul rapid a utilisar.
        * **heap memory** (amasse-memorie) - Por data creat durant que li aplication execute se. Li data in ti-ci loc posse esser 
        adjuntet, movet, removet, mesurat, etc. Pro su natura dinamic on considera it plu lent a utilisar, ma it possibilisa 
        plu creativ usationes de memorie. Quande on adjunte data a ti-ci region on nomina it un **alocation**. Quande on remove data 
        de it on nomina it un **dealocation**.
    ru:
      title: Память
      content_markdown: |
        Программы на Rust имеют 3 региона, в которых хранятся данные:

        * **data memory** (память данных) - для данных фиксированного размера и **статические** (доступны в любой момент
          времени выполнения программы). Рассмотрим текст в вашей программе (пример строка "Hello World!"). Эта строка - 
          это набор байт, которые нельзя изменить и можно только считать, поэтому они размещены в этом регионе. Компиляторы
          делают очень много оптимизаций с таким типом данных. Этот регион памяти считается очень быстрым, так как 
          местоположение данные известно и фиксировано заранее.
        * **stack memory** (стек) - для данных, что объявляются как переменные внутри блока видимости (например функция).
          Местоположение этого типа памяти никогда не меняется на протяжении вызова функции, из-за этого компиляторы
          могут оптимизировать код, поэтому стек очень быстро работает.
        * **heap memory** (куча) - для данных, которые создаются, пока приложение работает.
          Данные в этом регионе могут быть добавлены, перемещены, удалены, изменены в размере, и т.д. Из-за своей 
          динамической природы, считается что этот регион медленней остальных, но он позволяет более креативное использование
          памяти. Когда данные добавляются в этот регион, это называется **allocation** (выделение памяти). Когда данные 
          удаляются - deallocation (освобождение памяти).
    es:
      title: Memoria
      content_markdown: |
        Los programas Rust tienen 3 regiones de memoria donde almacenar los datos:
        * **Data memory (o memoria de datos)** - Para datos de tamaño fijo y **estáticos** (es decir, siempre disponibles a lo largo
          de la vida del programa). Considera el texto del programa (por ejemplo, "¡Hola, Mundo!"), los bytes de este texto son de sólo
          lectura, por lo tanto se almacenan en esta región. Los compiladores hacen muchas optimizaciones
          con este tipo de datos, generalmente se consideran muy rápidos de usar ya que
          las ubicaciones son conocidas y fijas.
        * **stack memory (o memoria de pila)** - Para los datos que se declaran como variables dentro de
          una función. La ubicación de esta memoria nunca cambia durante la duración de la llamada a la función, debido a esto los
          compiladores pueden optimizar el código para que los datos de la pila sean rápidos de usar.
        * **heap memory (memoria de montículo o dinámica)** - Para los datos que se crean mientras la aplicación se está ejecutando.
          Los datos de esta región pueden ser añadidos, movidos, eliminados, redimensionados, etc.
          Debido a su naturaleza dinámica, se considera generalmente más lento de usar, pero permite
          usos mucho más creativos de la memoria. Cuando se añaden datos a esta región, lo llamamos
          **asignación**. Cuando los datos se eliminan de esta sección lo llamamos **desasignación**.
    pt-br:
      title: Memória
      content_markdown: |
        Os programas em Rust têm 3 regiões de memória onde os dados são armazenados:
        * **data memory (memória de dados)** - Para dados com tamanho fixo e **estático** (ou seja, 
          sempre disponíveis durante a vida útil do programa). Considere um texto em seu programa 
          (por exemplo, "Olá, mundo!"), os bytes desse texto são somente lidos, então eles são 
          colocados nesta região. Compiladores fazem muitas otimizações esse tipo de dados, eles 
          geralmente são considerados muito rápidos de usar pois onde estão armazenados são 
          conhecidos e fixos.
        * **stack memory (memória de pilha)** - Para dados declarados como variáveis dentro de uma
          função. O local dessa memória nunca muda durante a duração de uma chamada de função, assim
          os compiladores podem otimizar o código e por isso a pilha de dados é muito rápida de 
          acessar.
        * **heap memory** - Para dados criados enquanto o aplicativo está em execução. Os dados 
          nessa região podem ser adicionados, movidos, removidos, redimensionados etc. Por causa da 
          sua natureza dinâmica geralmente é considerado mais lenta, mas permite usos de memória muito 
          mais criativas. Quando dados são adicionados a essa região, chamamos de **alocação**. Quando 
          os dados são removidos desta seção, chamamos de **desalocação**.
    zh-cn:
      title: 内存
      content_markdown: |
        Rust 程序有3个存放数据的内存区域：
        * **数据内存** - 对于固定大小和 **静态** （就是在整个程序声明周期中都存在的）的数据。
          考虑一下程序中的文本（例如 “Hello World”），该文本的字节只能读取，因此它们位于该区域中。
          编译器对这类数据做了很多优化，由于位置已知且固定，因此通常认为编译器使用起来非常快。
        * **栈内存** - 对于在函数中声明为变量的数据。
          在函数调用期间，内存的位置不会改变，因为编译器可以优化代码，所以栈数据使用起来非常快。
        * **堆内存** - 对于在程序运行时创建的数据。
          此区域中的数据可以添加、移动、删除、调整大小等。由于它的动态特性，通常认为它使用起来比较慢，
          但是它允许更多创造性的内存使用。当数据添加到该区域时，我们称其为 **分配**。 从本区域中删除
          数据后，我们将其称为 **释放**。
  - en:
      title: Creating Data In Memory
      content_markdown: |
        When we **instantiate** a **struct** in our code our program creates the associated field data side by side in memory.

        We instantiate by specifying all field values within 

        `StructName { ... }`.

        struct fields are accessed using a dot operator `.`.

        Memory details of our example:
        * The text inside the quotes is read only data (e.g. "ferris"), therefore it is 
          placed in *data memory region*
        * The function call `String::from` creates a struct `String` that is placed side 
          by side with the fields of SeaCreature in the *stack*. A String represents text that can be changed 
          and does this by:
          1. Creating memory on the *heap* for the text where it can be modified
          2. Storing a reference to that memory location on the *heap* and storing it in `String` 
          struct (More on this in future lessons) 
        * Finally our two friends *Ferris* and *Sarah* have data structures that will always have
          fixed locations in our program, so they are placed on the *stack*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crab%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22none%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20%7B%7D%20legs%2C%20and%20a%20%7B%7D%20weapon%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20and%20%7B%7D%20legs.%20They%20have%20no%20weapon..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
    fr:
      title: Création de donnée en mémoire
      content_markdown: |
        Lorsqu'on **instancie** une **structure** dans notre code, le programme
        crée les champs de données associés côte à côte en mémoire.

        On instancie une structure en spécifiant les champs dans des accolades.

        `StructName { ... }`.

        On accède aux champs de la structure avec l'opérateur `.`.

        Détail de la mémoire pour notre exemple:
        * Le texte à l'intérieur des guillemets est une donnée de lecture uniquement (e.g. "ferris"),
        celui-ci est donc placé dans la région *data memory*.
        * L'appel à la fonction `String::from` crée une structure `String` qui est placée en mémoire à côté
          des champs de la structure SeaCreature sur la pile. Un élément `String` représente un texte
          qui peut changer et cela est rendu possible en:
          1. Créant un emplacement sur le *tas* pour le texte où il pourra être modifié
          2. Stockant une référence vers cet emplacement de mémoire (sur le *tas*) et
          en stockant cette référence dans une structure `String` (sur la *pile*). Nous reparlerons
          de cela dans de futures leçons.
        * Finalement nos deux amis *Ferris* et *Sarah* ont des structures de données qui auront
          toujours une position fixe en mémoire et sont donc placés sur la pile.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20La%20structure%20SeaCreature%20est%20plac%C3%A9e%20sur%20la%20pile%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20La%20structure%20String%20est%20%C3%A9galement%20sur%20la%20pile%20mais%0A%20%20%20%20%20%20%20%20%2F%2F%20maintient%20une%20r%C3%A9f%C3%A9rence%20vers%20des%20donn%C3%A9es%20sur%20le%20tas%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crabe%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22pinces%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22poulpe%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22none%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20est%20un%20%7B%7D.%20Ces%20derniers%20poss%C3%A8dent%20%7B%7D%20bras%2C%20%7B%7D%20jambes%2C%0A%20%20%20%20%20%20%20%20et%20utilisent%20leurs%20%7B%7D%20comme%20arme.%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%0A%20%20%20%20%20%20%20%20ferris.animal_type%2C%0A%20%20%20%20%20%20%20%20ferris.arms%2C%0A%20%20%20%20%20%20%20%20ferris.legs%2C%0A%20%20%20%20%20%20%20%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20est%20un%20%7B%7D.%20Ces%20derniers%20poss%C3%A8dent%20%7B%7D%20bras%2C%20et%20%7B%7D%20jambes.%0A%20%20%20%20%20%20%20%20Ils%20ne%20sont%20pas%20%C3%A9quip%C3%A9s%20d%27armes...%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%0A%20%20%20%20%20%20%20%20sarah.animal_type%2C%0A%20%20%20%20%20%20%20%20sarah.arms%2C%0A%20%20%20%20%20%20%20%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
    de:
      title: Structs initialisieren
      content_markdown: |
        Wenn ein struct **instanziiert** wird, legt das Programm die Felder des structs Seite an Seite im Speicher an.

        Die Initialisierung erfolgt mit folgendem Syntax:

        `StructName { feld1, feld2, ... }`.

        Auf die Felder des structs werden mit einem `.` zugegriffen.

        In unserem Beispiel bedeutet das:
        * Text innerhalb der Anführungszeichen sind read-only Daten (z.B. "ferris"), daher sind sie
          in **data memory**
        * Der Funktionsaufruf `String::from` erstellt ein struct `String` das Seite an Seite der anderen
          Felder in `SeaCreature` auf den **stack** gelegt wird. Ein String repräsentiert (veränderbaren) Text,
          der...
          1. ... im **heap** angelegt wird und daher dort verändert werden kann,
          2. ... die Adresse (Referenz) zum Speicherstück im heap im `String` struct speichert
        * Nachdem unsere Freunde *Ferris* und *Sarah* Datenstrukturen sind, die in der main-Funktion
          erstellt wurden, werden diese auf den **stack** platziert.
    ie:
      title: Creation de Data in Memorie
      content_markdown: |
        Quande on **instantia** un **struct** in nor code, li programma crea li data por li camp relatet con it ye láteres in li memorie.

        Noi instantia per specificar omni camp-valores intra

        `StructNómine { ... }` .

        Accesse es dat al campes de un struct con li punctu-operator `.`.

        Detallies pri memorie in nor exemple:

        * Li textu intra li signes de citation es data quel es solmen leet (p.ex. "ferris"), e pro to es plazzat in li
        *region por data-memorie*
        * Li function-vocation `String::from` crea li struct `String` quel es plazzat lateralmen con li campes de CreaturaMarit 
        sur li *stack*. Un String representa textu changeabil, fante it possibil quam seque:
        1. Per crear memorie sur li *heap* por li textu ú it posse esser modificat
        2. Per aprovisionar un referentie a ti loc de memorie sur li *heap* e aprovisionar it in li struct `String` 
        (plu detallies pri to in lectiones a sequer)
        * In fine, nor amics *Ferris* e *Sarah* possede data-structuras queles sempre va haver locs fix in nor programma,
        e pro to es plazzat sur li *stack*.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20CreaturaMarin%20%7B%0A%20%20%20%20tip_de_animale%3A%20String%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Li%20data%20de%20CreaturaMarin%20es%20sur%20li%20stack%0A%20%20%20%20let%20ferris%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Anc%20li%20struct%20String%20es%20sur%20li%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20ma%20possede%20un%20referentie%20al%20data%20sur%20li%20heap%0A%20%20%20%20%20%20%20%20tip_de_animale%3A%20String%3A%3Afrom(%22crabe%22)%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%202%2C%0A%20%20%20%20%20%20%20%20jambes%3A%204%2C%0A%20%20%20%20%20%20%20%20arme%3A%20String%3A%3Afrom(%22griffe%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20tip_de_animale%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%208%2C%0A%20%20%20%20%20%20%20%20jambes%3A%200%2C%0A%20%20%20%20%20%20%20%20arme%3A%20String%3A%3Afrom(%22nullcos%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20es%20un%20%7B%7D.%20Ili%20have%20%7B%7D%20brasses%2C%20%7B%7D%20jambes%2C%20e%20es%20armat%20con%20un%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20ferris.nomine%2C%20ferris.tip_de_animale%2C%20ferris.brasses%2C%20ferris.jambes%2C%20ferris.arme%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20es%20un%20%7B%7D.%20Ili%20have%20%7B%7D%20brasses%2C%20e%20%7B%7D%20jambes.%20Ili%20have%20null%20armes..%22%2C%0A%20%20%20%20%20%20%20%20sarah.nomine%2C%20sarah.tip_de_animale%2C%20sarah.brasses%2C%20sarah.jambes%0A%20%20%20%20)%3B%0A%7D%0A
    ru:
      title: Создание структур
      content_markdown: |
        Когда мы **создаём экземпляр** структуры в коде, в памяти выделяется память для всех полей структуры.

        Создание екземпляра структуры выглядит так:

        `StructName { ... }`

        Мы указываем значения полей в фигурных скобках. Доступ к полям структуры происходит через оператор точку `.`.

        Подробности по примеру:
        * Текст внутри двойных скобок - это данные только для чтения (пример "ferris"), следовательно 
          он размещается в *data memory* регионе
        * Вызов функции `String::from` создает структуру `String`, которая размещается рядом с другими полями 
          структуры SeaCreature в *стеке*. `String` (строка) представляет текст, который может быть
          изменен и делает это так:
          1. Выделяет память в *куче* (heap) для текста (размер выделенной памяти в куче может увеличиваться и уменьшаться)
          2. Берет ссылку на выделенную память с *кучи* и сохраняет ее в `String` (больше в следующих занятиях)
        * Наши два друга *Феррис* и *Сара* имеют структуры данных, которые всегда будут иметь фиксированные
          местоположения в нашей программе, так как они расположены на *стеке*.
    es:
      title: Creación de Datos en Memoria
      content_markdown: |
        Cuando **instanciamos** una estructura **struct** en nuestro código, nuestro programa crea los datos asociados a cada campo uno al lado del otro en memoria.

        Para instanciar una estructura, especificaremos todos los valores de los campos dentro de 

        `StructName { ... }`.

        Los campos de una estructura se acceden mediante el operador de punto `.`.

        Detalles de memoria de nuestro ejemplo:
        * El texto dentro de las comillas es de sólo lectura de datos (por ejemplo, "ferris"), por lo tanto se
          coloca en la *región de memoria de datos*.
        * La llamada a la función `String::from` crea una estructura `String` que se coloca al lado de los campos
          de SeaCreature en la *pila*. Un string representa un texto que se puede modificar y lo hace de la siguiente manera: 
          1. Crea memoria en el montículo para el texto, donde se puede modificar.
          2. Guarda una referencia a esa ubicación de memoria en el montículo y lo almacena en la estructura `String` 
          (Nos centraremos en esto en futuras lecciones).
        * Finalmente nuestros amigos *Ferris* y *Sarah* tienen estructuras de datos que siempre tendrán
          ubicaciones fijas en nuestro programa, así que se colocan en la *pila*.
    pt-br:
      title: Criando Dados na Memória
      content_markdown: |
        Quando nós **instanciamos** uma **struct** no nosso código o programa cria os campos
        associados lado-a-lado na memória.

        Nós instanciamos uma estrutura especificando todos os valores dos campos dentro de

        `StructName { ... }`.

        Os campos são acessados usando o operador de ponto `.`.

        Detalhes da memória do nosso exemplo:
        * O texto dentro das aspas é somente leitura (por exemplo, "Ferris"), portanto é colocado
          na *região da memória de dados*
        * A chamada da função `String::from` cria uma struct `String` que é colocada lado-a-lado 
          com os campos de SeaCreature na *pilha*. Uma String representa um texto que pode ser 
          alterado e faz assim:
          1. Criando memória no *heap* para o texto onde ele pode ser modificado.
          2. Armazenando uma referência a esse local de memória no *heap* e armazenando-o no struct 
          `String` (mais a respeito em lições futuras)
        * Finalmente, nossos dois amigos *Ferris* e *Sarah* têm estruturas de dados que sempre terão
          locais fixos em nosso programa, portanto, eles são colocados na *pilha*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Os%20dados%20de%20SeaCreature%20est%C3%A3o%20na%20pilha%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20A%20struct%20da%20String%20tamb%C3%A9m%20est%C3%A1%20na%20pilha%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20mas%20mant%C3%A9m%20uma%20refer%C3%AAncia%20dos%20dados%20na%20heap%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22caranguejo%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22garra%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22polvo%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22nenhum%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%C3%A9%20um%20%7B%7D.%20Eles%20t%C3%AAm%20%7B%7D%20bra%C3%A7os%2C%20%7B%7D%20patas%2C%20e%20uma%20arma%20de%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%C3%A9%20um%20%7B%7D.%20Eles%20t%C3%AAm%20%7B%7D%20bra%C3%A7os%20e%20%7B%7D%20patas.%20Eles%20n%C3%A3o%20t%C3%AAm%20armas..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
    zh-cn:
      title: 在内存中创建数据
      content_markdown: |
        当我们在代码中 **实例化** 一个 **结构体** 时，我们的程序会在内存中并排创建关联的字段数据。

        当我们通过制定所有字段值的方式来实例化时：

        `结构体名 { ... }`.

        结构体字段可以通过 `.` 运算符来获取。

        我们例子的内存详情：
        * 引号内的文本是只读数据（例如“ferris”），因此它位于 *数据内存区*。
        * 函数调用 `String::from` 创建一个结构体 `String`，该结构体与 SeaCreature 的字段并排放置在 *栈* 中。
          字符串表示可以更改的文本通过：
          1. 在 *堆* 上创建可修改文本的内存。
          2. 将 *堆* 中存储对象的内存位置的引用存储在 `String` 结构体中(在以后的课程中会详细介绍)。
        * 最后，我们的两个朋友 *Ferris* 和 *Sarah* 有在程序中总是固定的位置的数据结构，所以它们被放在 *栈* 上。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%A0%88%E4%B8%8A%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%9F%E5%9C%A8%E6%A0%88%E4%B8%8A%EF%BC%8C%0A%20%20%20%20%20%20%20%20%2F%2F%20%E4%BD%86%E4%B9%9F%E5%AD%98%E6%94%BE%E4%BA%86%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%A0%86%E4%B8%8A%E7%9A%84%E5%BC%95%E7%94%A8%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22crab%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22octopus%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22none%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20%7B%7D%20legs%2C%20and%20a%20%7B%7D%20weapon%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20is%20a%20%7B%7D.%20They%20have%20%7B%7D%20arms%2C%20and%20%7B%7D%20legs.%20They%20have%20no%20weapon..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A
  - en:
      title: Tuple-like Structs
      content_markdown: |
        For conciseness, you can create structs that are used like a tuple.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20This%20is%20still%20a%20struct%20on%20a%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
    fr:
      title: Structures sous forme de n-uplet
      content_markdown: |
        Pour être concis, tu peux créer des structures qui s'utilisent comme des n-uplets (en anglais tuples).

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20On%20cr%C3%A9e%20une%20structure%20sur%20la%20pile%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
    de:
      title: Tuple-Structs
      content_markdown: |
        Eine verkürzte Schreibweiße bietet das Instanziieren von structs mittels von **Tupeln**.
    ie:
      title: Tuplic Structs
      content_markdown: |
        Por esser concis, on posse crear structs queles on usa quam un tuple.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Ti%20es%20ancor%20un%20struct%20sur%20un%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
    ru:
      title: Кортежи-структуры
      content_markdown: |
        Для краткости, вы можете создавать структуры, которые используются точно так же как кортежи (tuple).
    es:
      title: Estructuras en Forma de Tupla
      content_markdown: |
        Para ser concisos, puedes crear estructuras que se usan como una tupla
    pt-br:
      title: Estruturas em Tuplas
      content_markdown: |
        Para sermos concisos, você pode criar estruturas que são usadas em tupla.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Isto%20ainda%20%C3%A9%20uma%20estrutura%20em%20uma%20pilha%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
    zh-cn:
      title: 类元组结构体
      content_markdown: |
        简洁起见，你可以创建像元组一样使用的结构体。

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E8%BF%99%E4%BB%8D%E7%84%B6%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9C%A8%E6%A0%88%E4%B8%8A%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
  - en:
      title: Unit-like Structs
      content_markdown: |
        Structs do not have to have any fields at all.

        As mentioned in Chapter 1 a *unit* is another word for an empty tuple `()`. This is why this kind of struct is called *Unit-like*.

        This type of struct is rarely used.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A
    fr:
      title: Structures de type unitaire
      content_markdown: |
        Il n'est pas nécessaire que les structures possèdent des champs.

        Comme mentionné au Chapitre 1, une *unité* est une autre appellation pour un n-uplet vide `()`. 
        C'est pourquoi ce type de structure est dit *de type unitaire* (en anglais unit-like).

        Ce type de structure est rarement utilisé.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20On%20cr%C3%A9e%20une%20structure%20sur%20la%20pile%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A
    de:
      title: Unit-Structs
      content_markdown: |
        Structs müssen keine Felder enthalten.

        Wie in Kapitel 1 ist ein *unit* ein anderes Wort für ein leeres Tupel `()`. Daher werden diese structs auch *unit-like* (unit-ähnlich) genannt.

        Sowas wird allerdings nur selten verwendet.
    ie:
      title: Unitic Structs
      content_markdown: Structs in fact ne besona quelcunc campes in ili.

        Quam mentionat in Capitul 1 un *unit* es un altri metode por dir vacui tuple `()`. Pro to on nomina un tal struct
        *Unit-like* (unitic, unitesc).

        Tal structs es rarmen usat.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Ti%20es%20ancor%20un%20struct%20sur%20un%20stack%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0Av
    ru:
      title: Юнит-структуры
      content_markdown: |
        Структуры могут вовсе не иметь ни одного поля.

        Как было упомянуто в Главе 1, *юнит* - это то же самое, что и пустой кортеж `()`. Вот почему этот вид структур называют *юнит-структуры*.

        Этот тип не так распространен как остальные.
    es:
      title: Estructuras Tipo-Unitario
      content_markdown: |
        No es necesario que las estructuras tengan campos.

        Como ya se mencionó en el capítulo 1, una *unidad (unit)* es otra palabra para una tupla vacía `()`. Es por eso que este tipo de estructura se llama *de Tipo-Unitario*.

        Este tipo de estructura no es muy común.
    pt-br:
      title: Estruturas Tipo Unit
      content_markdown: |
        As estruturas não precisam ter nenhum campo.

        Como mencionado no capítulo 1, a *unit* é outra palavra para uma tupla vazia `()`. 
        É por isso que esse tipo de estrutura é chamado de *Unit-like*.

        Este tipo de estrutura raramente é usado.
    zh-cn:
      title: 类单元结构体
      content_markdown: |
        结构体也可以没有任何字段。

        就像第一章提到的，一个 *unit* 是空元组 `()` 的别称。这就是为什么，此类结构体被称为 `类单元`。

        这种类型的结构体很少用到。

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A
  - en:
      title: Enumerations
      content_markdown: |
        Enumerations allow you to create a new type that can have a value of several tagged elements using the `enum` keyword.

        `match` helps ensure exhaustive handling of all possible enum values making it a powerful tool in ensuring quality code.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20is%20a%20crab%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20is%20a%20octopus%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20is%20a%20fish%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20is%20a%20clam%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
    fr:
      title: Enumerations
      content_markdown: |
        Les énumerations permettent de créer un nouveau type dont la valeur
        ne peut prendre uniquement celle d'un ensemble de valeurs constantes.
        On crée une énumération avec le mot clé `enum`.

        `match` aide à s'assurer que l'on a traité tous les cas d'une énumération,
        ce qui en fait un outil puissant pour assurer le maintien de la qualité de code.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20cette%20ligne%20supprime%20les%20warnings%20du%20compilateur%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20est%20un%20crabe%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20est%20un%20poulpe%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20est%20un%20poisson%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20est%20une%20palourde%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
    de:
      title: Enumerations
      content_markdown: |
        Aufzählungen (enumerations) erlauben das Erzeugen eines neuen Typs, die nur eine fixe Liste an Werten zulassen.
        Die gültigen Werte werden mit dem `enum` Schlüsselwort eingeleitet.

        `enum` ist besonders im Zusammenhang mit `match` nützlich: da `match` exhaustive ist, versucht es den Programmierer darüber zu
        informieren, falls nicht alle möglichen Testfälle durchgegangen wurden.

        Versuche unser Beispielcode zum Laufen zu bringen. Welcher Fall wurde in `match` nicht berücksichtigt? Kannst du diesen noch einfügen?
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%2C%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22ferris%20is%20a%20crab%22)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22ferris%20is%20a%20octopus%22)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22ferris%20is%20a%20fish%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Enumerationes
      content_markdown: |

        Enumerationes possibilisa li creation de un nov tip quel usa li clave-parol `enum` e quel posse posseder li valore 
        de pluri marcat elementes.

        Con `match` on es assecurat tractar se con omni possibil valores del enum, fante it un potent utensile in li creation 
        de code de alt qualitá.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Specie%20%7B%0A%20%20%20%20Crabe%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Pisc%2C%0A%20%20%20%20Mollusco%2C%0A%7D%0A%0Astruct%20CreaturaMarin%20%7B%0A%20%20%20%20specie%3A%20Specie%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Li%20data%20de%20CreaturaMarin%20es%20sur%20li%20stack%0A%20%20%20%20let%20ferris%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Li%20struct%20String%20es%20anc%20sur%20li%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20ma%20possede%20un%20referentie%20de%20data%20sur%20li%20heap%0A%20%20%20%20%20%20%20%20specie%3A%20Specie%3A%3ACrabe%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%202%2C%0A%20%20%20%20%20%20%20%20jambes%3A%204%2C%0A%20%20%20%20%20%20%20%20arme%3A%20String%3A%3Afrom(%22griffe%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20%2F%2F%20Ci%20on%20usa%20match%20por%20comparar%20contra%20omni%20possibil%20%27brasse%27%20(arm)%20del%0A%20%20%20%20%2F%2F%20enum.%20Li%20compilator%20va%20incolerar%20se%20si%20on%20ne%20include%20omni%20possibil%0A%20%20%20%20%2F%2F%20brasses%20in%20li%20comparation.%0A%20%20%20%20match%20ferris.specie%20%7B%0A%20%20%20%20%20%20%20%20Specie%3A%3ACrabe%20%3D%3E%20println!(%22ferris%20es%20un%20crabe%22)%2C%0A%20%20%20%20%20%20%20%20Specie%3A%3AOctopus%20%3D%3E%20println!(%22ferris%20es%20un%20octopus%22)%2C%0A%20%20%20%20%20%20%20%20Specie%3A%3APisc%20%3D%3E%20println!(%22ferris%20es%20un%20pisc%22)%2C%0A%20%20%20%20%20%20%20%20Specie%3A%3AMollusco%20%3D%3E%20println!(%22ferris%20es%20un%20mollusco%22)%2C%0A%20%20%20%20%7D%0A%7D%0A

    ru:
      title: Перечисления
      content_markdown: |
        Перечисления `enum` позволяют вам создавать новый тип, который имеет одно определенное значение из 
        списка перечисленных вами возможных значений.
    es:
      title: Enumeraciones
      content_markdown: |
        Las enumeraciones permiten crear un nuevo tipo que puede tener un valor entre varios elementos etiquetados utilizando
        la palabra reservada `enum`.

        `match` ayuda a asegurar un manejo exhaustivo de todos los posibles valores del enumerado, convirtiéndolo en una
        herramienta muy útil para asegurar un código de calidad.
    pt-br:
      title: Enumerações
      content_markdown: |
        As enumerações permitem criar um novo tipo que pode conter o valor de vários elementos etiquetados
        usando a palavra-chave `enum`.

        O `match` ajuda a garantir o tratamento exaustivo de todos os valores possíveis de *enum*, tornando-o uma ferramenta poderosa para garantir um código de qualidade.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20esta%20linha%20evita%20avisos%20do%20compilador%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20caranguejo%22%2C%20ferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20polvo%22%2C%20ferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20peixe%22%2C%20ferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20%C3%A9%20um%20molusco%22%2C%20ferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
    zh-cn:
      title: 枚举
      content_markdown: |
        枚举允许你使用 `enum` 关键字创建一个新类型，该类型的值可以包含几个带标记的元素。

        `match` 有助于确保对所有可能的枚举值进行彻底的处理，使其成为确保高质量代码的强大工具。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22claw%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20is%20a%20crab%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20is%20a%20octopus%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20is%20a%20fish%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20is%20a%20clam%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Enumerations With Data
      content_markdown: |
        `enum` elements can also have one or more data types allowing them to behave like *union* from C.

        When an `enum` is pattern matched using `match`, you can bind a variable name to each data value.

        Memory details of `enum`:
        * An enum data value will have a memory size equal to its largest element. This allows for all potential values to fit in the same space of memory.
        * In addition to element data types (if any), each element also has a numeric value that represents which tag it is.

        Other details:
        * Rust's `enum` is something also known as a *tagged-union*
        * The combining of types to make a new type is what people mean when they say Rust has *algebraic types*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20some%20other%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D
    fr:
      title: Enumerations avec des données
      content_markdown: |
        Les éléments `enum` peuvent également avoir un ou plusieurs type de données
        ce qui les rend similaire au type *union* du language C.

        Lorsqu'une énumération est utilisée avec `match`, on peut lier un nom de variable à chaque valeur.

        Représentation des énumérations en mémoire:
        * La place mémoire qu'occupe un élément d'une énumération est égale à la taille de l'élément
        de l'énumération qui occupe le plus de place mémoire. Ce qui permet de remplacer un élément
        en mémoire par un autre sans avoir à redimensionner l'espace mémoire.
        * En plus du type de donnée de l'élément (s'il en a un), chaque élément possède une valeur
        numérique permettant d'identifier celui-ci.

        Autres détails:
        * Les énumérations de Rust sont également appelées *unions étiquetés* (en anglais tagged-unions).
        * La combinaison de types pour en créer un nouveau est ce à quoi quelqu'un fait référence
        lorsqu'il dit: Rust possède des types algébriques.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20cette%20ligne%20supprime%20les%20warnings%20du%20compilateur%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Les%20donn%C3%A9es%20de%20SeaCreature%20sont%20sur%20la%20pile%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20La%20structure%20String%20est%20%C3%A9galement%20sur%20la%20pile%0A%20%20%20%20%20%20%20%20%2F%2F%20mais%20maintient%20une%20r%C3%A9f%C3%A9rence%20vers%20une%20donn%C3%A9e%20sur%20le%20tas%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22grandes%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22petites%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20est%20un%20crabe%20avec%20%7B%7D%20%7B%7D%20pinces%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20est%20un%20crabe%20avec%20d%27autres%20armes%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20n%27est%20pas%20un%20crabe%22)%2C%0A%20%20%20%20%7D%0A%7D
    de:
      title: Enumerations mit Daten
      content_markdown: |
        `enum` Elemente können auch Daten (oder Felder) beinhalten, vergleichbar mit *unions* aus C (nicht der Arbeitergewerkschaft haha).

        Wenn ein `enum` in einem Fall im `match` übereinstimmt, können die Werte aus dem struct direkt an Variablen gebunden werden
        (im Beispiel in Zeile 32 zu sehen).

        Weitere Details zu `enum`:
        * Der Speicherbedarf eines enums entspricht dem des größten Elements (hier wäre `Claw` das größte Element).
        * Neben den Datentypen (sollte es welche geben) kann jedes Element mittels einer Zahl erreicht werden.

        Mehr Details!
        * `enum` ist in Rust auch bekannt als *tagged-union*.
        * Das Kombinieren von verschiedenen Typen wird in Rust auch als *algebraischer Typ* bezeichnet (eng. algebraic type).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0A%0A%2F%2F%20Claw%20has%20additional%20information%20about%20number%20of%20claws%20and%20size%0A%2F%2F%20Poison%20has%20additional%20information%20about%20the%20type%20of%20poison%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20number%20of%20claws%20and%20size%20is%20bound%20to%20the%20variables%20num_claws%20and%20size%0A%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Enumerationes con Data
      content_markdown: |
        Li elementes de `enum` posse haver un o plu data-tipes, quel es un poc simil a *union* in C.

        Quande on fa un pattern match (filtrage de mustres) con `match`, on posse ligar un nómine de variabile a chascun data-valore.

        Detallies pri `enum` in memorie:
        * Un data-valore por un enum va posseder un grandore egal a su max grand element. Con to, omni possibil valores 
        va posser intrar li sam loc de memorie.
        * Ultra le data-tipes de elementes (si ili trova se), chascun element have un valore numeric 
        quel representa su tag (marcation).

        Altri detallies:
        * `enum` in Rust es anc conosset quam un *tagged-union* (marcat union)
        * Li combination de tipes por crear un nov tip es li cose pri quel li gente parla quande ili di que Rust 
        possede *algebraic types*.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Specie%20%7B%20Crabe%2C%20Octopus%2C%20Pisc%2C%20Mollusco%20%7D%0Aenum%20TipVenen%20%7B%20Acidic%2C%20Dolorosi%2C%20Mortific%20%7D%0Aenum%20Grandore%20%7B%20Grand%2C%20Litt%20%7D%0Aenum%20Arme%20%7B%0A%20%20%20%20Griffe(i32%2C%20Grandore)%2C%0A%20%20%20%20Venen(TipVenen)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20CreaturaMarin%20%7B%0A%20%20%20%20specie%3A%20Specie%2C%0A%20%20%20%20nomine%3A%20String%2C%0A%20%20%20%20brasses%3A%20i32%2C%0A%20%20%20%20jambes%3A%20i32%2C%0A%20%20%20%20arme%3A%20Arme%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Li%20data%20de%20CreaturaMarin%20es%20sur%20li%20stack%0A%20%20%20%20let%20ferris%20%3D%20CreaturaMarin%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Anc%20li%20struct%20String%20es%20sur%20li%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20ma%20possede%20un%20referentie%20al%20data%20sur%20li%20heap%0A%20%20%20%20%20%20%20%20specie%3A%20Specie%3A%3ACrabe%2C%0A%20%20%20%20%20%20%20%20nomine%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20brasses%3A%202%2C%0A%20%20%20%20%20%20%20%20jambes%3A%204%2C%0A%20%20%20%20%20%20%20%20arme%3A%20Arme%3A%3AGriffe(2%2C%20Grandore%3A%3ALitt)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.specie%20%7B%0A%20%20%20%20%20%20%20%20Specie%3A%3ACrabe%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.arme%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Arme%3A%3AGriffe(num_griffes%2C%20grandore)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20descrition_de_grandore%20%3D%20match%20grandore%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Grandore%3A%3AGrand%20%3D%3E%20%22grand%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Grandore%3A%3ALitt%20%3D%3E%20%22litt%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20es%20un%20crabe%20con%20%7B%7D%20%7B%7D%20griffes%22%2C%20num_griffes%2C%20descrition_de_grandore)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20es%20un%20crabe%20con%20alquel%20altri%20arme%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20es%20alquel%20altri%20animale%22)%2C%0A%20%20%20%20%7D%0A%7D%0A

    ru:
      title: Перечисления с данными
      content_markdown: |
        Элементы `enum` также могут иметь один и больше типов данных (например, структуру или кортеж-структуру). 
        Это чем-то похоже на *union* с языка C.

        Когда `enum` сравнивается с серией шаблонов (или матчится, англ. is pattern matched), вы можете
        связать имя переменной к каждому значению или полю структуры.

        Как `enum` представлен в памяти:
        * Перечисление будет иметь размер, равный наибольшему из его элементов. Это позволяет всем потенциальным
          значениям вместиться в одну и ту же область памяти (без дополнительных выделений памяти).
        * Элементы перечисления имеют невидимый числовой тэг в дополнении к данным, что этот элемент уже и так несет.

        Еще немного информации:
        * `enum` Rust(а) иногда называют *типом-сумой* (tagged-union)
        * Комбинирование разных типов, чтобы создать новый тип - это то, что люди имеют ввиду, когда говорят, что
          Rust имеет *алгебраические типы*
    es:
      title: Enumeraciones con Datos
      content_markdown: |
        Los elementos de un `enum` también pueden tener uno o más tipos de datos que les permitan comportarse como *union* en C.

        Cuando un elemento `enum` se empareja con un patrón usando `match`, se puede vincular un nombre de variable a cada valor de datos.

        Detalles de memoria para `enum`:
        * Un valor de datos enum tendrá un tamaño de memoria igual a su elemento más grande. Esto permite que todos
        los potenciales valores quepan en el mismo espacio de memoria.
        * Además de los tipos de datos de los elementos (si los hay), cada elemento tiene también un valor numérico
        que representa qué etiqueta es.

        Otros detalles:
        * El `enum` de Rust también se conoce como *unión etiquetada* (tagged-union).
        * La combinación de tipos para hacer otros nuevos es a lo que nos referimos al decir que Rust tiene *tipos algebraicos*.
    pt-br:
      title: Enumerações com Dados
      content_markdown: |
        Os elementos `enum` também podem ter um ou mais tipos de dados permitindo que eles se comportem
        como o *union* da linguagem C.

        Quando um `enum` corresponde ao padrão usando `match`, você pode vincular um nome de variável 
        para cada valor de dados.

        Detalhes de memória do `enum`:
        * Um valor de dados *enum* terá um tamanho de memória igual ao seu maior elemento. Isso permite
          que todos os valores possíveis caibam no mesmo espaço de memória.
        * Além dos tipos de dados do elemento (se houver), cada elemento também possui um valor numérico 
          que representa qual etiqueta (tag) ele é.

        Outros detalhes:
        * O `enum` do Rust também é conhecido como *tagged-union*
        * A combinação de tipos para criar um novo tipo é a o que nos referimos quando dizemos que Rust 
          tem *tipos algébricos*.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20esta%20linha%20evita%20avisos%20do%20compilador%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20os%20dados%20de%20SeaCreature%20est%C3%A3o%20na%20pilha%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20A%20struct%20da%20String%20tamb%C3%A9m%20est%C3%A1%20na%20pilha%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20mas%20mant%C3%A9m%20uma%20refer%C3%AAncia%20dos%20dados%20na%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22grandes%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22pequenas%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22Ferris%20%C3%A9%20um%20caranguejo%20com%20%7B%7D%20garras%20%7B%7D%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22Ferris%20%C3%A9%20um%20caranguejo%20com%20outro%20tipo%20de%20arma%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22Ferris%20%C3%A9%20outro%20tipo%20de%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D
    zh-cn:
      title: 带数据的枚举
      content_markdown: |
        `enum` 的元素可以有一个或多个数据类型，从而使其表现得像C语言中的 *联合*。

        当使用 `match` 对 一个 `枚举` 进行模式匹配时，可以将变量名称绑定到每个数据值。

        `枚举` 的内存细节：
        * 枚举数据的内存大小等于它最大元素的大小。这允许所有可能的值都适合于相同的内存空间。
        * 除了元素数据类型(如果有的话)之外，每个元素还有一个数字值，表示它是哪个标签。

        其他细节：
        * Rust的 `枚举` 也被称为 *标签联合* (tagged-union)
        * 把类型组合成一种新的类型，这就是人们所说的 Rust 具有 *algebraic 类型* 的含义。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20this%20line%20prevents%20compiler%20warnings%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20SeaCreature's%20data%20is%20on%20stack%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20String%20struct%20is%20also%20on%20stack%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20holds%20a%20reference%20to%20data%20on%20heap%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22big%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22small%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ferris%20is%20a%20crab%20with%20%7B%7D%20%7B%7D%20claws%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20a%20crab%20with%20some%20other%20weapon%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ferris%20is%20some%20other%20animal%22)%2C%0A%20%20%20%20%7D%0A%7D
  - en:
      title: Chapter 3 - Conclusion
      content_markdown: |
        How exciting! We now have a the most basic tools for representing the form of our ideas in code. Hopefully now we 
        can see a glimmer of how Rust's fundamental operations work in harmony and conciseness with its types.  Next up we will talk about 
        a concept that gives our data types even more flexibility of representation: *generics*.
    fr:
      title: Chapitre 3 - Conclusion
      content_markdown: |
        Super! Nous possédons désormais les outils qu'il nous faut pour représenter nos idées avec du code. 
        Espérons que maintenant nous pouvons voir plus clairement comment les opérations fondamentales de Rust fonctionnent 
        en harmonie et de manière concise avec les types. Dans le prochain chapitre, nous parlerons d'un concept qui 
        donne à nos données encore plus de flexibilité dans leur représentation: la généricité.
    de:
      title: Kapitel 3 - Fazit
      content_markdown: |
        Wie aufregend! Wir haben jetzt das Werkzeug, womit wir unsere Ideen im Code repräsentieren können.
        Diese Einblicke in Rust's fundamentale Operationen und wie sie im Einklang zueinander stehen, sollte bei so manchen von euch
        hoffentlich einen Funken verursacht haben. Als nächstes wagen wir uns in noch mehr Flexibilität: den *generics*.
    ie:
      title: Capitul 3 - Conclusion
      content_markdown: |
        Quam excitant! Noi ja nu possede un tre basic utensilarium por representar li forme de nor idés in nor code. 
        Esperabilmen desde nu noi va posseder un poc aclaration pri qualmen li operationes fundamental in Rust labora junt 
        in harmonie e con concision con su tipes. A sequer noi va parlar pri un concept quel da nor data-types 
        mem plu flexibilitá e plu representation: *generics*.
    ru:
      title: Глава 3 - Заключение
      content_markdown: |
        Как здорово! Теперь у нас есть базовые инструменты для представления форм наших идей в коде. 
        Надеемся, что теперь мы можем увидеть проблеск того, как основные операции Rust работают в 
        гармонии и согласии с его типами. Далее мы поговорим о концепции, которая дает нашим типам данных 
        ещё большую гибкость представления: *дженерики* (шаблонные типы данных).
    es:
      title: Capítulo 3 - Conclusión
      content_markdown: |
        ¡Genial! Ahora tenemos las herramientas más básicas para representar nuestras ideas en código.
        Esperemos que ahora podamos ver un atisbo de cómo las operaciones fundamentales de Rust funcionan
        en armonía y concisión con sus tipos. A continuación hablaremos de un concepto que da a nuestros
        tipos de datos aún más flexibilidad de representación: *los genéricos*.
    pt-br:
      title: Capítulo 3 - Conclusão
      content_markdown: |
        Que legal! Agora temos as ferramentas mais básicas para representar as nossas idéias no código. 
        Esperamos que agora possamos ver como as operações fundamentais do Rust funcionam em harmonia
        e concisão com seus tipos. A seguir, falaremos sobre um conceito que oferece aos nossos tipos 
        de dados ainda mais flexibilidade de representação: *genéricos*.
    zh-cn:
      title: 第三章 - 总结
      content_markdown: |
        多么令人兴奋啊！现在我们有了一个最基本的工具，可以用代码来展示我们的想法。
        希望现在我们能看到 Rust 的基本操作是如何与它的类型和谐一致地工作的。
        接下来我们将讨论一个概念，它为我们的数据类型提供了更大的灵活性: *泛型*。
  - chapter: 4
    en:
      title: Chapter 4 - Generic Types
      content_markdown: |
        Generic types are incredibly important in Rust. They are used in the representation 
        of nullable values (i.e. variables which might not have a value yet), error handling, 
        collections, and more! In this section we will be learning about the foundational generic types 
        you will likely be using all the time.
    fr:
      title: Chapitre 4 - Types Génériques
      content_markdown: |
        Les types génériques sont incroyablement important avec Rust. Ils sont utilisés pour la représentation
        de valeurs potentiellement nulles (ex. variables qui n'a peut-être pas encore de valeurs), gestion d'erreurs, 
        collections, et plus! Dans cette section, nous allons découvrir les types génériques fondamentaux
        dont vous ne pourrez plus vous passer.
    ie:
      title: Capitul 4 - Tipes Géneric
      content_markdown: |
        Tipes géneric es íncredibilmen important in Rust. On usa les por representar valores nullabil
        (t.e. variabiles ancor ne possedent un valore), por tractar errores, colectiones e plu!
        In ti-ci section noi va aprender pri li fundamental tipes géneric queles tu va max possibilmen
        sempre utilisar.
    pt-br:
      title: Capítulo 4 - Tipos Genéricos
      content_markdown: |
        Tipos genéricos são incrivelmente importantes no Rust. Eles são usados na representação de 
        valores *null* (ou seja, variáveis que ainda não tenham um valor atribuído), tratamento de erros, 
        coleções e muito mais! Nesta seção aprenderemos sobre os tipos genéricos fundamentais que você
        provavelmente usará o tempo todo.
    zh-cn:
      title: 第四章 - 泛型
      content_markdown: |
        泛型在 Rust 中非常重要。它们用于表示可空值（即可能还没有值的变量）、错误处理、集合等等！
        在本章中，我们将学习你可能将会经常使用的的基本泛型。
    ru:
      title: Глава 4 - Обобщённые типы
      content_markdown: |
        Обобщённые типы очень важны в Rust. Они используются для представления значений, которые
        могут быть нулевыми (nullable), обработкой ошибок, коллекциями и другими! В этом разделе
        мы поговорим об основополагающих обобщённых типах, которые вы, вероятно, будете использовать
        постоянно.
    es:
      title: Capítulo 4 - Tipos Genéricos
      content_markdown: |
        Los tipos genéricos son muy importantes en Rust. Se utilizan en la representación de valores nulos,
        (es decir, variables que podrían no tener ningún valor todavía) en la gestión de errores, en las colecciones, etc.
        En este capítulo hablaremos sobre los tipos genéricos fundamentales que probablemente ya estés usando todo el tiempo.
  - en:
      title: What Are Generic Types?
      content_markdown: |
        Generic types allow us to partially define a `struct` or `enum`, enabling a compiler to create a fully 
        defined version at compile-time based off our code usage.

        Rust generally can infer the final type by looking at our instantiation, but if it needs help you 
        can always be explicit using the `::<T>` operator, also known by the name `turbofish` (he's a good friend of mine!).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20A%20partially%20defined%20struct%20type%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20item%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Note%3A%20by%20using%20generic%20types%20here%2C%20we%20create%20compile-time%20created%20types.%20%0A%20%20%20%20%2F%2F%20Turbofish%20lets%20us%20be%20explicit.%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%2042%20%7D%3B%0A%20%20%20%20let%20bool_bag%20%3D%20BagOfHolding%3A%3A%3Cbool%3E%20%7B%20item%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Rust%20can%20infer%20types%20for%20generics%20too!%0A%20%20%20%20let%20float_bag%20%3D%20BagOfHolding%20%7B%20item%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Note%3A%20never%20put%20a%20bag%20of%20holding%20in%20a%20bag%20of%20holding%20in%20real%20life%0A%20%20%20%20let%20bag_in_bag%20%3D%20BagOfHolding%20%7B%0A%20%20%20%20%20%20%20%20item%3A%20BagOfHolding%20%7B%20item%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20i32_bag.item%2C%20bool_bag.item%2C%20float_bag.item%2C%20bag_in_bag.item.item%0A%20%20%20%20)%3B%0A%7D%0A
    fr:
      title: Qu'est-ce que les types génériques?
      content_markdown: |
        Les types génériques permettent de définir partiellement une structure ou une énumération, laissant le compilateur
        créer une version parfaitement définie lors de la compilation du programme.

        Rust peut généralement inférer le type final en observant de quelle manière est faite l'instantiation. Si besoin,
        on peut explicitement utiliser l'opérateur `::<T>` pour spécifier le type,
        egalement appelé `turbofish` (c'est un bon ami à moi!).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Une%20structure%20partiellement%20d%C3%A9finie%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20item%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Note%3A%20en%20utilisant%20les%20types%20g%C3%A9n%C3%A9riques%2C%20nous%20cr%C3%A9ons%20des%20types%20qui%20%0A%20%20%20%20%2F%2F%20seront%20cr%C3%A9%C3%A9s%20lors%20de%20la%20compilation.%0A%20%20%20%20%2F%2F%20L'op%C3%A9rateur%20turbofish%20nous%20permet%20de%20pr%C3%A9ciser%20explicitement%20le%20type.%0A%20%20%20%20%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%2042%20%7D%3B%0A%20%20%20%20let%20bool_bag%20%3D%20BagOfHolding%3A%3A%3Cbool%3E%20%7B%20item%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Rust%20peut%20toutefois%20inf%C3%A9rer%20le%20type!%0A%20%20%20%20let%20float_bag%20%3D%20BagOfHolding%20%7B%20item%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Note%3A%20si%20vous%20%C3%AAtes%20un%20joueur%20de%20Donjons%20et%20Dragons%2C%20vous%20devriez%20savoir%0A%20%20%20%20%2F%2F%20que%20mettre%20un%20sac%20de%20ce%20type%20dans%20un%20autre%20du%20m%C3%AAme%20type%20est%20une%0A%20%20%20%20%2F%2F%20op%C3%A9ration%20risqu%C3%A9e.%0A%20%20%20%20let%20bag_in_bag%20%3D%20BagOfHolding%20%7B%0A%20%20%20%20%20%20%20%20item%3A%20BagOfHolding%20%7B%20item%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20i32_bag.item%2C%20bool_bag.item%2C%20float_bag.item%2C%20bag_in_bag.item.item%0A%20%20%20%20)%3B%0A%7D%0A
    ie:
      title: Quo es Tipes Géneric?
      content_markdown: |
        Tipes géneric possibilisa li partial definition de un `struct` o `enum`, con quel li compilator va posser
        crear un version completmen definat quande it compila se secun li code quel noi scri.

        Rust por li pluparte posse inferer li tip final per regardar nor instantiation, ma si it besona auxilie tu posse
        sempre esser plu explicit con li operator `::<T>`, anc conosset con li nómine `turbofish` (un pisc quel es un
        de mi bon amics!).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Un%20partialmen%20definit%20tip%20de%20un%20struct%0Astruct%20SacSinFunde%3CT%3E%20%7B%0A%20%20%20%20articul%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20A%20notar%3A%20per%20li%20usation%20ci%20de%20tipes%20g%C3%A9neric%2C%20noi%20crea%20tipes%20creat%20durant%0A%20%20%20%20%2F%2F%20li%20compilation%2C%20agrandante%20li%20grandore%20de%20nor%20code.%20Turbofish%20auxilia%20nos%0A%20%20%20%20%2F%2F%20esser%20explicit.%0A%20%20%20%20let%20sac_i32%20%3D%20SacSinFunde%3A%3A%3Ci32%3E%20%7B%20articul%3A%2042%20%7D%3B%0A%20%20%20%20let%20sac_bool%20%3D%20SacSinFunde%3A%3A%3Cbool%3E%20%7B%20articul%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Rust%20posse%20inferer%20tipes%20anc%20por%20g%C3%A9nerics!%0A%20%20%20%20let%20sac_quel_plana%20%3D%20SacSinFunde%20%7B%20articul%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20A%20notar%3A%20nequande%20plazzar%20un%20sac%20sin%20funde%20in%20un%20sac%20sin%20funde%20%0A%20%20%20%20%2F%2F%20in%20li%20ver%20vive%0A%20%20%20%20let%20sac_in_sac%20%3D%20SacSinFunde%20%7B%0A%20%20%20%20%20%20%20%20articul%3A%20SacSinFunde%20%7B%20articul%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20sac_i32.articul%2C%20sac_bool.articul%2C%20sac_quel_plana.articul%2C%20sac_in_sac.articul.articul%0A%20%20%20%20)%3B%0A%7D%0A
    pt-br:
      title: O Que São Tipos Genéricos?
      content_markdown: |
        Tipos genéricos nos permitem definir parcialmente uma `struct` ou `enum`, deixando que o 
        compilador instancie uma versão dela definida em tempo de compilação totalmente com base em
        nosso código.

        Geralmente o Rust pode inferir o tipo final observando a nossa instanciação, mas se ele precisar de
        ajuda você sempre pode ser explícito usando o operador `::<T>`, também conhecido pelo nome `turbofish`
        (ele é um bom amigo meu!).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Um%20tipo%20struct%20definido%20parcialmente%0Astruct%20Sacola%3CT%3E%20%7B%0A%20%20%20%20item%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Nota%3A%20usando%20tipos%20gen%C3%A9ricos%20aqui%20n%C3%B3s%20criamos%20tipos%20em%20tempo%20de%20compila%C3%A7%C3%A3o%0A%20%20%20%20%2F%2F%20fazendo%20o%20nosso%20c%C3%B3digo%20ficar%20maior.%20O%20turbofish%20nos%20permite%20ser%20expl%C3%ADcitos.%0A%20%20%20%20let%20i32_sacola%20%3D%20Sacola%3A%3A%3Ci32%3E%20%7B%20item%3A%2042%20%7D%3B%0A%20%20%20%20let%20bool_sacola%20%3D%20Sacola%3A%3A%3Cbool%3E%20%7B%20item%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20O%20Rust%20pode%20inferir%20os%20tipos%20para%20gen%C3%A9ricos%20tamb%C3%A9m!%0A%20%20%20%20let%20float_sacola%20%3D%20Sacola%20%7B%20item%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Nota%3A%20nunca%20coloque%20uma%20sacola%20dentro%20da%20outra%20na%20vida%20real%0A%20%20%20%20let%20sacola_na_sacola%20%3D%20Sacola%20%7B%0A%20%20%20%20%20%20%20%20item%3A%20Sacola%20%7B%20item%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20i32_sacola.item%2C%20bool_sacola.item%2C%20float_sacola.item%2C%20sacola_na_sacola.item.item%0A%20%20%20%20)%3B%0A%7D%0A
    zh-cn:
      title: 泛型是什么？
      content_markdown: |
        泛型允许我们部分定义一个 `结构体` 或 `枚举`，使编译器能够根据我们的代码使用情况，在编译时创建一个完全定义的版本。

        Rust 通常可以通过查看我们的实例化来推断出最终的类型，但是如果需要帮助，你可以使用 `::<T>` 操作符来显式地进行操作，
        该操作符也被称为 `turbofish` （他是我的好朋友！）。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20%E4%B8%80%E4%B8%AA%E9%83%A8%E5%88%86%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20item%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E6%B3%A8%E6%84%8F%EF%BC%9A%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E4%BA%86%E7%BC%96%E8%AF%91%E6%97%B6%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%BF%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%A4%A7%0A%20%20%20%20%2F%2F%20Turbofish%20%E4%BD%BF%E4%B9%8B%E6%98%BE%E5%BC%8F%E5%8C%96%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%2042%20%7D%3B%0A%20%20%20%20let%20bool_bag%20%3D%20BagOfHolding%3A%3A%3Cbool%3E%20%7B%20item%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Rust%20%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8E%A8%E6%96%AD%E5%87%BA%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%81%0A%20%20%20%20let%20float_bag%20%3D%20BagOfHolding%20%7B%20item%3A%203.14%20%7D%3B%0A%0A%20%20%20%20%2F%2F%20%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%9C%A8%E7%8E%B0%E5%AE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%EF%BC%8C%E4%B8%8D%E8%A6%81%E6%8A%8A%E4%B8%80%E8%A2%8B%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%94%BE%E5%9C%A8%E4%B8%80%E8%A2%8B%E7%9A%84%E4%B8%9C%E8%A5%BF%E9%87%8C%3A)%0A%20%20%20%20let%20bag_in_bag%20%3D%20BagOfHolding%20%7B%0A%20%20%20%20%20%20%20%20item%3A%20BagOfHolding%20%7B%20item%3A%20%22boom!%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20i32_bag.item%2C%20bool_bag.item%2C%20float_bag.item%2C%20bag_in_bag.item.item%0A%20%20%20%20)%3B%0A%7D%0A
    ru:
      title: Что такое Обобщённые типы?
      content_markdown: |
        Обобщённые типы позволяют частично определять `struct` или `enum`: компилятор создаст полностью 
        определенную версию во время компиляции, основываясь на использовании обобщенного типа.

        Обычно компилятор может вывести тип, увидев, в каком контексте мы его используем, но вы всегда можете
        явно указать тип для обобщенного типа с помощью оператора турбо-рыба `::<T>` (не бойтесь его).
    es:
      title: ¿Qué Son los Tipos Genéricos?
      content_markdown: |
        Los tipos genéricos nos permiten definir parcialmente una estructura (`struct`) o `enum`,
        permitiendo a un compilador crear una versión completamente definida en tiempo de compilación
        basada en el uso de nuestro código

        Por lo general, Rust puede inferir el tipo final mirando nuestra instanciación, pero si necesita
        ayuda siempre puede indicarlo usando el operador `::<T>`, también conocido con el nombre de `turbofish`.
  - en:
      title: Representing Nothing
      content_markdown: |
        In other languages, the keyword `null` is used to represent an absense of a value. It creates
        difficulty in programming languages because it creates the possibility that our program might fail 
        when interacting with a variable/field.

        Rust does not have `null`, but it is not ignorant of the importance of representing nothing! 
        Consider a naive representation using a tool we already know.

        This pattern of providing a `None` alternative representation for one or many alternate values is so 
        common Rust because of its lack of a `null` value. Generic types help solve this challenge.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventory(String)%2C%0A%20%20%20%20%2F%2F%20None%20represents%20the%20absence%20of%20an%20item%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20BagOfHolding%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A
    fr:
      title: Representation de valeurs nulles
      content_markdown: |
        Dans les autres languages, le mot-clé `null` est utilisé pour représenter l'abscence de valeur.
        Cela crée des difficultés dans les langages de programmation car il est possible que le programme
        s'arrête lorsque celui-ci essaie d'utiliser une valeur qui n'est pas présente.

        Rust ne possède pas le mot-clé `null`, mais n'ignore pas la nécessité de représenter l'abscence de valeur!
        Nous pouvons cependant créer une représentation naive en utilisant un outil que nous connaissons déjà.

        Ce pattern fournissant une représentation alternative `None` pour une ou plusieurs valeurs est très souvent utilisé.
        En effet Rust ne possède pas le mot-clé `null` comme dans les autres langages. Les types génériques peuvent cependant
        aider à résoudre ce problème.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventory(String)%2C%0A%20%20%20%20%2F%2F%20None%20repr%C3%A9sente%20l'absence%20d'%C3%A9l%C3%A9ment%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20BagOfHolding%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A
    ie:
      title: Representar Nullcos
      content_markdown: |
        In altri lingues, on usa li clave-parol `null` por representar li absentie de un valore. To crea 
        desfacilitás in lingues de programmation pro que it crea li possibilitá de fallition de nor programma 
        quande it interacte con un variabile/camp.

        Rust ne possede `null`, ma it conosse tre bon li importantie de posser representar nullcos!
        Lass nos considerar un representation naiv usante un utensile quel noi ja conosse.

        Ti-ci mustre quel provide un alternativ represantation usante `None` es tam comun in Rust pro su 
        manca de un valore `null`. Tipes géneric auxilia soluer ti-ci defí.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Articul%20%7B%0A%20%20%20%20Inventarie(String)%2C%0A%20%20%20%20%2F%2F%20None%20representa%20li%20absentie%20de%20un%20articul%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20SacSinFunde%20%7B%0A%20%20%20%20articul%3A%20Articul%2C%0A%7D%0A
    pt-br:
      title: Representando o Nada
      content_markdown: |
        Em outras linguagens, a palavra-chave `null` é usada para representar a ausência de um valor.
        Isso cria dificuldades nas linguagens de programação, porque possibilita que o nosso programa
        possa falhar ao interagir com uma variável/campo.

        O Rust não tem `null`, mas não ignora a importância de representar o *nada*! Considere uma
        representação ingênua usando uma ferramenta que já conhecemos.

        Esse padrão para fornecer uma representação alternativa ao `None` por um ou vários valores
        alternados é muito comum em Rust devido à falta de um valor `null`. Os tipos genéricos 
        ajudam a resolver esse desafio.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventario(String)%2C%0A%20%20%20%20%2F%2F%20None%20representa%20a%20aus%C3%AAncia%20de%20um%20item%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20Sacola%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A
    zh-cn:
      title: 表示空
      content_markdown: |
        在其他语言中，关键字 `null` 用于表示没有值。它给编程语言带来了困难，因为它使我们的程序在与变量字段交互时可能失败。

        Rust 没有 `null`，但它并不是不知道表示空的重要性！考虑使用一个我们已经知道的工具来朴素表示。

        这种为一个或多个替代值提供 `None` 替代表示的模式非常常见，因为它缺少 `null` 值。
        泛型类型有助于解决这一难题。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventory(String)%2C%0A%20%20%20%20%2F%2F%20None%20represents%20the%20absence%20of%20an%20item%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20BagOfHolding%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A
    ru:
      title: Представление ничего
      content_markdown: |
        В других языках ключевое слово `null` используется для обозначения отсутствия значения.
        Это ключевое слово может создавать проблемы, когда мы пытаемся использовать значение, но
        не проверяем `null` ли оно или нет.

        Rust не имеет `null`, но это не значит, что Rust игнорирует важность представления ничего!
        Рассмотрим наивную имплементацию с помощью `enum`.

        Паттерн предоставления альтернативного значения `None` или любых других так распространен в
        Rust, потому что в нём нет `null` значения. Обобщённые типы помогают решить эту ситуацию.
    es:
      title: Ausencia de Valor
      content_markdown: |
        En otros lenguajes de programación, la palabra reservada `null` se utiliza para representar la ausencia de valor.
        Esto crea ciertas dificultades en dichos lenguajes, ya que aparece la posibilidad de que nuestro programa falle al
        interactuar con una variable o campo.

        En Rust no hay `null`, pero eso no quiere decir que ignore la importancia de representar la ausencia de valor.
        Se puede representar usando herramientas que ya conocemos.

        Este patrón de proporcionar una alternativa nula `None` para uno o muchos valores alternativos es muy común en
        Rust debido a su falta de un valor `null`. Los tipos genéricos ayudan a resolver este desafío.
  - en:
      title: Option
      content_markdown: |
        Rust has a built in generic enum called `Option` that allows us to represent nullable values 
        without using `null`.

        ```
        enum Option<T> {
            None,
            Some(T),
        }
        ```

        This enum is so common, instances of the enum can be created anywhere with the keyword `Some` and `None`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20A%20partially%20defined%20struct%20type%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Our%20parameter%20type%20T%20can%20be%20handed%20to%20others%0A%20%20%20%20item%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Note%3A%20A%20bag%20for%20i32%2C%20holding%20nothing!%20We%20have%20to%20specify%20the%20type%0A%20%20%20%20%2F%2F%20because%20otherwise%20Rust%20would%20not%20know%20what%20type%20of%20bag%20it%20is.%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20nothing%20in%20the%20bag!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20something%20in%20the%20bag!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20something%20in%20the%20bag!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20nothing%20in%20the%20bag!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20match%20lets%20us%20deconstruct%20Option%20elegantly%20and%20ensure%20we%20handle%20all%20cases!%0A%20%20%20%20match%20i32_bag.item%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22found%20%7B%7D%20in%20bag!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22found%20nothing%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    fr:
      title: Option
      content_markdown: |
        Le langage Rust met à disposition une énumération générique `Option` qui permet de
        représenter des valeurs pouvant être nulles sans utiliser `null`.

        ```
        enum Option<T> {
            None,
            Some(T),
        }
        ```

        Ce type d'énumération est tellement commun qu'on peut créer une instance de cette énumération directement avec `Some` et `None`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Une%20structure%20partiellement%20d%C3%A9finie.%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Le%20param%C3%A8tre%20T%20sera%20d%C3%A9fini%20lors%20de%20l'instanciation%20de%20la%20structure.%0A%20%20%20%20item%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Note%3A%20La%20structure%20BagOfHolding%20contiendra%20%C3%A9ventuellement%20un%20%C3%A9l%C3%A9ment%0A%20%20%20%20%2F%2F%20de%20type%20i32%2C%20mais%20ne%20contient%20rien%20pour%20le%20moment!%0A%20%20%20%20%2F%2F%20Nous%20devons%20sp%C3%A9cifier%20le%20type%20car%20autrement%20Rust%20ne%20le%20conna%C3%AEtrait%20pas.%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22il%20n'y%20a%20rien%20dans%20le%20sac!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22il%20y%20a%20quelque%20chose%20dans%20le%20sac!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22il%20y%20a%20quelque%20chose%20dans%20le%20sac!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22il%20n'y%20a%20rien%20dans%20le%20sac!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Avec%20'match'%2C%20nous%20pouvons%20d%C3%A9construire%20notre%20'Option'%20%C3%A9l%C3%A9gamment%20et%0A%20%20%20%20%2F%2F%20s'assurer%20que%20nous%20prenions%20en%20compte%20tous%20les%20cas.%0A%20%20%20%20match%20i32_bag.item%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22il%20y%20%7B%7D%20dans%20le%20sac!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22le%20sac%20est%20vide%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Option
      content_markdown: |
        Rust possede ja un enum géneric nominat `Option` quel lassa nos posser representar valores nullabil
        sin li usation de `null.`

        ```
        enum Option<T> {
            None,
            Some(T),
        }
        ```

        Ti enum es tam frequent que on posse crear instanties de it úcunc con li clave-paroles `Some` e `None`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Un%20partialmen%20definit%20tip%20de%20un%20struct%0Astruct%20SacSinFunde%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Our%20parameter%20type%20T%20can%20be%20handed%20to%20others%0A%20%20%20%20articul%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20A%20notar%3A%20un%20sac%20por%20i32%2C%20possedente%20nullcos!%20Noi%20deve%20specificar%20li%20tip%0A%20%20%20%20%2F%2F%20pro%20que%20altrimen%20Rust%20ne%20vell%20saver%20pri%20quel%20tip%20de%20sac%20it%20acte%20se.%0A%20%20%20%20let%20sac_i32%20%3D%20SacSinFunde%3A%3A%3Ci32%3E%20%7B%20articul%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20sac_i32.articul.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20nequo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20alquo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20sac_i32%20%3D%20SacSinFunde%3A%3A%3Ci32%3E%20%7B%20articul%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20sac_i32.articul.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20alquo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Hay%20nequo%20in%20li%20sac!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20con%20match%20noi%20posse%20elegantmen%20deconstructer%20Option%20e%20esser%20cert%20que%0A%20%20%20%20%2F%2F%20omni%20casus%20es%20tractat!%0A%20%20%20%20match%20sac_i32.articul%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22Trovat%20%7B%7D%20in%20li%20sac!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22Nequo%20trovat%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    pt-br:
      title: Option
      content_markdown: |
        O Rust possui uma enumeração genérica embutida chamada `Option` que nos permite representar valores 
        nulos sem precisar usar o `null`.

        ```
        enum Option<T> {
            None,
            Some(T),
        }
        ```

        Essa enumeração é tão comum que as suas instâncias podem ser criadas em qualquer lugar com a 
        palavra-chave `Some` e `None`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Um%20tipo%20struct%20parcialmente%20definido%0Astruct%20Sacola%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Nosso%20par%C3%A2metro%20T%20pode%20ser%20entregue%20a%20outros%0A%20%20%20%20item%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Nota%3A%20Uma%20sacola%20para%20i32%2C%20contendo%20nada!%20Precisamos%20especificar%20o%20tipo%0A%20%20%20%20%2F%2F%20porque%20sen%C3%A3o%20o%20Rust%20n%C3%A3o%20saber%C3%A1%20qual%20o%20tipo%20que%20sacola%20%C3%A9.%0A%20%20%20%20let%20i32_sacola%20%3D%20Sacola%3A%3A%3Ci32%3E%20%7B%20item%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20i32_sacola.item.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22n%C3%A3o%20h%C3%A1%20nada%20na%20sacola!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tem%20alguma%20coisa%20na%20sacola!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i32_sacola%20%3D%20Sacola%3A%3A%3Ci32%3E%20%7B%20item%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20i32_sacola.item.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tem%20alguma%20coisa%20na%20sacola!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22n%C3%A3o%20h%C3%A1%20nada%20na%20sacola!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20match%20lets%20us%20deconstruct%20Option%20elegantly%20and%20ensure%20we%20handle%20all%20cases!%0A%20%20%20%20match%20i32_sacola.item%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22encontrei%20%7B%7D%20na%20sacola!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22n%C3%A3o%20encontrei%20nada%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    zh-cn:
      title: Option
      content_markdown: |
        Rust 有一个内置的泛型枚举叫做 `Option`，它可以让我们不使用 `null` 就可以表示可空值。

        ```
        enum Option<T> {
            None,
            Some(T),
        }
        ```

        这个枚举很常见，使用关键字 `Some` 和 `None` 可以在任何地方创建其实例。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20%E4%B8%80%E4%B8%AA%E9%83%A8%E5%88%86%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20%E6%88%91%E4%BB%AC%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8BT%E5%8F%AF%E4%BB%A5%E4%BC%A0%E9%80%92%E7%BB%99%E5%85%B6%E4%BB%96%0A%20%20%20%20item%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E6%B3%A8%E6%84%8F%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%94%BE%20i32%20%E7%9A%84%20bag%EF%BC%8C%E9%87%8C%E9%9D%A2%E4%BB%80%E4%B9%88%E9%83%BD%E6%B2%A1%E6%9C%89%EF%BC%81%0A%20%20%20%20%2F%2F%20%E6%88%91%E4%BB%AC%E5%BF%85%E9%A1%BB%E6%B3%A8%E6%98%8E%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%90%A6%E5%88%99%20Rust%20%E4%B8%8D%E7%9F%A5%E9%81%93%20bag%20%E7%9A%84%E7%B1%BB%E5%9E%8B%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20nothing%20in%20the%20bag!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20something%20in%20the%20bag!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20something%20in%20the%20bag!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22there's%20nothing%20in%20the%20bag!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20match%20%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%88%91%E4%BB%AC%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E6%9E%84%20Option%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%A1%AE%E4%BF%9D%E6%88%91%E4%BB%AC%E5%A4%84%E7%90%86%E4%BA%86%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%AF%E8%83%BD%E6%83%85%E5%86%B5%EF%BC%81%0A%20%20%20%20match%20i32_bag.item%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22found%20%7B%7D%20in%20bag!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22found%20nothing%22)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: Option
      content_markdown: |
        В Rust есть встроенный (из стандатной библиотеки) обобщённый тип `Option`, который допускает 
        нулевые значения без использования `null`.

        ```
        enum Option<T> {
            None,
            Some(T),
        }
        ```

        Это перечисление так распространено, что варианты этого перечисления могут использоваться везде: достаточно просто
        написать `Some` или `None`.
    es:
      title: Option
      content_markdown: |
        Rust tiene un enumerado genérico integrado llamado `Option` que nos permite representar
        valores nulos sin usar `null`.

        ```
        enum Option<T> {
            None,
            Some(T),
        }
        ```

        Este enum es tan común que se pueden crear instancias del enum en cualquier lugar con las
        palabras reservadas `Some` y `None`.
  - en:
      title: Result
      content_markdown: |
        Rust has a built in generic enum called `Result` that allows us to return a value that has the possibility of failing.
        It is the idiomatic way in which the language does error handling.

        ```
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        ```

        Note that our generics type has multiple *parameterized types* separated by a comma.

        This enum is so common, instances of the enum can be created anywhere with the keyword `Ok` and `Err`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20%2F%2F%20match%20lets%20us%20deconstruct%20Result%20elegantly%20and%20ensure%20we%20handle%20all%20cases!%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22found%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Error%3A%20%7B%7D%22%2Ce)%2C%0A%20%20%20%20%7D%0A%7D%0A
    fr:
      title: Result
      content_markdown: |
        Le langage Rust met à disposition une énumération générique `Result` qui permet de renvoyer une valeur qui a la possibilité d'échouer.
        C'est la façon idiomatique avec laquelle le language gère les erreurs.

        ```
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        ```

        Note que ce type générique a plusieurs *types paramétrés* séparés par une virgule.

        Cette énumération est très utilisée et on peut créer une instance avec les mots-clés `Ok` et `Err`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22ce%20n%27est%20pas%20le%20bon%20nombre%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20%2F%2F%20Avec%20%27match%27%2C%20nous%20pouvons%20d%C3%A9construire%20notre%20%27Result%27%20%C3%A9l%C3%A9gamment%20et%0A%20%20%20%20%2F%2F%20s%27assurer%20que%20nous%20prenions%20en%20compte%20tous%20les%20cas.%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22trouv%C3%A9%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Erreur%3A%20%7B%7D%22%2Ce)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ie:
      title: Result
      content_markdown: |
        Rust possede su propri enum géneric nominat `Result` (resultate) quel lassa nos posser retornar un valore quel posse fallir.
        To es li maniere idiomatic in ti lingue por tractar errores.

        ```
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        ```

        A notar que nor tip géneric possede pluri *tipes parametrisat* separat per commas.

        Ti enum es tam frequent que on posse crear instanties de it úcunc con li clave-paroles `Ok` e `Err`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20far_alquo_quel_posse_fallir(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22Li%20numer%C3%B3%20ne%20es%20just%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20far_alquo_quel_posse_fallir(12)%3B%0A%0A%20%20%20%20%2F%2F%20con%20match%20noi%20posse%20elegantmen%20deconstructer%20Result%20e%20tracter%20pri%0A%20%20%20%20%2F%2F%20omni%20possibil%20casus!%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22%7B%7D%20trovat%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Errore%3A%20%7B%7D%22%2C%20e)%2C%0A%20%20%20%20%7D%0A%7D%0A
    pt-br:
      title: Result
      content_markdown: |
        O Rust possui uma enumeração genérica chamada `Result` que nos permite retornar um valor que 
        tem a possibilidade de falhar.

        Esta é a maneira idiomática pela qual a linguagem faz a manipulação de erros.

        ```
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        ```

        Observe que os nosso tipos genéricos possuem vários *tipos parametrizados* separados por
        vírgula.

        Esta enumeração é tão comum que instâncias dela podem ser criadas em qualquer lugar com
        as palavras-chave `Ok` e `Err`.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20faz_alguma_coisa_que_pode_falhar(12)%3B%0A%0A%20%20%20%20%2F%2F%20o%20match%20nos%20permite%20desconstruir%20o%20Result%20elegantemente%20%0A%20%20%20%20%2F%2F%20e%20garante%20que%20lidemos%20com%20todos%20os%20casos!%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22encontrei%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Erro%3A%20%7B%7D%22%2C%20e)%2C%0A%20%20%20%20%7D%0A%7D%0A
    zh-cn:
      title: Result
      content_markdown: |
        Rust 有一个内置的泛型枚举叫做 `Result`，它可以让我们返回一个包含失败可能的值。
        这是编程语言进行错误处理的惯用方法。

        ```
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        ```

        注意我们的泛型有多个用逗号分隔的 *参数化的类型*。

        这个枚举很常见，使用关键字 `Ok` 和 `Err` 可以在任何地方创建其实例。
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20%2F%2F%20match%20%E8%AE%A9%E6%88%91%E4%BC%98%E9%9B%85%E5%9C%B0%E8%A7%A3%E6%9E%84%20Rust%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%A1%AE%E4%BF%9D%E6%88%91%E4%BB%AC%E5%A4%84%E7%90%86%E4%BA%86%E6%89%80%E6%9C%89%E6%83%85%E5%86%B5%EF%BC%81%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22found%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Error%3A%20%7B%7D%22%2Ce)%2C%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: Result
      content_markdown: |
        Rust имеет встроенное перечисление `Result` - оно позволяет вернуть значение или ошибку. 
        Это идиоматический способ обработки ошибок. 
        ```
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        ```

        Заметьте, что шаблонный тип имеет несколько **параметрезированых типов**, разделенных запятой.

        Это перечисленние так распространено, что его варианты можно использовать везде, просто написав
        `Ok` или `Err`.
    es:
      title: Result
      content_markdown: |
        Rust tiene  un enumerado genérico integrado llamado `Result` que nos permite devolver un
        valor que puede dar error. Es la forma que este lenguaje tiene de gestionar los errores.

        ```
        enum Result<T, E> {
            Ok(T),
            Err(E),
        }
        ```

        Ten en cuenta que nuestro tipo genérico tiene múltiples *tipos parametrizados* separados
        por una coma.

        Este enum es tan común que se pueden crear instancias del enum en cualquier lugar con las
        palabras reservadas `Ok` y `Err`.
  - en:
      title: Failable Main
      content_markdown: |
        `main` has the capability of returning a `Result`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Main%20returns%20no%20value%2C%20but%20could%20return%20an%20error!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22found%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20handle%20this%20error%20gracefully%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20return%20a%20new%20error%20from%20main%20that%20said%20what%20happened!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22something%20went%20wrong%20in%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Notice%20we%20use%20a%20unit%20value%20inside%20a%20Result%20Ok%0A%20%20%20%20%2F%2F%20to%20represent%20everything%20is%20fine%0A%20%20%20%20Ok(())%0A%7D%0A
    fr:
      title: main retourne une erreur
      content_markdown: |
        `main` a la capacité de retourner une structure `Result`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22ce%20n%27est%20pas%20le%20bon%20nombre%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20main%20ne%20retourne%20pas%20de%20valeur%20mais%20peut%20retourner%20une%20erreur!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22trouv%C3%A9%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20On%20traite%20cette%20erreur%20gracieusement.%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Retourne%20une%20nouvelle%20erreur%20depuis%20%27main%27%20avec%20un%20message%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20d%27explication!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22quelque%20chose%20s%27est%20mal%20pass%C3%A9%20%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20dans%20le%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Notes%20qu%27on%20utilise%20une%20valeur%20unitaire%20avec%20%27Ok%27%0A%20%20%20%20%2F%2F%20pour%20siginifier%20que%20tout%20va%20bien.%0A%20%20%20%20Ok(())%0A%7D%0A
    ie:
      title: Un Main Fallibil
      content_markdown: |
        Anc `main` posse retornar un `Result`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20far_alquo_quel_posse_fallir(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22Li%20numer%C3%B3%20ne%20es%20just%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20Main%20retorna%20null%20valore%2C%20ma%20posse%20retornar%20un%20errore!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20far_alquo_quel_posse_fallir(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22%7B%7D%20trovat%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20tractar%20ti-ci%20errore%20gracilmen%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20retornar%20un%20nov%20errore%20de%20main%20quel%20informar%20pri%20quo%20ha%20evenit!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22alquo%20fals%20ha%20evenit%20in%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20A%20notar%20que%20noi%20usa%20in%20valore%20unit%20intra%20un%20Result%20Ok%0A%20%20%20%20%2F%2F%20por%20monstrar%20que%20omnicos%20standa%20bon%0A%20%20%20%20Ok(())%0A%7D%0A
    pt-br:
      title: Main Falível
      content_markdown: |
        O `main` tem a capacidade de retornar um `Result`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20o%20Main%20n%C3%A3o%20retorna%20um%20valor%2C%20mas%20pode%20retornar%20um%20erro!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20faz_alguma_coisa_que_pode_falhar(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22encontrei%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20lida%20com%20o%20erro%20normalmente%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20retorna%20um%20novo%20erro%20do%20main%20que%20nos%20informa%20o%20que%20houve!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22alguma%20coisa%20deu%20errado%20em%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Observe%20que%20usamos%20um%20valor%20unit%20dentro%20de%20um%20Result%20Ok%0A%20%20%20%20%2F%2F%20para%20representar%20que%20est%C3%A1%20tudo%20bem%0A%20%20%20%20Ok(())%0A%7D%0A
    zh-cn:
      title: 可失败的主函数
      content_markdown: |
        `main` 函数有可以返回 `Result` 的能力！
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%8D%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E4%BD%86%E5%8F%AF%E8%83%BD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%EF%BC%81%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22found%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E4%BC%98%E9%9B%85%E5%9C%B0%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E8%AF%B4%E6%98%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E7%9A%84%E6%96%B0%E9%94%99%E8%AF%AF%EF%BC%81%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22something%20went%20wrong%20in%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20Notice%20we%20use%20a%20unit%20value%20inside%20a%20Result%20Ok%0A%20%20%20%20%2F%2F%20to%20represent%20everything%20is%20fine%0A%20%20%20%20Ok(())%0A%7D%0A
    ru:
      title: Возврат результата в Main
      content_markdown: |
        Функция `main` может возвращать `Result`!
    es:
      title: Main Fallido
      content_markdown: |
        `main` tiene la capacidad de devolver un valor del enumerado `Result`
  - en:
      title: Graceful Error Handling
      content_markdown: |
        `Result` is so common that Rust has a powerful operator `?` for working with them. These two statements are equivalent:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
            Ok(v) => v,
            Err(e) => return Err(e),
        }
        ```

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20Look%20at%20how%20much%20code%20we%20saved!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42)%3F%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
    fr:
      title: Gestion élégante des erreurs
      content_markdown: |
        `Result` est tellement commun que Rust possède l'opérateur `?` qui lui est associé. Ces deux bout de code sont équivalent:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
            Ok(v) => v,
            Err(e) => return Err(e),
        }
        ```

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22ce%20n%27est%20pas%20le%20bon%20nombre%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20Regarde%20comme%20le%20code%20est%20plus%20concis%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42)%3F%3B%0A%20%20%20%20println!(%22trouv%C3%A9%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
    ie:
      title: Gracil Tractation de Errores
      content_markdown: |
        `Result` es tam frequent que Rust possede li potent operator `?` por tractar con ili. Ti du declarationes es egal:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
            Ok(v) => v,
            Err(e) => return Err(e),
        }
        ```
    pt-br:
      title: Manipulação de Erros Elegantes
      content_markdown: |
        O `Result` é tão comum que o Rust tem o poderoso operador `?` para trabalhar com ele. 
        Estas duas declarações são equivalentes:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
            Ok(v) => v,
            Err(e) => return Err(e),
        }
        ```

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20Olha%20quanto%20c%C3%B3digo%20n%C3%B3s%20salvamos!%0A%20%20%20%20let%20v%20%3D%20faz_alguma_coisa_que_pode_falhar(42)%3F%3B%0A%20%20%20%20println!(%22encontrei%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
    zh-cn:
      title: 优雅地错误处理
      content_markdown: |
        `Result` 如此常见至于 Rust 有个强大的操作符 `?` 来配合它。
        以下两表达式相等：

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
            Ok(v) => v,
            Err(e) => return Err(e),
        }
        ```

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20%E7%9C%8B%E7%9C%8B%E6%88%91%E4%BB%AC%E8%8A%82%E7%9C%81%E4%BA%86%E5%A4%9A%E5%B0%91%E4%BB%A3%E7%A0%81%EF%BC%81%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42)%3F%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
    ru:
      title: Элегантная обработка ошибок
      content_markdown: |
        `Result` так часто встречается что в Rust есть могущественный оператор `?`. Эти две конструкции одинаковы:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
            Ok(v) => v,
            Err(e) => return Err(e), // возврат из функции
        }
        ```
    es:
      title: Gestionar Errores de Forma Elegante
      content_markdown: |
        `Result` es tan común que Rust cuenta con el operador `?` para trabajar con él.
        Estas dos afirmaciones son equivalentes:

        ```
        do_something_that_might_fail()?
        ```

        ```
        match do_something_that_might_fail() {
            Ok(v) => v,
            Err(e) => return Err(e),
        }
        ```
  - en:
      title: Ugly Option/Result Handling
      content_markdown: |
        Working with `Option`/`Result` can be tedious when you are just trying to write some quick code.  Both `Option` and `Result` have a 
        function called `unwrap` that can be useful for getting a value in a quick and dirty manner.  `unwrap` will:
         
        1. Get the value inside Option/Result
        2. If the enum is of type None/Err, `panic!`

        These two pieces of code are equivalent:

        ```
        my_option.unwrap()
        ```

        ```
        match my_option {
            Some(v) => v,
            None => panic!("some error message generated by Rust!"),
        }
        ```

        Similarly:

        ```
        my_result.unwrap()
        ```

        ```
        match my_result {
            Ok(v) => v,
            Err(e) => panic!("some error message generated by Rust!"),
        }
        ```

        Be a good rustacean and properly use `match` when you can!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20concise%20but%20assumptive%20and%20gets%20ugly%20fast%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20will%20panic!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(1).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A

    fr:
      title: Gestion peu élégante de Option/Result
      content_markdown: |
        Utiliser `Option` et `Result` peut être fastidieux lorsqu'on souhaite rapidement écrire du code.
        `Option` et `Result` ont tout les deux une fonction appelé `unwrap` qui permet d'obtenir une
        valeur de manière rapide mais peu élégante.
        `unwrap` va:
          
         1. Renvoyer la valeur de notre Option ou Result
         2. Faire 'paniquer' le code si la valeur de l'énumération est de type None ou Err. Lorsqu'un
         programme Rust panique, il envoie un message d'erreur et s'arrête.

         Ces deux bout de code sont équivalent

         ```
         my_option.unwrap()
         ```

         ```
         match my_option {
             Some(v) => v,
             None => panic!("un message d'erreur généré par Rust!"),
         }
         ```

         De même:

         ```
         my_result.unwrap()
         ```

         ```
         match my_result {
             Ok(v) => v,
             Err(e) => panic!("un message d'erreur généré par Rust!"),
         }
         ```

         Tu doit être un bon rustacien et utiliser `match` comme il faut et quand tu peux.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22ce%20n%27est%20pas%20le%20bon%20nombre%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20Concis%20mais%20suppose%20qu%27une%20valeur%20est%20pr%C3%A9sente%20et%20le%20code%20%0A%20%20%20%20%2F%2F%20peut%20vite%20devenir%20illisible.%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42).unwrap()%3B%0A%20%20%20%20println!(%22trouv%C3%A9%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Le%20programme%20affichera%20le%20mesage%20d%27erreur%20et%20s%27arr%C3%AAtera%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(1).unwrap()%3B%0A%20%20%20%20println!(%22trouv%C3%A9%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A

    ie:
      title: Desbell Tractation de Errores
      content_markdown: |
        Sempre usar `Option`/`Result` posse devenir íncomod quande on simplicmen vole scrir un poc code. Ambi `Option` e `Result`
        have un metode nominat `unwrap` (aperter) quel es comod por strax obtenir un valore ma con un poc desbellesse. `unwrap` va:

        1. trovar li valore intra Option/Result
        2. si li valore es de tip None/Err, `panic`!

        Ti du pezzes de code es egal:

        ```
        mi_option.unwrap()
        ```

        ```
        match mi_option {
          Some(v) => v,
          None => panic!("alquel erra-missage generat de Rust!")
        }
        ```

        Similmen:

        ```
        mi_result.unwrap()
        ```

        ```
        match mi_result {
          Ok(v) => v,
          Err(e) => panic!("alquel erra-missage generat de Rust!")
        }
        ```

        Esse un bon Rustaceane e usa `match` sempre quande tu posse!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20far_alquo_quel_posse_fallir(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22Li%20numer%C3%B3%20ne%20es%20just!%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20concis%20ma%20basat%20pri%20assumptiones%20e%20strax%20desbell%0A%20%20%20%20let%20v%20%3D%20far_alquo_quel_posse_fallir(42).unwrap()%3B%0A%20%20%20%20println!(%22%7B%7D%20trovat%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20to-ci%20va%20generar%20un%20panic!%0A%20%20%20%20let%20v%20%3D%20far_alquo_quel_posse_fallir(1).unwrap()%3B%0A%20%20%20%20println!(%22%7B%7D%20trovat%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A
    pt-br:
      title: Manipulação de Option/Erros Deselegante
      content_markdown: |
        Trabalhar com `Option`/`Result` pode ser entediante quando você está apenas tentando escrever
        um código rápido. Tanto `Option` quanto `Result` têm uma função chamada `unwrap` que pode ser
        útil para obter um valor de maneira rápida e *feia*. `unwrap` irá:
         
        1. Obter o valor de Option/Result
        2. Se a enumeração for do tipo None/Err, `panic!`

        Esses dois trechos de código são equivalentes:

        ```
        my_option.unwrap()
        ```

        ```
        match my_option {
            Some(v) => v,
            None => panic!("alguma mensagem de erro gerada pelo Rust!"),
        }
        ```

        Similarmente:

        ```
        my_result.unwrap()
        ```

        ```
        match my_result {
            Ok(v) => v,
            Err(e) => panic!("alguma mensagem de erro gerada pelo Rust!"),
        }
        ```

        Seja um bom rustáceo e use `match` apropriadamente quando puder!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20faz_alguma_coisa_que_pode_falhar(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22este%20n%C3%A3o%20%C3%A9%20o%20n%C3%BAmero%20correto%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20conciso%2C%20mas%20pretencioso%20e%20falha%20r%C3%A1pido%0A%20%20%20%20let%20v%20%3D%20faz_alguma_coisa_que_pode_falhar(42).unwrap()%3B%0A%20%20%20%20println!(%22encontrei%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20erro%20de%20panic!%0A%20%20%20%20let%20v%20%3D%20faz_alguma_coisa_que_pode_falhar(1).unwrap()%3B%0A%20%20%20%20println!(%22encontrei%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A
    zh-cn:
      title: 丑陋的 Option/错误处理
      content_markdown: |
        当你只是试图写一些快速的代码时，`Option`/`Result` 可能是乏味的。
        `Option` 和 `Result` 都有一个名为 `unwrap` 的函数，这个函数可以快速而粗略地获取值。
        `unwrap` 会：

        1. 获取 Option/Result 内部的值
        2. 如果枚举的类型是 None/Err， `panic!`

        这两块代码是相等的：

        ```
        my_option.unwrap()
        ```

        ```
        match my_option {
            Some(v) => v,
            None => panic!("some error message generated by Rust!"),
        }
        ```

        类似的：

        ```
        my_result.unwrap()
        ```

        ```
        match my_result {
            Ok(v) => v,
            Err(e) => panic!("some error message generated by Rust!"),
        }
        ```

        做个好 rustacean，正确使用 `match`!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22this%20is%20not%20the%20right%20number%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20%E7%AE%80%E6%B4%81%E4%BD%86%E5%81%87%E8%AE%BE%E6%80%A7%E5%BC%BA%EF%BC%8C%E8%80%8C%E4%B8%94%E5%BE%88%E5%BF%AB%E5%B0%B1%E4%BC%9A%E5%8F%98%E5%BE%97%E4%B8%91%E9%99%8B%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20%E8%BF%99%E4%BC%9A%20panic!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(1).unwrap()%3B%0A%20%20%20%20println!(%22found%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A
    ru:
      title: \"Грязная\" обработка Option/Result
      content_markdown: |
        Обрабатывать каждый `Option`/`Result` может быть очень утомительным, когда вы всего-то хотите
        написать немного кода по-быстрому. `Option` и `Result` имеют метод `unwrap`, который полезен,
        когда Вам нужно по-быстрому достать значение.

        `unwrap` работает так:

        1. Получить значение из `Option`/`Result`
        2. Если оно было `None`/`Err`, 'panic!' 

        Эти два блока кода эквивалентны:

        ```
        my_option.unwrap()
        ```

        ```
        match my_option {
            Some(v) => v,
            None => panic!("some error message generated by Rust!"),
        }
        ```

        Соответственно:

        ```
        my_result.unwrap()
        ```

        ```
        match my_result {
            Ok(v) => v,
            Err(e) => panic!("some error message generated by Rust!"),
        }
        ```

        Будь хорошим rustacean и используй `match`, где это необходимо!
    es:
      title: Gestionar Errores Option y Result de Forma Poco Elegante
      content_markdown: |
        Al escribir código rápido, puede que trabajar con `Option`/`Result` sea un fastidio. Tanto
        `Option` como `Result` tienen una función llamada `unwrap` que puede ser útil para obtener
        un valor de manera rápida pero poco elegante. `unwrap` puede:
         
        1. Obtener el valor dentro de Option/Result. 
        2. Si la lista es del tipo None/Err, `panic!`

        Estos dos fragmentos de código son equivalentes:

        ```
        my_option.unwrap()
        ```

        ```
        match my_option {
            Some(v) => v,
            None => panic!("some error message generated by Rust!"),
        }
        ```

        De igual manera:

        ```
        my_result.unwrap()
        ```

        ```
        match my_result {
            Ok(v) => v,
            Err(e) => panic!("some error message generated by Rust!"),
        }
        ```

        ¡Sé un buen Rustacean y usa `match` siempre que puedas!
  - en:
      title: Vectors
      content_markdown: |
        Some of the most useful generic types are collection types. A vector is a variably sized list of items
        represented by the struct `Vec`.

        The macro `vec!` lets us easily create a vector rather than manually constructing one.

        `Vec` has the method `iter()` which creates an iterator from a vector, allowing us to easily
        put a vector into a `for` loop.

        Memory Details:
        * `Vec` is a struct, but internally it contains a reference to a fixed list of its items on the heap.
        * A vector starts with a default capacity, when more items are added than it has capacity for, it 
          reallocates its data on the heap to have a new fixed list with large capacity.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20We%20can%20be%20explicit%20with%20type%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbofish%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20But%20look%20how%20clever%20Rust%20is%20about%20determining%20the%20type%20automatically%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20That's%20a%20beautiful%20macro!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Hello%22)%2C%20String%3A%3Afrom(%22World%22)%5D%3B%0A%0A%20%20%20%20for%20word%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20word)%3B%0A%20%20%20%20%7D%0A%7D%0A

    fr:
      title: Vecteurs
      content_markdown: |
        Les types génériques les plus utiles sont les collections. Un vecteur est une liste de taille variable
        et est représenté par la structure `Vec`.

        La macro `vec!` permet de créer facilement un vecteur au lieu d'avoir à le construire manuellement.

        `Vec` possède la méthode `iter()` qui crée un itérateur à partir d'un vecteur, permettant de parcourir les éléments de celui-ci dans une boucle `for`.

        Détails de la mémoire:
        * `Vec` est une structure qui contient une référence vers une liste fixe de ses éléments sur le tas.
        * Un vecteur est créé avec une capacité par défaut. Lorsque qu'on souhaite ajouter de nouveaux éléments et
        qu'il n'y a pas la capacité suffisante, Rust réaffecte les données sur le tas de telle sorte à avoir une nouvelle
        taille fixe et une capacité supérieure.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20On%20peut%20%C3%AAtre%20explicite%20avec%20le%20type.%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbofish%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20Mais%20regarde%20%C3%A0%20quel%20point%20Rust%20est%20intelligent%20et%20peut%0A%20%20%20%20%2F%2F%20automatiquement%20d%C3%A9terminer%20le%20type.%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20C%27est%20une%20jolie%20macro!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Hello%22)%2C%20String%3A%3Afrom(%22World%22)%5D%3B%0A%0A%20%20%20%20for%20word%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20word)%3B%0A%20%20%20%20%7D%0A%7D%0A

    ie:
      title: Vectors
      content_markdown: |
        Li tipes por colectiones es un del max util tipes géneric. Un vector es un variabilmen mesurat 
        liste de articules representat per li struct `Vec`.

        Li macro `vec!` lassa nos facilmen crear un vector vice crear un manualmen.

        `Vec` have li metode `iter()` quel crea un iterator de un vector, con quel noi posse facilmen
        plazzar un vector in un loop `for`.

        Detallies pri memorie:
        * `Vec` es un struct, ma internmen it contene un referentie a un fix liste de su articules sur li heap.
        * Un vector comensa con un capacitá decidet, ma quande on adjunte coses a it queles superpassa su capacitá, it
        realoca li data sur li heap por haver un nov liste fix con un plu grand capacitá
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Noi%20posse%20esser%20explicit%20pri%20tipes%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbopisc%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20Ma%20vide%20quam%20inteligent%20es%20Rust%20pri%20automaticmen%20determinar%20li%20lip%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20Quam%20bell%20macro!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Salute%22)%2C%20String%3A%3Afrom(%22Munde%22)%5D%3B%0A%0A%20%20%20%20for%20parol%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20parol)%3B%0A%20%20%20%20%7D%0A%7D%0A

    pt-br:
      title: Matrizes
      content_markdown: |
        Alguns dos tipos genéricos mais úteis são os tipos de coleção. Uma matriz é uma lista de itens 
        de tamanho variável representada pela estrutura `Vec`.

        A macro `vec!` nos permite criar facilmente uma matriz ao invés de contruir uma manualmente.

        `Vec` possui o método `iter()` o qual cria um iterador a partir de uma matriz, permitindo-nos 
        facilmente usr uma matriz em um loop `for`.

        Detalhes da Memória:
        * `Vec` é um struct, mas internamente contém uma referência a uma lista fixa de seus itens no heap.
        * Uma matriz começa com uma capacidade padrão. Quando são adicionados mais itens do que a capacidade
          inicial, ele realoca seus dados no heap para ter uma nova lista fixa com capacidade maior.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Podemos%20ser%20expl%C3%ADcitos%20com%20o%20tipo%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbofish%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20Veja%20qu%C3%A3o%20esperto%20o%20Rust%20%C3%A9%20determinando%20o%20tipo%20automaticamente%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20Olha%20que%20macro%20linda!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Ol%C3%A1%22)%2C%20String%3A%3Afrom(%22Mundo%22)%5D%3B%0A%0A%20%20%20%20for%20word%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20word)%3B%0A%20%20%20%20%7D%0A%7D%0A
    zh-cn:
      title: Vectors
      content_markdown: |
        一些经常使用的泛型是集合类型。一个 vector 是可变长度的元素集合，以结构体 `Vec` 表示。

        宏 `vec!` 让我们可以轻松的创建 vector，而不是手动构造一个。

        `Vec` 有一个函数 `iter()` 可以从一个 vector 创建一个迭代器，这允许我们轻松的将一个 vector 放到一个 `for` 循环中。

        内存细节：
        * `Vec` 是一个结构体，但是内部其实保存了在堆上固定长度数据的引用。
        * 一个 vector 开始有默认大小容量，当更多的元素被添加进来后，它会重新在堆上分配一个新的有更大大小的固定容量。（类似 C++ 的vector）
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E6%98%BE%E5%BC%8F%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbofish%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20%E4%BD%86%E6%98%AF%E7%9C%8B%E7%9C%8B%20Rust%20%E6%98%AF%E5%A4%9A%E4%B9%88%E8%81%AA%E6%98%8E%E7%9A%84%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%E5%95%8A%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20%E8%BF%99%E4%B8%AA%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%AE%8F%EF%BC%81%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22Hello%22)%2C%20String%3A%3Afrom(%22World%22)%5D%3B%0A%0A%20%20%20%20for%20word%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20word)%3B%0A%20%20%20%20%7D%0A%7D%0A
    ru:
      title: Векторы
      content_markdown: |
        Одни из самых полезных обобщённых типов - это коллекции. Структура `Vec` - это вектор, динамически изменяемый 
        массив.

        С помощью макроса `vec!` можно удобно создавать векторы, перечисляя его элементы. 

        `Vec` имеет метод `iter()`, который создаёт итератор по элементам вектора, а итератор можно 
        легко использовать в цикле `for`.

        Внутренности вектора:
        * `Vec` это структура, а внутри она содержит ссылку на массив фиксированной длины в куче.
        * При создании, вектор имеет вместимость по умолчанию. Когда в него добавляются элементы, а 
        его вместимость уже закончилось, он переалоцирует массив на куче с большей вместимостью, чем была.
    es:
      title: Vectores
      content_markdown: |
        Algunos de los tipos genéricos más útiles son los tipos de colección. Un vector es una lista de
        tamaño variable de elementos representados por la estructura `Vec`.

        La macro `vec!` nos permite crear fácilmente un vector en lugar de construirlo manualmente.

        `Vec` tiene el método `iter()` que crea un iterador a partir de un vector, permitiéndonos poner
        fácilmente un vector en un bucle `for`.

        Detalles de memoria:
        * `Vec` es una estructura, pero internamente contiene una referencia a una lista fija de sus
        elementos en el montículo.
        * Un vector comienza con una capacidad por defecto, cuando se añaden más elementos de los que
        tiene capacidad, reasigna sus datos en el montículo para tener una nueva lista fija con más capacidad.
  - en:
      title: Chapter 4 - Conclusion
      content_markdown: |
        In one chapter we've learned how much power generic types give us! Don't worry if you don't 
        know fully how to use everything, right now it's just good to be aware of the major ideas you will
        see again and again in code. Our functions are getting quite lengthy! In our next chapter we will 
        spend talk about an important concept in Rust: data ownership.

    fr:
      title: Chapitre 4 - Conclusion
      content_markdown: |
        Dans un seul chapitre, nous avons découvert la puissance des types génériques! Ne t'inquiète pas si tu ne
        sais pas parfaitement comment utiliser tout ce que nous venons de voir. Pour le moment il suffit de retenir les
        principales idées, nous n'avons pas fini de les revoir encore et encore. Nos fonctions deviennent assez longues!
        Dans notre prochain chapitre, nous allons parler d'un concept important dans
        Rust: la possession des données (ownership).

    ie:
      title: Capitul 4 - Conclusion
      content_markdown: |
        In un sol capitul noi ha aprendet pri li potentie quel li tipes géneric da nos! Ne sucia te si tu ancor
        ne save qualmen usar omnicos. Por li moment, it es plu important solmen esser conscient pri li grand
        idés queles tu va vider denov e denov in code. Nor functiones ha tam agrandat se! In li capitul a sequer
        noi va transpassa li tot capitul per discusser qualmen passar data inter functioner por que noi mey posser
        vider li detallies e devenir plu clar pri qualmen Rust regarda memorie.
    pt-br:
      title: Capítulo 4 - Conclusão
      content_markdown: |
        Em um capítulo aprendemos quanta força os tipos genéricos nos dão! Não se preocupe se você não 
        souber como usar tudo, porque agora é bom estar ciente das principais idéias que você verá 
        repetidas vezes no código. Nossas funções estão ficando muito longas! No próximo capítulo,
        falaremos sobre um conceito importante no Rust: propriedade de dados.
    zh-cn:
      title: 第四章 - 总结
      content_markdown: |
        在这一章中，我们了解了泛型类型给我们带来的强大功能！如果你不完全知道如何使用所有的泛型功能，
        不要担心，现在最好了解您将在代码中反复看到的主要思想。我们的函数变得相当大了！
        在下一章中，我们将讨论 Rust 中的一个重要概念：数据所有权。
    ru:
      title: Глава 4 - Заключение
      content_markdown: |
        За одну главу мы узнали, как много силы нам дают обобщённые типы! Не волнуйтесь, если Вы не 
        знаете, как это все применить. На данном этапе, Вам нужно только быть внимательным к идеям, 
        которые Вы увидете ещё много раз. Наши функции становятся слегка громоздкие! В следующей 
        главе мы поговорим о важном концепте в Rust: владение.
    es:
      title: Capítulo 4 - Conclusión
      content_markdown: |
        En sólo un capítulo hemos aprendido el poder de los tipos genéricos. No te preocupes si no sabes completamente
        cómo usarlo todo, ahora mismo es bueno ser consciente de las principales ideas que verás una y otra vez en el código.
        ¡Nuestras funciones se están haciendo bastante largas! En el próximo capítulo hablaremos de un concepto importante de
        Rust: pertenencia de datos.
  - chapter: 5
    en:
      title: Chapter 5 - Ownership & Borrowing Data
      content_markdown: |
        Rust has a unique paradigm for managing memory compared to other programming languages. We're going to look at
        the behaviors and validations of the compiler one by one so it's not overwhelming. It's important to remember that 
        ultimately the rules we show don't exist to make your life hard, but to help you make your code less error-prone!
    fr:
      title: Chapitre 5 - Propriété et emprunt de données
      content_markdown: |
        Comparé aux autres langages de programmation, Rust possède un paradigme unique en ce qui concerne
        la gestion de la mémoire. Nous allons nous intéresser aux comportements et aux validations du compilateur
        un par un pour être sûr de bien comprendre. Il est important de garder à l'esprit qu'au bout du compte,
        les règles que nous allons voir ne sont pas là pour te compliquer la vie, mais pour éviter que ton code
        ne soit truffé d'erreurs!
    ie:
      title: Capitul 5 - Proprietá e Pruntation de Data
      content_markdown: |
        Rust possede un dessine unic por gerer memorie quel es diferent quam altri lingues de programmation. Noi va regardar
        chascun conduida e validation del compilator poc a poc por que on ne mey esser aplastat per it. It es important a
        memorar que in fine ti regules ne existe por far li vive plu dur, ma in contrari por far tui code minu erraci!
    pt-br:
      title: Capítulo 5 - Propriedade & Empréstimo de Dados
      content_markdown: |
        O Rust possui um paradigma singular para gerenciar a memória em comparação a outras linguagens
        de programação. Vamos analisar os comportamentos e validações do compilador, um por um, para que
        os conceitos não sejam muito pesados. É importante lembrar que, no fim das contas, as regras
        que mostramos não existem para dificultar sua vida, mas para ajudá-lo a tornar seu código menos
        propenso a erros!
    ru:
      title: Глава 5 - Владение и Заимствование данными
      content_markdown: |
        Rust использует уникальную парадигму для управления памятью по сравнению с другими языками 
        программирования. Мы посмотрим на поведение компилятора и то, как он проверяет код 
        постепенно, иначе Вы рискуете быть ошеломлены. Важно понимать, что все эти правила существуют
        не для того, чтобы сделать Вашу жизнь сложнее, а для того, чтобы предотвратить широкий спектр 
        ошибок.
  - en:
      title: Ownership
      content_markdown: |
        Instantiating a type and **binding** it to a variable name creates a memory resource that the Rust compiler will validate
        through its whole **lifetime**.  The bound variable is called the resource's **owner**.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20We%20instantiate%20structs%20and%20bind%20to%20variables%0A%20%20%20%20%2F%2F%20to%20create%20memory%20resources%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20the%20owner%0A%7D%0A
    fr:
      title: Propriété (en anglais ownership)
      content_markdown: |
        L'instanciation d'un type et le fait de lier (en anglais **binding**) la ressource à une variable crée
        une ressource mémoire que le compilateur Rust validera pendant toute sa durée de vie (en anglais **lifetime**).
        La variable liée devient le propriétaire (en anglais **owner**) de la ressource.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Nous%20instancions%20une%20structure%20et%20l%27attachons%20%C3%A0%20une%20variable%0A%20%20%20%20%2F%2F%20pour%20cr%C3%A9er%20les%20ressources%20n%C3%A9cessaires%20en%20m%C3%A9moire%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20devient%20le%20propri%C3%A9taire%20(owner)%20de%20la%20ressource%0A%7D%0A
    ie:
      title: Proprietá (ownership)
      content_markdown: |
        Instantiar un tip e ligar (**binding**) it a un nómine de un variabile crea un ressurse de memorie quel li compilator de Rust
        va validar durant su tot vive-témpor (**lifetime**). Li ligat variabile es nominat li "proprietario" (**owner**) de it.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Noi%20instantia%20structs%20e%20liga%20a%20variabiles%0A%20%20%20%20%2F%2F%20por%20crear%20ressurses%20de%20memorie%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20es%20li%20proprietario%0A%7D%0A
    pt-br:
      title: Propriedade
      content_markdown: |
        Instanciar um tipo e **vinculá-lo** a um nome de variável cria um recurso de memória que o compilador Rust validará por toda sua a **vida útil**. A variável vinculada é chamada de **proprietária** do recurso.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Instanciamos%20structs%20e%20vinculamos%20a%20vari%C3%A1veis%0A%20%20%20%20%2F%2F%20para%20criar%20recursos%20de%20mem%C3%B3ria%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20o%20propriet%C3%A1rio%0A%7D%0A
    ru:
      title: Владение
      content_markdown: |
        Создание объекта типа и **связывание** (binding) его с именем переменной создаёт ресурс в памяти, который будет
        валидироваться на протяжении всего своего **времени жизни** (lifetime). Такую переменную называют **владельцем**
        ресурса (в данном случае объекта типа).
  - en:
      title: Scope-Based Resource Management
      content_markdown: |
        Rust uses the last place of usage or end of function scope as the place to deconstruct and deallocate a resource.

        The term for this deconstruction and deallocation is called a **drop**.

        Memory detail:
        * Rust does not have garbage collection.
        * This is also called Resource Aquisition Is Initialization ( RAII ) in C++.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20it's%20no%20longer%0A%20%20%20%20%2F%2F%20used%20to%20after%20this%20location%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%20because%20of%20the%20end%0A%20%20%20%20%2F%2F%20of%20the%20function%20scope%0A%7D%0A
    fr:
      title: Management des ressources basé sur la portée (en anglais scope)
      content_markdown: |
        Rust prend en compte le dernier endroit où une variable a été utilisée ainsi
        que la fin de la portée de la fonction pour déconstruire et désallouer une ressource.

        On dira pour cette déconstruction et désallocation que la variable est "jetée" (en anglais **dropped**).

        Détails de la mémoire:
        * Rust ne possède pas de ramasse-miettes (en anglais garbage collector).
        * Cela est également connu sous le nom de RAII (l'acquisition d'une ressource est une initialisation) en C ++.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20%2F%2F%20la%20variable%20foo_a%20est%20jet%C3%A9e%20ici%20car%20elle%20n'est%20%0A%20%20%20%20%2F%2F%20plus%20utilis%C3%A9e%20apr%C3%A8s%20cet%20endroit%20du%20code%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20la%20variable%20foo_b%20est%20jet%C3%A9e%20ici%20car%20la%20port%C3%A9e%0A%20%20%20%20%2F%2F%20de%20la%20fonction%20prend%20fin%0A%7D%0A
    ie:
      title: Gerentie de Ressurses Basat sur Cadre (Scope)
      content_markdown: |
        Rust usa li final loc de usation o li fine del cadre de un function quam li loc por deconstructer e dealocar 
        un ressurse. On nomina ti deconstruction e dealocation un "cade" (**drop**).

        Detallies pri memorie:
        * Rust ne possede jettallia-colection (garbage collection).
        * Tis qui save C++ va conosser ti concepte quam Resource Aquisition Is Initialization ( RAII ).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20%2F%2F%20foo_a%20cade%20ci%20pro%20que%20on%20ne%20plu%20usa%20it%0A%20%20%20%20%2F%2F%20pos%20ciloc%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20cade%20ci%20pro%20que%20it%20es%20li%20fine%0A%20%20%20%20%2F%2F%20del%20cadre%20del%20function%0A%7D%0A
    pt-br:
      title: Gerenciamento de Recursos Baseado em Escopo
      content_markdown: |
        O Rust usa o último local de utilização ou o final do escopo da função para desconstruir e desalocar um recurso.

        O termo para esta descontrução e desalocação é chamado **descarte** (ou *drop*).

        Detalhes da memória:
        * O Rust não tem garbage collection.
        * Também conhecido por Aquisição de Recursos é Inicialização (sigla RAII,
          em inglês) em C++.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20%2F%2F%20foo_a%20%C3%A9%20descartado%20aqui%20porque%20n%C3%A3o%20%C3%A9%20mais%0A%20%20%20%20%2F%2F%20usado%20depois%20deste%20lugar%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20%C3%A9%20descartado%20aqui%20porque%20%C3%A9%20o%20fim%0A%20%20%20%20%2F%2F%20do%20escopo%20da%20fun%C3%A7%C3%A3o%0A%7D%0A
    ru:
      title: Управление ресурсами на основе области видимости
      content_markdown: |
        Rust использует последнее место использования или конец области видимости функции в качестве места, где делает
        свою работу деконструктор и деалоцируется ресурс.

        Термин для обозначения деконструктора и деалокации — **drop**. 

        Тонкости памяти:
        * В Rust нет сборщика мусора
        * Это может быть знакома Вам как идиома RAII (Resource Aquisition Is Initialization) из С++
  - en:
      title: Dropping is Hierarchical
      content_markdown: |
        When a struct is dropped, the struct itself is dropped first then it's children are dropped individually and so on.

        Memory Details:
        * By automatically freeing memory Rust helps ensure that there are less memory leaks 
        * Memory resources can only be dropped once.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20first%0A%20%20%20%20%2F%2F%20then%20foo.bar%20is%20dropped%0A%7D%0A
    fr:
      title: La déconstruction et désallocation est hiérarchique
      content_markdown: |
        Lorsqu'une structure est jetée (déconstruite et désallouée), la structure elle-même est jetée en première puis
        on jete ses enfants un par un et ainsi de suite.

        Détails de la mémoire:
        * En libérant automatiquement la mémoire, Rust aide à s'assurer qu'il y a moins de fuites de mémoire.
        * Les ressources mémoire ne peuvent être déconstruites et désallouées qu'une seule fois.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo%20est%20jet%C3%A9%20en%20premier%2C%0A%20%20%20%20%2F%2F%20vient%20ensuite%20le%20tour%20de%20foo.bar%0A%7D%0A
    ie:
      title: On Cade Secun Hierarchie
      content_markdown: |
        Quande un struct es lassat cader, su elementes infantal cade in prim.
        Detallies pri memorie:
        * Li automatic liberation memorie in Rust auxilia in esser cert que minu memorie-fugida va evenir
        * Ressurses de memorie posse cader solmen un vez.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo.bar%20cade%20in%20prim%0A%20%20%20%20%2F%2F%20pos%20quel%20anc%20foo%20cade%0A%7D%0A
    pt-br:
      title: O Descarte é Hierárquico
      content_markdown: |
        Quando uma estrutura é descartada, a estrutura em si é descartada primeiro,
        depois os filhos são descartados individualmente e assim por diante.

        Detalhes da Memória:
        * Ao liberar automaticamente a memória, o Rust ajuda a garantir que haja menos
          vazamentos de memória.
        * Os recursos de memória só podem ser descartados uma vez.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20descartado%20primeiro%0A%20%20%20%20%2F%2F%20e%20s%C3%B3%20ent%C3%A3o%20foo.bar%20%C3%A9%20descartado%0A%7D%0A
    ru:
      title: Drop по иерархии
      content_markdown: |
        Когда структура drop'ается, в начале происходит drop этой структуры, а потом её детей по очереди и так далее.  

        Тонкости памяти:
        * Автоматически очищая память, Rust помогает уменьшить количество утечек памяти
        * Ресурсы должны быть drop'нуты только один раз!
  - en:
      title: Moving Ownership
      content_markdown: |
        When a owner is passed as an argument to a function, ownership is moved to the function parameter.

        After a **move** the variable in the original function can no longer be used.

        Memory details:
        * During a **move** the stack memory of the owners value is copied to the function call's parameter stack memory.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20is%20moved%20to%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20can%20no%20longer%20be%20used%0A%7D%0A
    fr:
      title: Transfert de propriétaire
      content_markdown: |
        Lorsqu'une ressource est passée en argument d'une fonction, le propriétaire de cette ressource devient le paramètre de la fonction.

        Après cela, la variable passée en argument ne peut plus être utilisée, car la variable a été déplacée.

        Détails de la mémoire:
        * Lors du transfert de propriétaire, les éléments de la pile concernant la variable à déplacer sont copié sur la pile du paramètre de la fonction appelée.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20est%20jet%C3%A9%20(d%C3%A9construit%20et%20d%C3%A9sallou%C3%A9)%20ici%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20foo%20est%20d%C3%A9plac%C3%A9%20vers%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20ne%20peut%20plus%20%C3%AAtre%20utilis%C3%A9%0A%7D%0A
    ie:
      title: Transferentie de Proprietá
      content_markdown: |
        Quande li proprietario es passat quam un argument a un function, li proprietá move se al parametre del function.
        Pos un **move** on ne plu posse usar li variabile in li function original.
        Detallies pri memorie:
        * Durant un **move** li memorie sur li stack del valore del proprietario es copiat al memorie stack del parametre 
        del vocator del function.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20cade%20ci%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20transfere%20se%20a%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20on%20ne%20plu%20posse%20usar%20foo%0A%7D%0A
    pt-br:
      title: Movendo a Propriedade
      content_markdown: |
        Quando um proprietário é passado como argumento para uma função, a propriedade é movida para o parâmetro da função.

        Após um **movimento**, a variável na função original não pode mais ser usada.

        Detalhes da memória:
        * Durante uma **movimentação**, a memória da pilha do proprietário do valor é copiada para a memória da pilha dos parâmetros da função chamada.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20faz_alguma_coisa(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20%C3%A9%20descartado%20aqui%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20movido%20para%20faz_alguma_coisa%0A%20%20%20%20faz_alguma_coisa(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20n%C3%A3o%20pode%20mais%20ser%20usado%0A%7D%0A
    ru:
      title: Передача владения
      content_markdown: |
        Когда владелец ресурса используется в качестве аргумента функции, владение передаётся параметру
        этой функции. 

        После **передачи** (move) переменной, начиная с того места, где мы её передали, переменную больше нельзя
        использовать.

        Тонкости памяти:
        * **Передача** или **move** копирует память со стека владельца в стек параметров функции.
  - en:
      title: Returning Ownership
      content_markdown: |
        Ownership can also be returned from a function.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20ownership%20is%20moved%20out%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20becomes%20the%20owner%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20because%20of%20end%20of%20function%20scope%0A%7D%0A

    fr:
      title: Retourner la propriété d'une ressource
      content_markdown: |
        Une fonction peut retourner la propriété d'une ressource.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20Le%20propri%C3%A9taire%20de%20la%20structure%20Foo%20d%C3%A9m%C3%A9nage%0A%20%20%20%20%2F%2F%20%C3%A0%20l'ext%C3%A9rieur%20de%20la%20fonction.%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20devient%20le%20nouveau%20propri%C3%A9taire.%0A%20%20%20%20%2F%2F%20foo%20est%20jet%C3%A9%20(d%C3%A9construit%20et%20d%C3%A9sallou%C3%A9)%20ici%20car%20la%20port%C3%A9e%20de%20la%20%0A%20%20%20%20%2F%2F%20fonction%20main%20se%20termine.%0A%7D%0A

    ie:
      title: Retornar Proprietá
      content_markdown: |
        On posse anc retornar proprietá tra un function.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20li%20propriet%C3%A1%20exea%20ci%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20deveni%20li%20proprietario%0A%20%20%20%20%2F%2F%20foo%20cade%20pro%20que%20it%20es%20li%20fine%20del%20cadre%20del%20function%0A%7D%0A
    pt-br:
      title: Retornando a Propriedade
      content_markdown: |
        A propriedade também pode ser retornada de uma função.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20a%20propriedade%20%C3%A9%20retornada%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20se%20torna%20o%20propriet%C3%A1rio%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20descartado%20por%20causa%20do%20fim%20do%20escopo%20da%20fun%C3%A7%C3%A3o%0A%7D%0A
    ru:
      title: Возвращение владения
      content_markdown: |
        Владение также может быть возвращено с функции.
  - en:
      title: Borrowing Ownership with References
      content_markdown: |
        References allow us borrow access to a resource with the `&` operator.

        References are also dropped like other resources.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
    fr:
      title: S'approprier une ressource avec des références.
      content_markdown: |
        Les références nous permettent d'emprunter l'accès à une ressource grâce à l'opérateur `&`.

        Les références sont également jetées (déconstruites et désallouées) comme les autres ressources.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20et%20foo%20sont%20jet%C3%A9s%20ici%0A%7D%0A
    ie:
      title: Pruntar Proprietá con Referenties
      content_markdown: |
        Con referenties noi posse prunta accesse a un ressurse con li operator `&`.

        Referenties cade in Rust just quam omni altri ressurses.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20cade%20ci%0A%20%20%20%20%2F%2F%20foo%20cade%20ci%0A%7D%0A
    pt-br:
      title: Emprestando Propriedade com Referências
      content_markdown: |
        As referências nos permitem emprestar o acesso a um recurso com o operador `&`.

        As referências também são descartadas do mesmo jeito que os outros recursos.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20%C3%A9%20descartado%20aqui%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20descartado%20aqui%0A%7D%0A
    ru:
      title: Заимствование у владельца с помощью ссылок
      content_markdown: |
        Ссылки позволяют нам заимствовать доступ к ресурсу с помощью оператора `&`.

        Ссылки drop'аются так же как и остальные ресурсы.
  - en:
      title: Borrowing Mutable Ownership with References
      content_markdown: |
        We can also borrow mutable access to a resource with the `&mut` operator.

        A resource owner cannot be moved or modified while mutably borrowed.

        Memory detail:
        * Rust prevents having two ways to mutate an owned value because it introduces the possibility of a data race.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20do_something(foo)%20would%20fail%20because%0A%20%20%20%20%2F%2F%20foo%20cannot%20be%20moved%20while%20mutably%20borrowed%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20foo.x%20%3D%2013%3B%20would%20fail%20here%20because%0A%20%20%20%20%2F%2F%20foo%20is%20not%20modifiable%20while%20mutably%20borrowed%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20is%20dropped%20here%20because%20its%20no%20longer%20used%20after%20this%20point%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20this%20works%20now%20because%20there%20all%20mutable%20references%20were%20dropped%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20move%20foo%27s%20ownership%20to%20a%20function%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A

    fr:
      title: S'approprier une ressource mutable avec des références
      content_markdown: |
        On peut créer une référence mutable qui permet d'emprunter l'accès à une ressource mutable (celles-ci sont
        créées avec le mot-clé **let**) en utilisant l'opérateur `&mut`.

        Le propriétaire d'une ressource ne peut pas changer lorsque la ressource
        est empruntée avec une référence mutable.

        Détails de la mémoire:
        * Rust empêche d'avoir deux moyens de modifier une valeur car cela introduirait 
        des problèmes concurrentiels d'accès aux données.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20est%20jet%C3%A9%20(d%C3%A9construit%20et%20d%C3%A9sallou%C3%A9)%20ici.%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20ECHEC%3A%20l'appel%20%C3%A0%20la%20fonction%20do_something(foo)%20%C3%A9chouerait.%0A%20%20%20%20%2F%2F%20En%20effet%2C%20le%20propri%C3%A9taire%20de%20foo%20ne%20peut%20pas%20%C3%AAtre%20d%C3%A9plac%C3%A9%20vers%0A%20%20%20%20%2F%2F%20le%20param%C3%A8tre%20de%20la%20fonction%20car%20f%20l'a%20emprunt%C3%A9%20avec%20l'op%C3%A9rateur%20%26mut.%0A%0A%20%20%20%20%2F%2F%20ECHEC%3A%20l'instruction%20%60foo.x%20%3D%2013%3B%60%20%C3%A9chouerait.%20En%20effet%20foo%20ne%20peut%20pas%20%0A%20%20%20%20%2F%2F%20%C3%AAtre%20modifi%C3%A9%20car%20f%20l'a%20emprunt%C3%A9%20avec%20une%20r%C3%A9f%C3%A9rence%20mutable.%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20est%20jet%C3%A9%20ici%20car%20il%20n'est%20plus%20utilis%C3%A9%20par%20la%20suite.%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20On%20a%20le%20droit%20car%20l'unique%20r%C3%A9f%C3%A9rence%20mutable%20f%20a%20%C3%A9t%C3%A9%20jet%C3%A9e.%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20foo%20change%20une%20fois%20de%20plus%20de%20propri%C3%A9taire!%0A%20%20%20%20%2F%2F%20Le%20nouveau%20propri%C3%A9taire%20de%20foo%20est%20le%20param%C3%A8tre%0A%20%20%20%20%2F%2F%20de%20la%20fonction%20do_something.%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A

    ie:
      title: Pruntation de Mutabil Proprietá con Referenties
      content_markdown: |
        Noi posse anc pruntar accesse mutabil a un ressurse con li operator `&mut`.

        Un proprietario de un ressurse ne posse mover o modificar se durant que it es pruntat mutabilmen.

        Detallies pri memorie:
        * Rust preveni li duplic mutabil pruntation de un valore pro que con to on have li possibilitá de data-concurrentie.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20far_alquo(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20cade%20ci%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20FALLIMENT%3A%20far_alquo%20vell%20fallir%20pro%20quo%0A%20%20%20%20%2F%2F%20foo%20ne%20posse%20mover%20durant%20que%20it%20es%20pruntat%20mutabilmen%0A%0A%20%20%20%20%2F%2F%20FALLIMENT%3A%20foo.x%20%3D%2013%3B%20vell%20fallir%20ci%20pro%20que%0A%20%20%20%20%2F%2F%20on%20ne%20posse%20modificar%20foo%20durant%20que%20it%20es%20pruntat%20mutabilmen%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20cade%20ci%20pro%20que%20on%20ne%20usa%20it%20plu%20pos%20ciloc%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20nu%20it%20functiona%20pro%20quo%20omni%20referenties%20mutabil%20ha%20cadet%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20transferer%20li%20propriet%C3%A1%20de%20foo%20a%20un%20function%0A%20%20%20%20far_alquo(foo)%3B%0A%7D%0A
    pt-br:
      title: Emprestando Propriedades Mutáveis Usando Referências
      content_markdown: |
        Também podemos emprestar um acesso mutável a um recurso usando o operador `& mut`.

        O proprietário de um recurso não pode ser movido ou modificado durante um empréstimo mutável.

        Detalhes de memória:
        * O Rust evita ter duas maneiras de alterar um valor que tenha um dono, pois
        introduz a possibilidade de uma corrida de dados.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20faz_alguma_coisa(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20%C3%A9%20descartado%20aqui%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20faz_alguma_coisa(foo)%20ir%C3%A1%20falhar%20porque%0A%20%20%20%20%2F%2F%20foo%20n%C3%A3o%20pode%20ser%20movida%20durante%20um%20empr%C3%A9stimo%20mut%C3%A1vel%0A%0A%20%20%20%20%2F%2F%20FAILURE%3A%20foo.x%20%3D%2013%3B%20ir%C3%A1%20falhar%20porque%0A%20%20%20%20%2F%2F%20foo%20n%C3%A3o%20%C3%A9%20modific%C3%A1vel%20durante%20um%20empr%C3%A9stimo%20mut%C3%A1vel%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20%C3%A9%20descartado%20aqui%20por%20n%C3%A3o%20ser%20mais%20usado%20depois%20deste%20ponto%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20isto%20aqui%20funciona%20agora%20porque%20todas%20as%20refer%C3%AAncias%20%0A%20%20%20%20%2F%2F%20mut%C3%A1veis%20foram%20descartadas%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20move%20a%20propriedade%20de%20foo%20para%20uma%20fun%C3%A7%C3%A3o%0A%20%20%20%20faz_alguma_coisa(foo)%3B%0A%7D%0A
    ru:
      title: Заимствование у владельца с правами на изменние
      content_markdown: |
        Мы также можем позаимствовать доступ к ресурсу с правами на его изменение с помощью 
        оператора `&mut`.

        Владелец ресурса не может быть передан (move'нут) или изменён (права на изменения у `&mut` ссылки), пока
        он **mut**'абельно заимствован.

        Тонкости памяти:
        * Rust предотвращает изменение ресурса более чем с одного места, так как это может привести
        к гонкам данных (data race).
  - en:
      title: Dereferencing
      content_markdown: |
        Using `&mut` references, you can set the owner's value using the `*` operator.

        You can also get a copy of owned value using the `*` operator (If the value can be copied. We will discuss copyable types in later chapters).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20get%20a%20copy%20of%20the%20owner's%20value%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20set%20the%20reference's%20owner's%20value%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A

    fr:
      title: Déréférencement
      content_markdown: |
        Avec une référence, on peut modifier la valeur avec l'opérateur de déréférencement `*`.

        Tu peux également obtenir une copie de la valeur en utilisant également l'opérateur de déférencement `*`
        (à condition que la valeur puisse être copiée, nous discuterons des types qui peuvent l'être
        dans un prochain chapitre).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20obtient%20une%20copie%20de%20la%20valeur%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20change%20la%20valeur%20originelle%20mais%20pas%20celle%20de%20la%20copie!%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A

    ie:
      title: Dereferentiar
      content_markdown: |
        Con referenties, on posse etablisser li valore del proprietario con li operator `*`.

        On posse anc obtener un copie del propri valore con li operator `*`
        (si li valore es copiabil. Noi va parlar pri tipes copiabil in li capitules a sequer.)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20obtenir%20un%20copie%20del%20valore%20del%20proprietario%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20etablisser%20li%20valore%20del%20proprietario%20del%20referentie%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A
    pt-br:
      title: Desreferenciando
      content_markdown: |
        Usando referências você pode definir o valor do proprietário usando o operador `*`.

        Você também pode obter uma cópia do valor de propriedade usando o operador `*` 
        (Se o valor puder ser copiado. Discutiremos tipos copiáveis nos próximos 
        capítulos).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20pega%20uma%20c%C3%B3pia%20do%20propriet%C3%A1rio%20do%20valor%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20atribue%20%C3%A0%20refer%C3%AAncia%20do%20propriet%C3%A1rio%20do%20valor%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A
    ru:
      title: Разыменование
      content_markdown: |
        Используя `&mut` ссылки, Вы можете установить значение переменной, используя `*` оператор.

        Вы также можете получить копию значения, используя `*` (только если значение может быть скопировано. Мы поговорим о 
        копируемых типах в следующих главах).
  - en:
      title: Passing Around Borrowed Data
      content_markdown: |
        Rust's rules for references might best be summarized by:

        * Rust only allows there to be one mutable reference **or** multiple non-mutable references **but not both**
        * A reference must never **live longer** than its owner.

        This doesn't tend to be a problem when passing around references to functions.

        Memory details:
        * The first rule of references prevents data races. What's a data race? A data race when reading from data has the possibility of being out of sync due to the existance of a writer to the data at the same time. This happens often in multi-threaded programming.
        * The second rule of references prevents the misuse of references that refer to non-existant data ( called dangling pointers in C ).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20mutable%20reference%20f%20is%20dropped%20here%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20because%20all%20mutable%20references%20are%20dropped%20within%0A%20%20%20%20%2F%2F%20the%20function%20do_something.%20We%20can%20create%20another.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
    fr:
      title: Transfert de données empruntées
      content_markdown: |
        Les règles de Rust en ce qui concerne les références peuvent être résumées en:

        * Rust n'autorise qu'une seule référence mutable (mot-clé `&mut`) ou plusieurs références immuables **mais pas les deux**.
        * Une référence ne doit pas **vivre plus longtemps** que son propriétaire. 

        Cela n'est pas un problème lorsque que la référence est passée en paramètre
        d'une fonction puisque la référence n'exite que dans la portée de la fonction.

        Détails de la mémoire:
        * La première règle empêche les accès concurrentiels. On parle d'accès concurrentiels lorsque plusieurs acteurs
        essayent d'accéder à une ressource en même temps. Par exemple j'essaie de lire une valeur mais quelqu'un d'autre
        la modifie en même temps, résultat je ne sais pas si je lis la valeur avant ou après modification. Cela arrive
        fréquemment dans les programme utilisant plusieurs fils d'exécution (en anglais threads).
        * La deuxième règle nous évite la mauvaise utilisation de références qui pourrait faire référence à une donnée
        inexistante (les fameux **dandling pointers** du language C).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20La%20r%C3%A9f%C3%A9rence%20mutable%20f%20est%20jet%C3%A9e%20(d%C3%A9construite%20et%20d%C3%A9sallou%C3%A9e)%20ici.%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Etant%20donn%C3%A9%20que%20la%20r%C3%A9f%C3%A9rence%20modifiable%20foo%20n%27existe%20uniquement%20dans%0A%20%20%20%20%2F%2F%20la%20fonction%20do_something%2C%20on%20peut%20en%20cr%C3%A9er%20une%20autre.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20est%20jet%C3%A9%20ici.%0A%7D%0A
    ie:
      title: Transferer Pruntat Data
      content_markdown: |
        On posse curtmen resumar li regules de Rust pri referenties quam seque:
          
        * **Un** mutabil referentie es permisset, **o** multiplic non-mutabil referenties, **ma ne ambi**
        * Un referentie ne mey viver plu long quam su proprietario.
          
        To por li pluparte ne es un problema quande on transfere referenties a functiones.
          
        Detallies pri memorie:
        * Li unesim regul de referenties preveni data-concurrentie. Quo es to? Data-concurrentie eveni quande on lee data con li possibilitá de un scritor al sam data in li sam moment. To eveni sovente in multi-filat programmation.
        * Li duesim regul de referenties preveni li misusa de referenties referent a data quel ne existe ( nominat dangling pointers in C ).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20far_alquo(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20mutabil%20referentie%20f%20cade%20ci%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20far_alquo(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20nam%20omni%20mutabil%20referenties%20cade%20intra%20%0A%20%20%20%20%2F%2F%20li%20function%20far_alquo.%20Noi%20posse%20crear%20un%20in%20plu.%0A%20%20%20%20far_alquo(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20cade%20ci%0A%7D%0A
    pt-br:
      title: Passando Dados Emprestados
      content_markdown: |
        As regras do Rust para referências podem ser melhor resumidas assim:

        * O Rust permite que haja apenas uma referência mutável **ou** múltiplas
          referências não-mutáveis, **mas não ambas**.
        * Uma referência nunca deve **viver mais** do que o seu proprietário.

        Isso não costuma ser um problema ao passar referências a funções.

        Detalhes da memória:
        * A primeira regra das referências previnem as corridas de dados. O que é uma corrida de dados? Uma corrida de dados acontece quando, na leitura dos dados, temos a possibilidade de conflito com a existência de outras escritas de dados ao mesmo tempo. Isso acontece frequentemente na programação multithread.
        * A segunda regra de referências evita o uso indevido de referências que se referem a dados inexistentes (chamados ponteiros pendentes em C).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20faz_alguma_coisa(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20a%20refer%C3%AAncia%20mut%C3%A1vel%20f%20%C3%A9%20descartada%20aqui%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20faz_alguma_coisa(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20porque%20todas%20as%20refer%C3%AAncias%20mut%C3%A1veis%20s%C3%A3o%20descartadas%20dentro%0A%20%20%20%20%2F%2F%20da%20fun%C3%A7%C3%A3o%20faz_alguma_coisa.%20Ent%C3%A3o%20podemos%20criar%20outra%20refer%C3%AAncia.%0A%20%20%20%20faz_alguma_coisa(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20descartado%20aqui%0A%7D%0A
  - en:
      title: References Of References
      content_markdown: |
        References can even be used on pieces of references.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
    fr:
      title: Réferences de réferences
      content_markdown: |
        Une référence peut faire référence à une autre.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20est%20jet%C3%A9%20(d%C3%A9construit%20et%20d%C3%A9allou%C3%A9)%20ici%2C%20ce%20qui%20nous%20autorise%0A%20%20%20%20%2F%2F%20%C3%A0%20cr%C3%A9er%20une%20r%C3%A9f%C3%A9rence%20immuable.%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20est%20jet%C3%A9%20ici.%0A%20%20%20%20%2F%2F%20foo%20est%20jet%C3%A9%20ici.%0A%7D%0A
    ie:
      title: Referenties de Referenties
      content_markdown: |
        On mem posse usar referenties sur referenties.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20far_alquo(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20cade%20ci%20por%20que%20noi%20mey%20posser%20crear%20un%20referentie%20%C3%ADnmutabil%0A%20%20%20%20let%20y%20%3D%20far_alquo(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20cade%20ci%0A%20%20%20%20%2F%2F%20foo%20cade%20ci%0A%7D%0A
    pt-br:
      title: Referências de Referências
      content_markdown: |
        Referências podem ser usadas até mesmo em pedaços de referências.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20faz_alguma_coisa(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20%C3%A9%20descartado%20aqui%20permitindo-nos%20criar%20uma%20refer%C3%AAncia%20n%C3%A3o%20mut%C3%A1vel%0A%20%20%20%20let%20y%20%3D%20faz_alguma_coisa(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20%C3%A9%20descartado%20aqui%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20descartado%20aqui%0A%7D%0A
  - en:
      title: Explicit Lifetimes
      content_markdown: |
        Even though Rust doesn't always show it in code, the compiler understands the lifetime of every variable and will attempt
        to validate that a reference never exists longer than its owner.

        Functions can be explicit by parameterizing the function signature with symbols that help identify 
        which parameters and return values share the same lifetime.

        Lifetime specifiers always start with a `'` (e.g. `'a`, `'b`, `'c`)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20the%20parameter%20foo%20and%20return%20value%20share%20the%20same%20lifetime%0Afn%20do_something%3C'a%3E(foo%3A%20%26'a%20Foo)%20-%3E%20%26'a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%20allow%20us%20to%20create%20a%20non-mutable%20reference%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo%20is%20dropped%20here%0A%7D%0A
    fr:
      title: Durée de vie explicite
      content_markdown: |
        Même si cela ne se voit pas, le compilateur porte une attention particulière à la durée de vie
        de chaque variable et veillera à ce qu'une référence n'existe pas au delà de
        l'existance de son propriétaire.

        Avec Rust, on peut explicitement spécifier la durée de vie des paramètres d'une fonction.
        Ceci permet à un ou plusieurs paramètres d'une fonction de partager la durée de vie de valeurs de retour.

        Les spécifieurs de durée de vie commencent toujours par le symbole `'` (e.g. `'a`, `'b`, `'c`).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20Le%20param%C3%A8tre%20foo%20et%20la%20valeur%20de%20retour%20partage%0A%2F%2F%20la%20m%C3%AAme%20dur%C3%A9e%20de%20vie.%0Afn%20do_something%3C%27a%3E(foo%3A%20%26%27a%20Foo)%20-%3E%20%26%27a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20x%20est%20jet%C3%A9%20(d%C3%A9construit%20et%20d%C3%A9allou%C3%A9)%20ici%2C%20ce%20qui%20permet%20de%0A%20%20%20%20%2F%2F%20cr%C3%A9er%20une%20r%C3%A9f%C3%A9rence%20immuable.%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20est%20jet%C3%A9%20ici.%0A%20%20%20%20%2F%2F%20foo%20est%20jet%C3%A9%20ici.%0A%7D%0A
    ie:
      title: Vive-témpores Explicit
      content_markdown: |
        Benque Rust ne sempre monstra it nos in li code, li compilator save li vive-témpor de chascun variabil e va provar validar
        que referenties ne vive plu long quam lor proprietarios.

        Un function posse esser explicit per parametrisar li function-signatura con simboles queles auxilia identificar
        quel parametres e quel retorn-valores partiprende li sam vive-témpor.

        Specificatores de vive-témpores sempre comensa con un `'` (e.g. `'a`, `'b`, `'c`)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20li%20parametre%20foo%20e%20retorn-valore%20partiprende%20li%20sam%20vive-t%C3%A9mpor%0A%0A%2F%2F%20(Benque%20por%20li%20pluparte%20on%20scri%20simplicmen%20%27a%2C%20%27b%2C%20%27c%2C%20etc.%2C%20on%0A%2F%2F%20posse%20scrir%20quocunc%20pos%20li%20%27%20%3A%20%27vive_tempor%2C%20%27long%2C%20%27curt%2C%20%0A%2F%2F%20%27unesim%2C%20%27duesim%20etc.%20es%20omnes%20possibil%20n%C3%B3mines%20por%20ili)%0Afn%20far_alquo%3C%27a%3E(foo%3A%20%26%27a%20Foo)%20-%3E%20%26%27a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20cade%20ci%20por%20possibilisar%20li%20creation%20de%20un%20%C3%ADnmutabil%20referentie%0A%20%20%20%20let%20y%20%3D%20far_alquo(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20cade%20ci%0A%20%20%20%20%2F%2F%20foo%20cade%20ci%0A%7D%0A
    pt-br:
      title: Tempo de Vida Explícito
      content_markdown: |
        Mesmo que o Rust nem sempre nos mostre no código, o compilador conhece o tempo de vida de cada variável e tentará validar uma referência que nunca deve existir por mais tempo que seu proprietário.

        As funções podem ser explícitas parametrizando a assinatura da função com símbolos que ajudam a identificar quais parâmetros e valores de retorno compartilham a mesma tempo de vida.

        Os especificadores de tempo de vida sempre começam com um `'` (por exemplo `'a`, `'b`, `'c`)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20o%20par%C3%A2metro%20foo%20e%20valor%20de%20retorno%20compartilham%20o%20mesmo%20tempo%20de%20vida%0Afn%20faz_alguma_coisa%3C'a%3E(foo%3A%20%26'a%20Foo)%20-%3E%20%26'a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20%C3%A9%20descartada%20aqui%20permitindo-nos%20criar%20uma%20refr%C3%AAncia%20n%C3%A3o-mut%C3%A1vel%0A%20%20%20%20let%20y%20%3D%20faz_alguma_coisa(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20%C3%A9%20descartada%20aqui%0A%20%20%20%20%2F%2F%20foo%20%C3%A9%20descartada%20aqui%0A%7D%0A
  - en:
      title: Multiple Lifetimes
      content_markdown: |
        Lifetime specifiers allow us to be explicit with certain scenarios the compiler cannot resolve itself 
        by distinguishing all of a function signature component's lifetimes.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20and%20the%20return%20value%20share%20the%20same%20lifetime%0A%2F%2F%20foo_a%20has%20an%20unrelated%20lifetime%0Afn%20do_something%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20is%20dropped%20here%20because%20only%20foo_b's%20lifetime%20exist%20beyond%20here%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20is%20dropped%20here%0A%20%20%20%20%2F%2F%20foo_b%20is%20dropped%20here%0A%7D%0A

    fr:
      title: Durée de vie multiple
      content_markdown: |
        Les spécifieurs de durée de vie permettent d'être explicite dans certains cas où le compilateur
        ne puisse pas résoudre lui-même les durées de vie des éléments de la signature d'une fonction.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20et%20la%20valeur%20de%20retour%20partagent%20la%20m%C3%AAme%20dur%C3%A9e%20de%20vie.%0A%2F%2F%20foo_a%20a%20sa%20propre%20dur%C3%A9e%20de%20vie.%0Afn%20do_something%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20est%20jet%C3%A9%20(d%C3%A9construit%20et%20d%C3%A9sallou%C3%A9)%20ici.%0A%20%20%20%20%2F%2F%20Seule%20la%20dur%C3%A9e%20de%20vie%20de%20foo_b%20continue.%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20est%20jet%C3%A9%20ici.%0A%20%20%20%20%2F%2F%20foo_b%20est%20jet%C3%A9%20ici.%0A%7D%0A

    ie:
      title: Multiplic Vive-témpores
      content_markdown: |
        Con specificatores de vive-témpores noi posse esser explicit quande li compilator ne posse self comprender les. 
        Tande noi fa distint li vive-témpores de omni componentes de un function-signatura.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20e%20li%20retorn-valore%20partiprende%20li%20sam%20vive-t%C3%A9mpor%0A%2F%2F%20foo_a%20have%20un%20vive-t%C3%A9mpor%20sin%20relation%20al%20altri%0Afn%20far_alquo%3C%27a%2C%20%27b%3E(foo_a%3A%20%26%27a%20Foo%2C%20foo_b%3A%20%26%27b%20Foo)%20-%3E%20%26%27b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%26foo_b.x%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20far_alquo(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20cade%20ci%20pro%20quo%20solmen%20li%20vive-t%C3%A9mpor%20de%20foo_b%20continua%20pos%20ci%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20cade%20ci%0A%20%20%20%20%2F%2F%20foo_b%20cade%20ci%0A%7D%0A
    pt-br:
      title: Tempos de Vida Múltiplos
      content_markdown: |
        Os especificadores de tempo de vida nos permitem ser explícitos em certos cenários que o compilador não pode resolver sozinho, distinguindo todas os tempo de vida dos componentes na assinatura de uma função.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20e%20o%20valor%20de%20retorno%20compartilham%20do%20mesmo%20tempo%20de%20vida%0A%2F%2F%20foo_a%20tem%20um%20tempo%20de%20vida%20n%C3%A3o%20relacionado%0Afn%20faz_alguma_coisa%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20faz_alguma_coisa(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20%C3%A9%20descartado%20aqui%20porque%20somente%20o%20tempo%20de%20vida%20de%20%0A%20%20%20%20%2F%2F%20foo_b%20existe%20al%C3%A9m%20deste%20ponto%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20%C3%A9%20descartado%20aqui%0A%20%20%20%20%2F%2F%20foo_b%20%C3%A9%20descartado%20aqui%0A%7D%0A
  - en:
      title: Static Lifetimes
      content_markdown: |
        A **static** variable is a memory resource created at compile-time that exists through a program start to 
        finish. They must have their types explicitly specified.

        A **static lifetime** is a memory resource that lasts indefinitely to the end of a program.  Note that by this definition
        some static lifetime resources can be created at runtime.

        Resources with static lifetimes have a special lifetime specifier `'static`.

        `'static` resources will never **drop**

        If static lifetime resources contain references they must all be `'static` (anything less would not live long enough).

        Memory detail:

        * Modifying static variables is inherently dangerous because they are globally accessable to be read from by anyone
          introducing the possibility of a data race. We'll talk about the challenges of global data later.
        * Rust allows the use of `unsafe { ... }` block to perform some operations that the compiler cannot make memory gaurantees about. The [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/) should not be talked about casually.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20static%20variables%20can%20also%20be%20scoped%20to%20a%20function%0A%20%20%20%20static%20mut%20SECRET%3A%20%26'static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20string%20literals%20have%20a%20'static%20lifetime%0A%20%20%20%20let%20msg%3A%20%26'static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26'static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20You%20can%20break%20some%20rules%2C%20but%20you%20must%20be%20explicit%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20we%20can%20set%20SECRET%20to%20a%20string%20literal%20because%20it%20is%20also%20%60static%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A

    fr:
      title: Durées de vie statiques
      content_markdown: |
        Une variable statique (en anglais **static**) est une ressource mémoire créée lors de la compilation
        et qui existe du début jusqu'à la fin du programme. le type doit être défini explicitement.

        Une **durée de vie statique** est une ressource mémoire qui existe indéfiniment jusqu'à la fin du programme.
        Une ressource statique peut être créée lors de l'exécution du programme.

        Elle est créée avec le mot-clé `'static`.

        Elle ne sera jamais déconstruite et désallouée avant la fin du programme.

        Si une ressouce statique contient une référence, celle-ci doit également être statique
        (sinon la durée de vie de la référence pourrait s'arrêter avant la fin du programme).

        Détails de la mémoire:

        * Modifier une variable statique est dangereux car ce sont des variables globales
        pouvant être lues par n'importe qui et pourrait créer des problèmes concurrentiels).
        Nous parlerons des défis des données globales dans de futurs chapitres.
        * Rust nous donne accès au bloc `unsafe { ... }` pour effectuer des opérations en mémoire
        risquées (le résultat n'est pas garanti). Le [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/)
        ne doit pas être pris à la légère.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Les%20variables%20statisques%20peuvent%20%C3%A9galement%0A%20%20%20%20%2F%2F%20%C3%AAtre%20limit%C3%A9es%20%C3%A0%20la%20port%C3%A9e%20de%20la%20fonction.%0A%20%20%20%20static%20mut%20SECRET%3A%20%26%27static%20str%20%3D%20%22espadon%22%3B%0A%0A%20%20%20%20%2F%2F%20Les%20cha%C3%AEnes%20de%20caract%C3%A8res%20ont%20une%20dur%C3%A9e%20de%20vie%20statiques.%0A%20%20%20%20let%20msg%3A%20%26%27static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26%27static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20On%20peut%20casser%20les%20r%C3%A8gles%2C%20mais%20il%20faut%20%C3%AAtre%20explicite.%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20On%20peut%20modifier%20la%20variable%20statique%20SECRET.%20La%20nouvelle%20valeur%0A%20%20%20%20%20%20%20%20%2F%2F%20reste%20une%20cha%C3%AEne%20de%20caract%C3%A8res%20statiques.%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A

    ie:
      title: Vive-témpores Static
      content_markdown: |
        Un variabil **static** es un ressurse de memorie creat al moment de compilation quel existe durant li programma
        desde de comense til li fine. Ili besona un tip explicitmen specificat.

        Un **vive-témpor static** es un ressurse de memorie quel continua til li fine del programma. A notar que secun ti definition
        quelc ressurses con vive-témpor static posse esser creat ye li execution del programma.

        Ressurses con vive-témpores static possede un special specificator `'static`.

        `'static` ressurses nequande **cade**

        Si un ressurse con un vive-témpor static possede referenties, ili deve omnis esser `'static` (quelcunc altri vive-témpor
        ne vell viver sat long).

        Detallies pri memorie:
        * Modificar variabiles static es dangerosi pro que ili es globalmen accessibil por letion de quicunc, quel introducte li
          possibilitá de data-concurrentie. Noi va parlar pri li desfacilitás de data global plu tard.
        * Rust possibilisa li usation de un bloc `unsafe { ... }` por far quelc operationes queles li compilator ne posse garantir. Li [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/) existe por to ma esse prudent!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20variabiles%20static%20posse%20anc%20esser%20cadrat%20a%20un%20function%0A%20%20%20%20static%20mut%20SECRET%3A%20%26%27static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20l%C3%ADtterales%20string%20have%20li%20vive-t%C3%A9mpor%20%27static%0A%20%20%20%20let%20msg%3A%20%26%27static%20str%20%3D%20%22Salute%20munde!%22%3B%0A%20%20%20%20let%20p%3A%20%26%27static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20On%20posse%20rupter%20li%20regules%2C%20ma%20deve%20esser%20explicit%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20noi%20posse%20far%20SECRET%20un%20l%C3%ADtterale%20string%20nam%20anc%20it%20es%20%60static%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A
    pt-br:
      title: Tempos de Vida Estáticos
      content_markdown: |
        Uma variável **estática** é um recurso de memória criado em tempo de compilação que existe do início ao fim dentro de um programa. Eles devem ter seus tipos especificados explicitamente.

        Um recurso com **tempo de vida estático** é um recurso de memória que dura indefinidamente até o término de um programa. Observe que, por essa definição, alguns recursos com tempo de vida estático podem ser criados em tempo de execução.

        Recursos com tempo de vida estático têm o especificador de tempo de vida especial `'static`.

        Recursos `'static` nunca serão **descartados**.

        Se os recursos com tempo de vida estático contiverem referências, todos deverão ser `'static` (nada menos do que isso viveria tempo suficiente).

        Detalhes da memória:
        * A modificação de variáveis estáticas é inerentemente perigosa, porque elas são acessíveis globalmente para serem lidas por qualquer um introduzindo a possibilidade de uma corrida de dados. Falaremos sobre os desafios dos dados globais mais tarde.
        * O Rust permite o uso do bloco `unsafe {...}` para executar algumas operações sobre as quais o compilador não pode garantir a integridade do que está guardado na memória. O [<span style="color:red; font-weight: bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/) não deve ser mencionado em vão.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20vari%C3%A1veis%20est%C3%A1ticas%20tamb%C3%A9m%20podem%20ter%20escopo%20definido%20para%20uma%20fun%C3%A7%C3%A3o%0A%20%20%20%20static%20mut%20SECRETO%3A%20%26'static%20str%20%3D%20%22senha%22%3B%0A%0A%20%20%20%20%2F%2F%20strings%20t%C3%AAm%20o%20mesmo%20tempo%20de%20vida%20que%20as%20vari%C3%A1veis%20est%C3%A1ticas%0A%20%20%20%20let%20msg%3A%20%26'static%20str%20%3D%20%22Ol%C3%A1%20Mundo!%22%3B%0A%20%20%20%20let%20p%3A%20%26'static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20voc%C3%AA%20pode%20quebrar%20algumas%20regras%2C%20mas%20deve%20ser%20expl%C3%ADcito%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20podemos%20atribuir%20uma%20string%20a%20SECRETO%20porque%20ela%20tamb%C3%A9m%20%C3%A9%20est%C3%A1tica%0A%20%20%20%20%20%20%20%20SECRETO%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRETO)%3B%0A%20%20%20%20%7D%0A%7D%0A
  - en:
      title: Lifetimes In Data Types
      content_markdown: |
        Similarly to functions, data types can be parameterized with lifetime specifiers of its members.

        Rust validates that the containing data structure of the references never lasts longer than the owners its references point to.

        We can't have structs running around with references pointing to nothingness!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A

    fr:
      title: Durée de vie dans les structures
      content_markdown: |
        De la même manière que les fonctions, les champs d'une structure peuvent
        être paramétrés avec des spécifieurs de durée de vie pour un ou plusieurs
        de ses membres.

        Si une structure contient une référence, alors le compilateur Rust s'assure
        que la durée de vie de la structure n'excède pas celle du 'propriétaire' de
        la référence.

        Le compilateur Rust ne permet pas d'avoir une structure possédant
        des références pointant vers rien du tout.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A

    ie:
      title: Vive-témpores in tipes de data
      content_markdown: |
        Similmen a functiones, data-tipes posse esser parametrisat con specificatores de vive-témpores de lor membres.
        Rust fa cert que li data-structura del contenent referenties ne vive plu long quam li proprietarios a queles lor referenties monstra.
        Noi ne posse tolerar structs con referenties monstrant nullcos!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A
    pt-br:
      title: Tempos de Vida em Tipos de Dados
      content_markdown: |
        Da mesma forma que as funções, os tipos de dados podem ser parametrizados com os especificadores de tempos de vida

        O Rust valida a estrutura de dados que contém as referências para que nunca dure mais do que os proprietários para os quais as suas referências apontam.

        Não podemos ter estruturas rodando por aí com referências apontando para o nada!
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A
  - en:
      title: Chapter 5 - Conclusion
      content_markdown: |
        Whew, congrats for making it through! I know it's alot to take in but you are well
        under way to becoming a Rustacean. Hopefully it's clear how Rust as a language aims to 
        solve many of these common challenges in systems programming:

        * Unintentional modification of resources
        * Forgetting to deconstruct resources 
        * Resources accidently being deconstructed twice
        * Using resources after they have been deconstructed 
        * Data races caused by writing to resources while others are reading from resources 
        * Seeing clearly areas of the code where compiler can’t make guarantees

        In the next chapter we'll apply some of this knowledge as we look how Rust handles text.
    fr:
      title: Chapitre 5 - Conclusion
      content_markdown: |
        Ouf, félicitations pour être arrivé jusque là! Je sais que c'est beaucoup à apprendre mais tu es en bonne
        voie pour devenir un Rustacean. J'espère que tu arrive à voir comment Rust en tant que langage vise à
        résoudre bon nombre des défis communs à la programmation système:

        * Modification involontaire de ressources.
        * Oubli de déconstruire les ressources.
        * Ressources accidentellement déconstruites deux fois.
        * Utilisation des ressources après leur déconstruction.
        * Accès concurrentiels causés par l'écriture d'une ressource tandis que quelqu'un est en train de la lire.
        * Voir clairement les zones du code dont le compilateur ne garantit pas les effets.

        Dans le chapitre suivant, nous appliquerons une partie de nos connaissances en examinant comment Rust gère le texte.
    ie:
      title: Capitul 5 - Conclusion
      content_markdown: |
        Gratulationes pro har leet omnicos til nu! Yo save que it es mult a aprender ma tu es ja sur li via de devenir
        un rustaceane. Noi espera que li explication ha esset clar pri qualmen Rust vole soluer li defís comun in li 
        programmation de sistemas:
        * Modification ínintentionat de ressurses
        * Obliviar deconstructer ressurses
        * Errari duplic deconstruction de ressurses
        * Usation de ressurses ja deconstructet
        * Data-concurrentie causat per scrition a ressurses durant que altris lee les
        * Vider clarmen locs del code in quel li compilator ne posse da nos un garantie
        In li capitul a sequer noi va aplicar ti-ci conossentie per vider qualmen Rust tracta se con textu.
    pt-br:
      title: Capítulo 5 - Conclusão
      content_markdown: |
        Ufa, parabéns por passar! Eu sei que é muito para absorver, mas você está bem encaminhado para se tornar um Rustáceo. Espero que esteja claro que o Rust como linguagem, visa solucionar muitos desses desafios comuns na programação de sistemas:

        * Modificação não intencional de recursos.
        * Esquecendo de desconstruir recursos.
        * Recursos sendo desconstruídos duas vezes acidentalmente.
        * Usando recursos depois que eles foram desconstruídos. 
        * Corridas de dados causadas pela gravação nos recursos enquanto outros estão lendo os mesmos recursos 
        * Vendo claramente áreas do código em que o compilador não pode dar garantias

        No próximo capítulo aplicaremos um pouco desse conhecimento ao ver como o Rust manipula textos.
  - chapter: 6
    en:
      title: Chapter 6 - Text
      content_markdown: |
        Now that we understand a bit how Rust thinks of memory, we are prepared to talk about text in more detail.
        Rust cares a great deal about international text and byte level concerns you might not be familiar with
        from other languages. That said, Rust has many great tools for managing those concerns.
    fr:
      title: Chapitre 6 - Texte
      content_markdown: |
        Maintenant que nous en savons un peu plus sur la manière dont Rust gère la mémoire,
        nous sommes prêts à parler des chaînes de caractères en détail.
        Rust se soucie beaucoup du support des textes internationaux et des problèmes associés au niveau des bits 
        (dont vous n'êtes peut-être pas familier). Cela dit, Rust dispose d'excellents
        outils pour gérer ces préoccupations.
    ie:
      title: Capitul 6 - Textu
      content_markdown: |
        Nam noi ja comprende un poc pri qualmen Rust concepte memorie, noi es preparat parlar plu detalliatmen pri textu.
        Rust sucia sempre pri textu international e li concernes sur li nivelle de bytes queles fórsan es nov por tis
        qui ha venit de altri lingues. Támen, Rust possede mult utensiles por gerer ti-ci problemas.
  - en:
      title: String Literals
      content_markdown: |
        String literals are always Unicode

        String literals type are `&'static str`

        * `&` meaning that its referring to a place in memory, and it lacks a `&mut` meaning that the compiler will not allow modification
        * `'static` meaning the string data will be available till the end of our program (it never drops)
        * `str` means that it points to a sequence of bytes that are always valid **utf-8**

        Memory details:
        * likely the Rust compiler will put your string in the data segment of your program memory
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
    fr:
      title: Chaînes de caractères
      content_markdown: |
        Les chaînes de caractères (en anglais string literals) sont toujours encodées avec le standard Unicode.

        Le type d'une chaîne de caractères est `&'static str`.

        * `&` signifie que c'est une référence. Remarque l'abscence du mot-clé `&mut`,
        cela nous dit également que le compilateur n'autorisera pas la modification.
        * `'static` signifie que la donnée sera disponible jusqu'à la fin du programme (celle-ci n'est jamais désallouée).
        * `str` signifie que la référence pointe vers une séquence de bytes qui sera toujours interprétable en tant qu'**utf-8**.

        Détails de la mémoire:
        * Le compilateur Rust va dans la plupart des cas placer les données de la chaîne de caractères
        sur le segment de données (en anglais data segment) de la mémoire du programme.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22salut%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
    ie:
      title: String Literals
      content_markdown: |
        String literals (caten-litterales) es sempre Unicode

        Li tip por string literals es `&'static str`

        * `&` significa que it refere a un loc in memorie, e it manca un `&mut` nam li compilator nequande va permisser modificar it
        * `static` significa que li data del string va sempre esser disponibil til li fine del programma (it nequande cade)
        * `str` significa que it indica un sequentie de bytes queles sempre es valid **utf-8**

        Detallies pri memorie:
        * max probabilmen li compilator Rust va plazzar tui string in li segment de data del memorie de tui programma
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22salute%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
  - en:
      title: What is utf-8
      content_markdown: |
        As more languages were used on computers, the world needed to represent more text characters
        than ASCII allowed (1 byte only allowed 256 characters). 

        **utf-8** was introduced with a variable byte length of 1-4 bytes greatly increasing the range of possible characters.

        An advantage of variable sized characters is text did not have unnecessary bytes for very common ASCII (only requiring 1 byte still in **utf-8**).

        A downside of variable sized characters is that character lookup can no longer be done quickly 
        (**O(1)** constant time) with a simple indexing (e.g. `my_text[3]` to get the 4th character). It's possible that the 
        proceeding characters could have variable widths that, altering where the 4th character actually begins in the sequence of bytes.

        Instead we must iterate through a **utf-8** byte sequence to understand where the unicode characters actually begin (**O(n)** linear time).

        Ferris: "I'm mostly just happy to have **utf-8** for representing emojis of my underwater friends."

        <span class="emoji">🐠🐙🐟🐬🐋</span>
    fr:
      title: Introduction à l'utf-8
      content_markdown: |
        De plus en plus de langues doivent être supportées par les ordinateurs d'aujourd'hui.
        Malheureusement, le système d'encodage ASCII initialement utilisé sur les premiers ordinateurs ne suffit plus
        pour représenter tout les caractères. L'encodage ASCII ne permet d'encoder seulement 256 caractères sur 1 byte.

        L'introduction du standard unicode **utf-8** a permis d'augmenter grandement le nombre caractères utilisable en
        offrant un encodage pouvant varier de 1 à 4 bytes.

        Un avantage d'avoir des caractères à taille variable est qu'on n'utilise pas de bytes superflues
        pour représenter les caractères communs ASCII (requiert un seul byte même avec l'encodage **utf-8**).

        Un désavantage d'avoir des caractères à taille variable est que l'accès ne peut plus être fait
        rapidemment (temps constant **O(1)**) avec un simple accès par index (e.g.
        `my_text[3]` pour récupérer le 4ème caractère). 
        En effet, il est possible que les caractères précédants le caractère que l'on souhaite lire aient une taille variable, altérant
        la position où le 4ème caractère se situe dans la séquence d'octets.

        Au lieu de cela, nous devons itérer sur la séquence de byte **utf-8** pour trouver où se situe
        le caractère unicode (temps linéaire **O(n)**).

        Ferris: "Je suis surtout content d'avoir l'encodage ** utf-8 ** pour représenter les emojis de mes amis sous-marins!"

        <span class="emoji">🐠🐙🐟🐬🐋</span>
    ie:
      title: Pri utf-8
      content_markdown: |
        Con plu e plu lingues usat in computatores, li munde besonat representar li caracteres usat in ili
        queles ASCII sol ne posset monstrar (1 byte possibilisat solmen 256 caracteres).

        On introductet **utf-8** con un byte-longore variant inter 1-4 bytes, creante un spacie por mult plu caracteres possibil.

        Un avantage de caracteres con grandore variabil es que con li max comun caracteres (ASCII) on besonat solmen un sol byte mem in **utf-8**

        Un desavantage es que caractere-serchada ne plu esset possibil con rapiditá
        (**O(1)** constant témpor) con un simplic indexation (p.ex. `my_text[3]` por trovar li 4im caractere). Nam in ti-ci exemple it es
        possibil que chascun caractere possede un largore diferent, e in li sequentie de bytes on ne posse garantir li loc ú it comensa e fini se.

        Pro to noi deve iterar tra un sequentie de bytes in **utf-8** por comprender ú comensa li caracteres unicode (**O(n)** lineari témpor).

        Ferris: "Por mi parte yo es felici posser usar **utf-8** por usar li emojis de mi amics submarin."

        <span class="emoji">🐠🐙🐟🐬🐋</span>
  - en:
      title: Escaping Characters
      content_markdown: |
        It's challenging to visually represent certain characters, **escape codes** allow us to put a symbol in their place.

        Rust supports the common escape codes from C-based languages:
        * `\n` - newline
        * `\r` - carriage return
        * `\t` - tab
        * `\\` - backslash
        * `\0` - null
        * `\'` - single-quote

        The complete list exists [here](https://doc.rust-lang.org/reference/tokens.html)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22Ferris%20says%3A%5Ct%5C%22hello%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
    fr:
      title: Caractères d'échappement
      content_markdown: |
        Certains caractères spéciaux posent problèmes dans les chaînes de caractères.
        Mais fort heureusement, les **caractères d'échappement** nous permettent de les représenter.

        Rust supporte la plupart des codes d'échappement communs aux langages de programmation basés sur le C:
        * `\n` - nouvelle ligne
        * `\r` - retour charriot
        * `\t` - tabulation
        * `\\` - backslash
        * `\0` - null
        * `\'` - apostrophe

        La liste complète existe [ici](https://doc.rust-lang.org/reference/tokens.html).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22Ferris%20dit%3A%5Ct%5C%22salut%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
    ie:
      title: Caracteres de escapa
      content_markdown: |
        Quande representar un caractere es desfacil, un **code de escapa** fa it possibil.

        In Rust es usat li comun codes de escapa trovat in lingues basat sur C.
        * `\n` - nov linea
        * `\r` - coche-retorna (carriage return)
        * `\t` - tabellator
        * `\\` - barre inversat
        * `\0` - null
        * `\'` - quote singul

        Li liste complet trova se [ci](http://doc.rust-lang.org/reference/tokens.html)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22Ferris%20di%3A%5Ct%5C%22salute%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
  - en:
      title: Multi-line String Literals
      content_markdown: |
        Rust strings are multiline by default.

        Use a `\` at the end of a line if you don't want a line break.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26'static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20I%20write%2C%20erase%2C%20rewrite%0A%20%20%20%20%20%20%20%20Erase%20again%2C%20and%20then%0A%20%20%20%20%20%20%20%20A%20poppy%20blooms.%0A%20%20%20%20%20%20%20%20-%20Katsushika%20Hokusai%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22hello%20%5C%0A%20%20%20%20world%22)%20%2F%2F%20notice%20that%20the%20spacing%20before%20w%20is%20ignored%0A%7D%0A
    fr:
      title: Chaînes de caractères sur plusieurs lignes
      content_markdown: |
        Avec Rust, les chaînes de caractères sont 'multi-lignes' par défaut.

        Utilise `\` à la fin d'une ligne si tu ne veux pas de retour à la ligne.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26%27static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20J%27%C3%A9cris%2C%20efface%2C%20r%C3%A9%C3%A9cris%0A%20%20%20%20%20%20%20%20Effacez%20%C3%A0%20nouveau%2C%20puis%0A%20%20%20%20%20%20%20%20Un%20coquelicot%20fleurit%0A%20%20%20%20%20%20%20%20-%20Katsushika%20Hokusai%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22hello%20%5C%0A%20%20%20%20world%22)%20%2F%2F%20l%27espace%20devant%20le%20%27w%27%20est%20ignor%C3%A9%0A%7D%0A
    ie:
      title: String Literals sur Lineas Multiplic
      content_markdown: |
        Catenes in Rust es predefinit quam multilineal.    

        On usa un `\` al fine de un linea si on ne vole que li linea mey rupter se.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku_angl%C3%A9s%3A%20%26%27static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20I%20write%2C%20erase%2C%20rewrite%0A%20%20%20%20%20%20%20%20Erase%20again%2C%20and%20then%0A%20%20%20%20%20%20%20%20A%20poppy%20blooms.%0A%20%20%20%20%20%20%20%20-%20Katsushika%20Hokusai%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20%0A%20%20%20%20println!(%22salute%20%5C%0A%20%20%20%20munde%22)%20%2F%2F%20n.b.%20li%20spacie%20avan%20m%20es%20ignorat%0A%7D%0A
  - en:
      title: Raw String Literals
      content_markdown: |
        Raw strings allow us to write a sequence of characters verbatim by starting with `r#"` and ending with `"#`. It lets us insert
        characters that might otherwise confuse a normal string literals (like double quotes and backslashes).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Raw%20strings%20are%20useful%20for%20some%20situations.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A
    fr:
      title: Chaînes de caractères bruts
      content_markdown: |
        Les chaînes de caractères bruts (en anglais raw string literals) permettent d'écrice textuellement
        une séquence de caractères en commençant par `r#"` et finissant par `"#`.
        Cela nous permet d'insérer des caractères qui seraient autrement pris
        pour un autre (notamment les caractères **"** et **\**).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Les%20cha%C3%AEnes%20de%20caract%C3%A8res%20bruts%20sont%20parfois%20utiles.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A
    ie:
      title: String Literals Crud
      content_markdown: |
        Con raw strings (crud catenes de caracteres) noi posse scrir un sequentie de caracteres quel comensa con `r#"` e fini se con `"#` Talmen
        noi posse inserter caracteres tales quam "" o \ queles normalmen es confusent in normal string literals.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Crud%20catenes%20es%20util%20de%20t%C3%A9mpor%20a%20t%C3%A9mpor.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%20%20%20%20%2F%2F%20Quo%20far%20si%20un%20%23%20trova%20se%20in%20un%20catene%3F%20On%20simplicmen%20adjunte%20un%20%23%20in%20plu%3A%0A%20%20%20%20%2F%2F%20r%23%23%22%20catene%20de%20caracteres%20%22%23%23%0A%20%20%20%20%2F%2F%20Quo%20far%20si%20trova%20se%20du%20%23%23%3F%20On%20adjunte%20un%20%23%20in%20plu!%20On%20posse%20usar%20quantcunc%0A%20%20%20%20%2F%2F%20si%20necessi%3A%20mem%20r%23%23%23%23%23%22catene%20de%20caracteres%22%23%23%23%23%23%20es%20possibil.%0A%7D%0A
  - en:
      title: String Literals From Files
      content_markdown: |
        If you have some very large text, consider using the macro `include_str!` to include text from local files in your program:

        ```rust
        let 00_html = include_str!("00_en.html");
        ```

    fr:
      title: Chaînes de caractères depuis un fichier
      content_markdown: |
        Si tu as du texte très volumineux à lire depuis un fichier en local,
        tu peux utiliser la macro `include_str!`:

        ```rust
        let 00_html = include_str!("00_en.html");
        ```

    ie:
      title: String Literals ex Archives
      content_markdown: |
        Si on possede mult textu, on posse usar li macro `include_str!` por includer li textu de archives local in li programma:

        ```rust
        let 00_html = include_str!("00_en.html");
        ```

  - en:
      title: String Slice
      content_markdown: |
        A string slice is a reference to a sequence of bytes in memory that must always be valid utf-8.

        A string slice (a sub-slice) of a `str` slice, must also be valid utf-8.

        Common methods of `&str`:
        * `len` gets the length of the string literal in bytes (not number of characters).
        *  `starts_with`/`ends_with` for basic testing.
        * `is_empty` returns true if zero length.
        * `find` returns an `Option<usize>` of the first position of some text.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20first_word%20%3D%20%26a%5B0..2%5D%3B%0A%20%20%20%20let%20second_word%20%3D%20%26a%5B3..7%5D%3B%0A%20%20%20%20%2F%2F%20let%20half_crab%20%3D%20%26a%5B3..5%5D%3B%20FAILS%0A%20%20%20%20%2F%2F%20Rust%20does%20not%20accept%20slices%20of%20invalid%20unicode%20characters%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20first_word%2C%20second_word)%3B%0A%7D%0A

    fr:
      title: String Slice
      content_markdown: |
        Une 'slice' (littéralement tranche) de chaîne de caractères est une référence
        à une séquence de bytes en mémoire qui doit être de l'utf-8 valide. Elle fait référence
        à une partie ou la totalité d'une chaîne de caractères.

        Une 'slice' (également nommée 'sub-slice') d'une 'slice' `str` doit également être de l'utf-8 valide.

        Méthodes utiles de `&str`:
        * `len` retourne la taille de la chaîne de caractères en bytes (pas le nombre de caractères!).
        * `starts_with`/`ends_with` pour tester si la chaîne de caractères commence ou finit par un certain motif.
        * `is_empty` retourne vrai si la taille est zéro.
        * `find` retourne une structure de type `Option<usize>` donnant la première position du modif à trouver.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22salut%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20first_word%20%3D%20%26a%5B0..5%5D%3B%0A%20%20%20%20let%20second_word%20%3D%20%26a%5B6..10%5D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20L'instruction%20suivante%20%C3%A9chouerait%3A%0A%20%20%20%20%2F%2F%20let%20half_crab%20%3D%20%26a%5B6..8%5D%3B%20%0A%20%20%20%20%2F%2F%20En%20effet%2C%20Rust%20n'accepte%20pas%20de%20'slice'%20de%20caract%C3%A8re%20unicode%20invalide.%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20first_word%2C%20second_word)%3B%0A%7D%0A

    ie:
      title: String Slice
      content_markdown: |
        Un string slice (tranche de un catene de caracteres) es un referentie a un sequentie de bytes in memorie quel deve sempre esser
        valid utf-8

        Anc un string slice (un tal-nominat sub-slice) de un `str` slice deve esser valid utf-8.

        Metodes comun de `&str`:
        * Con `len` on obtene li longore del string literal in bytes (ne li númere de caracteres).
        *  `starts_with`/`ends_with` por comparar to quo trova se al comense o al fine del catene
        * `is_empty` retorna true si li longore es zero
        * `find` retorna un `Option<usize>` del unesim position de alquel textu
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22salute%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20unesim_parol%20%3D%20%26a%5B0..6%5D%3B%0A%20%20%20%20let%20duesim_parol%20%3D%20%26a%5B7..11%5D%3B%0A%20%20%20%20%2F%2F%20let%20demi_crabe%20%3D%20%26a%5B9..11%5D%3B%20FALLIMENT%0A%20%20%20%20%2F%2F%20Rust%20ne%20accepta%20tranches%20de%20caracteres%20unicode%20queles%20es%20%C3%ADnvalid%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20unesim_parol%2C%20duesim_parol)%3B%0A%7D%0A
  - en:
      title: Chars
      content_markdown: |
        With so much difficulty in working with unicode, Rust offers a way to retrieve a sequence of utf-8 bytes as a vector of characters of type `char`.

        A `char` is always 4 bytes long (allowing for efficient lookup of individual characters).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20collect%20the%20characters%20as%20a%20vector%20of%20char%0A%20%20%20%20let%20chars%20%3D%20%22hi%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20should%20be%204%0A%20%20%20%20%2F%2F%20since%20chars%20are%204%20bytes%20we%20can%20convert%20to%20u32%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A

    fr:
      title: Chars
      content_markdown: |
        Du fait de la difficulté de travailler avec des caractères unicodes,
        Rust offre un moyen de récupérer une séquence d'octets utf-8 sous forme
        de vecteur de caractères de type `char`.

        Un `char` possède toujours une taille de 4 bytes (rendant la recherche
        d'un caractère particulier d'une chaîne de caractères plus rapide).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Collecte%20les%20caract%C3%A8res%20sous%20forme%20de%20vecteur%20de%20'char'.%0A%20%20%20%20let%20chars%20%3D%20%22salut%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20Devrait%20afficher%207.%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Etant%20donn%C3%A9%20que%20un%20'char'%20est%20stock%C3%A9%20sur%204%20bytes%2C%20%0A%20%20%20%20%2F%2F%20celui-ci%20peut%20donc%20%C3%AAtre%20converti%20en%20u32.%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A

    ie:
      title: Chars
      content_markdown: |
        Nam utilisar unicode posse esser desfacil, in Rust on posse retrovar un sequentie de bytes in utf-8 quam un vector de caracteres del tip `char` (caractere).

        Un `char` possede sempre un grandore de 4 bytes, con quel on posse facilmen trovar caracteres individual.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20colecter%20li%20caracteres%20quam%20un%20vector%20de%20char%0A%20%20%20%20let%20chars%20%3D%20%22salute%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20deve%20esser%204%0A%20%20%20%20%2F%2F%20nam%20chars%20es%204%20bytes%20noi%20posse%20converter%20les%20a%20u32%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A
  - en:
      title: String
      content_markdown: |
        A **String** is a struct that owns a sequence of utf-8 bytes in heap memory.

        Because its memory is on the heap, it can be extended, modified, etc. in ways string literals cannot.

        Common methods:

        * `push_str` to add more utf-8 bytes to the end of a string.
        * `replace` to replace sequences of utf-8 bytes with others.
        * `to_lowercase`/`to_uppercase` for case changes.
        * `trim` for trimming space

        When a String is dropped, it's heap memory is also dropped.

        `String` has a `+` operator that extends the string with a `&str` and returns itself, but it might not be as ergonomic as you hope for.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20helloworld%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%20%20%20%20helloworld.push_str(%22%20world%22)%3B%0A%20%20%20%20helloworld%20%3D%20helloworld%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%7D%0A
    fr:
      title: String
      content_markdown: |
        Une structure **String** possède une séquence de bytes utf-8 située sur le tas (en anglais heap).

        Du fait que la donnée se trouve sur le tas, celle-ci peut être étendue, modifiée, etc., contrairement
        aux chaînes de caractères (en anglais string literals).

        Méthodes utiles:

        * `push_str` pour ajouter d'autres bytes utf-8 à la fin.
        * `replace` pour remplacer une séquence de bytes utf-8 par une autre.
        * `to_lowercase`/`to_uppercase` pour tout mettre en minuscule ou en majuscule.
        * `trim` pour supprimer les espaces.

        Lorsqu'une structure String est désallouée, ses données
        se trouvant sur la pile le sont également.

        Une structure `String` possède l'opérateur `+` qui permet d'étendre la structure
        avec une autre chaîne de caractères de type `&str` et retourne la structure,
        mais ce n'est peut-être pas aussi ergonomique que vous l'espérez.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20helloworld%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%20%20%20%20helloworld.push_str(%22%20world%22)%3B%0A%20%20%20%20helloworld%20%3D%20helloworld%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%7D%0A
    ie:
      title: String
      content_markdown: |
        Un **String** es un struct quel possede un sequentie de bytes in utf-8 in memorie sur li heap.

        Essente sur li heap, on posse extender e modificar it etc. con un flexibilitá quel ne trova se in string literals.

        Metodes comun:

        * `push_str` por adjunter plu bytes utf-8 al fine de un catene.
        * `replace` por remplazzar sequenties de bytes utf-8 con altris.
        * `to_lowercase`/`to_uppercase` por maju-/minusculisation.
        * `trim` por remover spacies

        Quande un String cade, su memorie sur li heap cade junt con it.

        `String` have un operator `+` con quel on extende it con un `&str` e retorna se self, ma it ne es tam ergonomic quam on vell esperar.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20salute_munde%20%3D%20String%3A%3Afrom(%22salute%22)%3B%0A%20%20%20%20salute_munde.push_str(%22%20munde%22)%3B%0A%20%20%20%20salute_munde%20%3D%20salute_munde%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20salute_munde)%3B%0A%7D%0A
  - en:
      title: Text As Function Parameters
      content_markdown: |
        String literals and strings are generally passed around as a string slice to functions. This offers a lot of flexibility for
        most scenarios where you don't actually have to pass ownership.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20borrow%20%26%27static%20str%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%22hello%22)%3B%0A%20%20%20%20%2F%2F%20say_it_loud%20can%20also%20borrow%20String%20as%20a%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22goodbye%22))%3B%0A%7D%0A

    fr:
      title: Texte en tant que paramètre de fonction
      content_markdown: |
        Les chaînes de caractères et les structures String sont généralement passées aux fonctions sous forme de 'string slice'.
        Cela offre beaucoup de flexibilité pour la plupart des scénarios où vous n'avez pas besoin de transmettre la propriété (en anglais ownership).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20peut%20emprunter%20%26%27static%20str%20en%20tant%20que%20%26str%0A%20%20%20%20say_it_loud(%22bonjour%22)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20say_it_loud%20peut%20%C3%A9galement%20emprunter%20String%20en%20tant%20que%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22au%20revoir%22))%3B%0A%7D%0A

    ie:
      title: Textu quam Parametres de Functiones
      content_markdown: |
        In general on transfere string literals e strings quam un string slice (tranche de caracteres) a functiones. Con to on have 
        flexibilitá in li pluparte de situationes quande on ne besona transferer proprietá.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20di_it_vocosimen(msg%3A%20%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2C%20msg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20di_it_vocosimen%20posse%20pruntar%20%26%27static%20str%20quam%20un%20%26str%0A%20%20%20%20di_it_vocosimen(%22salute%22)%3B%0A%20%20%20%20%2F%2F%20di_it_vocosimen%20posse%20anc%20pruntar%20String%20quam%20un%20%26str%0A%20%20%20%20di_it_vocosimen(%26String%3A%3Afrom(%22a%20revidentie%22))%3B%0A%7D%0A
  - en:
      title: Building Strings
      content_markdown: |
        `concat` and `join` are two simple but powerful ways for building strings.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22hello%22%2C%20%22%20%22%2C%20%22world%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A

    fr:
      title: Construction de String
      content_markdown: |
        `concat` et` join` sont deux façons simples mais puissantes de construire les structures String.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22hello%22%2C%20%22%20%22%2C%20%22world%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A

    ie:
      title: Construction de Strings
      content_markdown: |
        Li simplic ma potent `concat` e `join` possibilisa li creation de catenes.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20salute_munde%20%3D%20%5B%22salute%22%2C%20%22%20%22%2C%20%22munde%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20salute_munde)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20abc)%3B%0A%7D%0A
  - en:
      title: Formatting Strings
      content_markdown: |
        The `format!` macro allows us to create a string by defining a parameterized string with placeholders for where and how values should be placed (e.g. `{}`).

        `format!` uses the same parameterized strings as `println!`

        The capabilities of this function are too large of scope for *Tour of Rust*, check out the documentation [here](https://doc.rust-lang.org/std/fmt/)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22secret%20to%20life%3A%20%7B%7D%22%2Ca)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cf)%3B%0A%7D%0A

    fr:
      title: Formatage de Strings
      content_markdown: |
        La macro `format!` nous permet de créer une chaîne de caractères en définissant
        une chaîne paramétrée avec des espaces réservés (e.g. `{}`) qui seront remplacés
        par certaines valeurs.

        `format!` utilise les mêmes chaînes de caractères paramétrées que `println!`.

        Les possibilités offertes par cette fonction sont trop larges pour être toutes
        vues dans note modeste * Tour de Rust *. Si vous souhaitez cependant en savoir plus,
        vous pouvez consulter la documentation [ici](https://doc.rust-lang.org/std/fmt/).
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22secret%20de%20la%20vie%3A%20%7B%7D%22%2Ca)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cf)%3B%0A%7D%0A

    ie:
      title: Formate de Strings
      content_markdown: |
        Con li macro `format!` noi posse crear un catene per definir un tal quel es parametrisat con placeholders (marcas substitutiv) pri u e qualmen li valores deve esser plazzat (usante `{}`).

        `format!` usa li sam catenes parametrisat quam tis in `println!`

        Li capabilitás de ti-ci function es tro grand por nor litt *Tour of Rust*; plu detallies trova se [in li documentation](https://doc.rust-lang.org/std/fmt/)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22secrete%20del%20vive%3A%20%7B%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f)%3B%0A%7D%0A
  - en:
      title: Converting Strings
      content_markdown: |
        Many types can be converted to a string using `to_string`.

        The generic function `parse` can be used to convert strings 
        or string literals into a typed value. This function returns 
        a `Result` because it could fail.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A

    fr:
      title: Conversion en String
      content_markdown: |
        Plusieurs types peuvent être convertis en String en utilisant `to_string`.

        La fonction générique `parse` peut être utilisée pour convertir une structure String
        ou une chaîne de caratères en un autre type.

        La fonction de l'exemple ci-contre retourne une structure `Result` car elle pourrait échouer.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A

    ie:
      title: Conversion de Strings
      content_markdown: |
        On posse utilisar `to_string` por converter mult tipes a un string.

        Li function géneric `parse` posse esser usat por converter strings o string literals
        ad-in un altri tip. Ti-ci function retorna un `Result` pro li possibilitá
        de falliment.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
  - en:
      title: Chapter 6 - Conclusion
      content_markdown: |
        Now you know the basics of text!  As you have seen, unicode makes working with text a bit tricky, but the standard library 
        has plenty of functionality to make it easy to manage.  

        Up to now, we've mostly looked at Rust from the lens of a procedural paradigm (i.e. just functions and data),
        it's time we now talk about traits and the capabilties unlocked by Rust's object oriented paradigm.
    fr:
      title: Chapitre 6 - Conclusion
      content_markdown: |
        Maintenant, tu sais tout ce que tu as à connaître sur la gestion des textes avec Rust!
        Comme tu l'as vu, l'encodage unicode rend le travail avec le texte un peu délicat,
        mais la bibliothèque standard de Rust possède beaucoup de fonctionnalités pour nous
        éviter ce travail.

        Jusqu'à présent, nous avons principalement utilisé Rust avec le paradigme de programmation
        procédural (e.g. uniquement des fonctions avec des données).
        Il est temps que nous parlions maintenant des traits (c'est le même terme en anglais)
        et des capacités débloquées par le paradigme de programmation orienté objet de Rust.
    ie:
      title: Capitul 6 - Conclusion
      content_markdown: |
        Nu tu comprende li basic coses a saver pri textu! Quam ja videt, unicode fa li manipulation de textu un poc desfacil, ma in li
        standard library trova se mult functionalitá con quel it deveni plu facil.

        Til nu noi ha videt Rust del vispunctu procedural (a saver solmen functiones e data), ma li témpor ha venit
        por parlar pri traits (trates) e li capabilitás liberat del paradigma "object oriented" (object-orientat) de Rust.
  - chapter: 7
    en:
      title: Chapter 7 - Object Oriented Programming
      content_markdown: |
        Expressing ideas with functions is a proven way of representing behavior and data (C 
        has been doing it for decades!). Historically, computer science has found other
        useful expressive aggregations and abstractions for data. You may be familiar with object oriented programming (OOP) as one
        such way. In this chapter we'll explore the Rust programming language beyond functions.

    fr:
      title: Chapitre 7 - Programmation orientée object
      content_markdown: |
        L'utilisation de fonctions pour exprimer une idée ou modéliser le comportement
        et les données d'un programme a toujours été une manière éprouvée d'écrire un
        programme (C le fait depuis des décennies!). Cependant, il existe d'autres paradigmes
        de programmation permettant l'agrégation et l'abstraction de données. Vous connaissez
        peut-être déjà la programmation orientée objet (POO). Dans ce chapitre, nous
        explorerons le langage de programmation Rust au-delà des fonctions.

    ie:
      title: Capitul 7 - Object-orientat Programmation
      content_markdown: |
        Li expression de idés tra functiones es un metode pruvat por representar conduida e data (C ha
        fat talmen durant decennies!). Historicmen, scientie computoral ha trovat altri expressiv e
        util agregationes e abstractiones por data. Tu es cert familiari con object-orientat programmation (OOP)
        quam un tal metode. In ti-ci capitul noi va explorar li lingue de programmation Rust ultra functiones.
  - en:
      title: What Is OOP?
      content_markdown: |
        Object oriented programming roughly refers to programming languages that have a number of iconic features:
        * Encapsulation - Associating data and functions into the conceptual unit of a single type called an *object*.
        * Abstraction - Hiding data and function members to obsfucate implementation details of an object.
        * Polymorphism - The ability to interacting with an object from different functional perspectives.
        * Inheritence - The ability to inherit data and behavior from other objects.

    fr:
      title: Qu'est-ce que la POO?
      content_markdown: |
        La programmation orientée objet se réfère grossièrement aux langages de
        programmation qui possèdent un certain nombre des fonctionnalités suivantes:
        * Encapsulation - Association de champs et de fonctions dans une seule unitée
        appelée *objet*.
        * Abstraction - Dissimulation des champs et des fonctions pour cacher les
        détails de l'implémentation d'un objet.
        * Polymorphisme - Mettre à disposition une interface unique pour des entités
        pouvant avoir des types différents.
        * Héritage - La capacité d'un objet d'hériter des caractéristiques d'un autre
        objet.

    ie:
      title: Quo es OOP?
      content_markdown: |
        Object-orientat programmation, curtmen dit, parla pri lingues de programmation con quelc trates iconic:
        * Objectes - Ili converge data e functiones ad-in li unitá conceptional de un singul tip nominat un *objecte*.
        * Incapsulation - On cela data e membres de functiones por obfuscacr detallies de implementation de un objecte.
        * Polimorfisme - Li habilitá de interacter con un objecte ex diferent perspectives functional.
        * Heredantie (inheritance) - Li habilitá de heredar data e conduida de altri objectes.
  - en:
      title: Rust Is Not OOP
      content_markdown: |
        Rust lacks inheritance of data and behavior in any meaningful way.

        * Structs cannot inherit fields from a parent struct.
        * Structs cannot inherit functions from a parent struct.

        That said, Rust implements many programming language features that you might not mind this lacking.

    fr:
      title: Rust n'est pas POO
      content_markdown: |
        Il n'y a pas d'héritage avec Rust.

        * Les structures ne peuvent pas hériter des champs d'une structure parente.
        * Les structures ne peuvent pas hériter des fonctions d'une structure parente.

        Cela dit, Rust implémente de nombreuses fonctionnalités qui nous permettent
        de ne pas regretter l'héritage.        

    ie:
      title: Rust ne es OOP
      content_markdown: |
        A Rust manca li grand trates de heredantie de data e conduida.

        * Structs ne posse heredar campes de un struct genitori.
        * Structs ne posse heredar functiones de un struct genitori.

        Malgré to, Rust implementa mult trates programmistic con queles tu certmen ne va suciar te pri lor absentie.
  - en:
      title: Encapsulation With Methods
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20creature.get_sound())%3B%0A%7D%0A
      content_markdown: |
        Rust supports the concept of an *object* that is a struct associated with some functions (also known as *methods*).

        The first parameter of any method must be a reference to the instance associated with the method call (e.g. `instanceOfObj.foo()`). Rust uses:
        * `&self` - Immutable reference to the instance.
        * `&mut self` - Mutable reference to the instance.

        Methods are defined within an implementation block with keyword `impl`:
        ```rust
        impl MyStruct { 
            ...
            fn foo(&self) {
                ...
            }
        }
        ```

    fr:
      title: Encapsulation avec des méthodes
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20creature.get_sound())%3B%0A%7D%0A
      content_markdown: |
        Avec Rust, un objet est représenté par une structure. On peut associer
        à celle-ci certaines fonctions (également appelées *méthodes*).

        Le premier paramètre de toute méthode doit être une référence de l'instance
        associée à l'appel de la méthode (par exemple `instanceOfObj.foo()`).
        Rust utilise:
        * `&self` - Référence immuable de l'instance.
        * `&mut self` - Référence mutable de l'instance.

        Les méthodes sont définies dans un bloc d'implémentation
        avec le mot clé `impl`:
        ```rust
        impl MyStruct { 
          ... 
          fn foo(&self){
            ...
          }
        }
        ```

    ie:
      title: Metodes por Objectes
      content_markdown: |
        Rust subtene li concepte de un *object* quam un struct con functiones associat (anc conosset quam *metodes*).

        Li unesim parametre de quelcunc metode deve esser un referentie al instantie associat con li voca del metode (p.ex. `instantieDeObj.foo()`) Rust usa:
        * `&self` - Ínmutabil referentie al instantie.
        * `&mut self` - Mutabil referentie al instantie.

        Metodes es definat inter:
        ```rust
        impl MyStruct {
            ...
            fn foo(&self) {
                ...
            }
        }
        ```
  - en:
      title: Abstraction With Selective Exposure
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20%26creature.get_sound())%3B%0A%7D%0A
      content_markdown: |
        Rust can hide the inner workings of objects.

        By default fields and methods are accessible only to the module they belong to.

        The `pub` keyword exposes struct fields and methods outside of the module.
    fr:
      title: Abstraction avec différents niveaux de visibilité
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20%26creature.get_sound())%3B%0A%7D%0A
      content_markdown: |
        Rust peut encapsuler le fonctionnement interne des objets.

        Par défaut, les champs et les méthodes ne sont accessibles
        qu'à l'intérieur du module auquel ils appartiennent.

        Le mot-clé `pub` permet d'exposer un champ ou une méthode
        pour qu'il ou elle soit visible en dehors d'un module.
    ie:
      title: Incapsulation in Objectes
      content_markdown: |
        Rust posse celar li activitá intern de objectes.

        Predefinitmen, campes e metodes es accessibil solmen al modul a quel ili apartene.

        Li clave-parol `pub` exposi campes e metodes del structes éxter li modul.
  - en:
      title: Polymorphism With Traits
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A
      content_markdown: |
        Rust supports polymorphism with traits. Traits allow us to associate a set of methods with a struct type. 

        We first define the signatures of methods of a trait within:

        ```
        trait MyTrait {
            fn foo(&self);
            ...
        }
        ```

        When a struct implements a trait, it establishes a contract that allows us to indirectly interact with the struct 
        through the trait type (e.g. `&dyn MyTrait`) without having to know the real type.

        A struct's implemented traits methods are defined within an implementation block:

        ```rust
        impl MyTrait for MyStruct { 
            fn foo(&self) {
                ...
            }
            ... 
        }
        ```

    fr:
      title: Polymorphisme avec les traits
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A
      content_markdown: |
        Rust rend possible le polymorphisme grâce aux 'traits'. Les traits
        nous permettent d'associer un ensemble de méthodes à une structure.

        Il faut tout d'abord définir la signature des méthodes d'un trait:

        ```
        trait MyTrait {
          fn foo(&self);
          ...
        }
        ```

        Quand une structure implémente un trait, le trait établit un contrat entre
        la structure et les méthodes que la structure doit implémenter. Cela nous
        permetra d'interagir avec la structure à travers le type du trait
        (par exemple `&dyn MyTrait`) sans avoir à connaître le type réel.

        Les méthodes du trait implémentées par la structure sont définies dans un bloc
        d'implémentation:

        ```rust
        impl MyTrait for MyStruct { 
          fn foo(&self){
            ...
          }
          ... 
        }
        ```

    ie:
      title: Polimorfisme con Trates
      content_markdown: |
        Rust subtene polimorfisme con trates (traits). Con trates noi posse associar un gruppe de metodes con un tip de struct.

        Ante omno, noi defina li signaturas de metodes de un trate intra:
        ```
        trait MiTrate {
            fn foo(&self);
            ...
        }
        ```

        Quande un struct implementa un trate, it etablisse un contracte secun quel noi posse índirectmen interacter con li struct
        tra li tip del trate (p.ex. `&dyn MiTrate`) sin dever conossen li ver tip.

        Li implementat trate-metodes de un struct es definat intra:

        ```rust
        impl MiTrate for MyStruct {
            fn foo(&self) {
                ...
            }
            ...
        }
        ```

  - en:
      title: Implemented Methods On Traits
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%20%20%20%20%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
      content_markdown: |
        Traits can have implemented methods.

        The functions have no direct access to the inner fields of a struct, but it can 
        be useful for sharing behavior between many trait implementors.

    fr:
      title: Méthodes implémentées sur les traits
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%20%20%20%20%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
      content_markdown: |
        Un 'trait' peut lui-même implémenter une ou plusieurs méthodes.

        Les méthodes d'un trait n'ont pas accès aux champs des structures
        mais elles peuvent être utiles pour partager un comportement
        entre plusieurs implémentations de traits.

    ie:
      title: Implementat Metodes sur Trates
      content_markdown: |
        Trates posse haver metodes implementat.

        Li functiones have null direct accesse al inter campes de un struct, ma it posse esser
        util por partiprender conduida inter mani implementatores de trates.
  - en:
      title: Trait Inheritence
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Atrait%20LoudNoiseMaker%3A%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20LoudNoiseMaker%20for%20SeaCreature%20%7B%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
      content_markdown: |
        Traits can inherit methods from other traits.

    fr:
      title: Hériter d'un trait
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Atrait%20LoudNoiseMaker%3A%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20LoudNoiseMaker%20for%20SeaCreature%20%7B%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
      content_markdown: |
        Un trait peut hériter d'un autre trait.

    ie:
      title: Heredantie de Trates
      content_markdown: |
        Trates posse heredar metodes ex altri trates.
  - en:
      title: Dynamic vs Static Dispatch
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20static_make_noise(creature%3A%20%26SeaCreature)%20%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20dynamic_make_noise(noise_maker%3A%20%26dyn%20NoiseMaker)%20%7B%0A%20%20%20%20%2F%2F%20we%20don't%20know%20the%20real%20type%0A%20%20%20%20noise_maker.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20static_make_noise(%26creature)%3B%0A%20%20%20%20dynamic_make_noise(%26creature)%3B%0A%7D%0A
      content_markdown: |
        Methods are executed in two ways:
        * static dispatch - When the instance type is known, we have direct knowledge of what function to call.
        * dynamic dispatch - When an instance type is not known, we must find out some way of calling the correct function.

        Traits types `&dyn MyTrait` give us the ability to work with instances of objects indirectly using dynamic dispatch.

        When dynamic dispatch is used, Rust will encourage you to put `dyn` before your trait type so people are aware.

        Memory details:
        * Dynamic dispatch is slightly slower because of the pointer chasing to find the real function call.
    fr:
      title: Dispatch dynamique ou statique
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20static_make_noise(creature%3A%20%26SeaCreature)%20%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20dynamic_make_noise(noise_maker%3A%20%26dyn%20NoiseMaker)%20%7B%0A%20%20%20%20%2F%2F%20we%20don't%20know%20the%20real%20type%0A%20%20%20%20noise_maker.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20static_make_noise(%26creature)%3B%0A%20%20%20%20dynamic_make_noise(%26creature)%3B%0A%7D%0A
      content_markdown: |
        Une méthode est exécutée de deux manières:
        * Dispatch statique - Lorsque le type de l'instance est connu, nous avons
        une connaissance directe de la méthode à appeler.
        * Dispatch dynamique - Lorsque le type de l'instance n'est pas connu, Rust
        doit se débrouiller pour appeler la bonne méthode.

        Les types de traits `&dyn MyTrait` nous permettent de travailler indirectement
        avec des instances d'objets en utilisant un dispatch dynamique.

        Lorsque qu'un dispach dynamique est utilisé, Rust nous encouragera (il affichera
        un warning) à placer `dyn` devant le type du trait pour indiquer que c'est un
        trait.

        Détails de la mémoire:
        * Le dispach dynamique est légèrement plus lent que le dispatch statique car
        il faut trouver la méthode à appeler.
    ie:
      title: Dinamic contra Static Dispatch (Depeche)
      content_markdown: |
        On execute metodes secun du manieres quam seque:
        * dispatch static - Quande on save li tip del instantie, noi save directmen pri quel function a vocar.
        * dispatch dinamic - Quande on ne save li tip del instantie, noi deve trovar un maniere por vocar li function corect.

        Li tip de un trate `&dyn MyTrait` possibilisa li manipulation de objectes índirectmen con dispatch dinamic.
  - en:
      title: Trait Objects
      content_markdown: |
        When we pass an instance of an object to a parameter of type `&dyn MyTrait` we pass what is called *trait object*. 

        A trait object is what allows us to indirectly call the correct methods of an instance. A trait object is a struct that holds the pointer of 
        our instance with a list of function pointers to our instance's methods.

        Memory details:
        * This list of functions is known in C++ as a *vtable*.
    fr:
      title: Objets trait
      content_markdown: |
        Lorsque nous transmettons l'instance d'un objet à un paramètre de
        type `&dyn MyTrait`, nous transmettons ce que l'on appelle un
        *objet trait* (en anglais trait object).

        Un objet trait est ce qui nous permet d'appeler indirectement les bonnes
        méthodes d'une instance via un dispach dynamique. Un objet trait est une
        structure qui contient le pointeur de l'instance ainsi qu'une liste de
        pointeurs vers les méthodes de cette instance.

        Détails de la mémoire:
        * Cette liste de fonctions est connue en C++ sous le nom de *vtable*.
        
    ie:
      title: Trate-Objectes
      content_markdown: |
        Quande noi transfere un instantie de un objecte a un parametre del tip `&dyn MyTrait` noi transfere un cose nominat un *trait object*.

        Un trait object es to quel auxilia nos índirectmen vocar li corect metodes de un instantie. Un trait object es un struct quel tene li puntator de
        nor instantie con un liste de puntatores del functiones al metodes de nor instantie.

        Detallies pri memorie:
        * On conosse ti-ci liste de functiones in C++ quam un *vtable*.
  - en:
      title: Handling Unsized Data
      content_markdown: |
        Traits introduce an interesting challenge when we want to store them within another struct. Traits obsfucate the original
        struct thus it also obsfucates the original size. Unsized values being stored in structs are handled in two ways in Rust:

        * `generics` - Using parameterized types effectively create struct/functions known types and thus known sizes.
        * `indirection` - Putting instances on the heap gives us a level of indirection that allow us to not have to worry about the size of the actual type and just store a pointer to it. There are other ways as well!

    fr:
      title: Gestion de données sans taille
      content_markdown: |
        Les traits présentent un défi intéressant lorsque nous voulons les stocker
        dans une autre structure. Les traits masquent la structure originelle et
        notamment sa taille. Avec Rust, les éléments sans taille connue et qui sont
        stockées dans une structure sont traitées de deux manières:

        * `génériques` - Le compilateur Rust créer des structures ou des fonctions
        dont la taille est connue par l'utilisation de types paramétrés (génériques).
        * `données sur le tas` - En mettant l'instance sur le tas et en stockant
        uniquement un pointeur vers cette instance. Cela nous donne un niveau
        d'indirection nous évitant d'avoir à se soucier de la taille du type. Il
        existe également d'autres moyens!

    ie:
      title: Gerer Data sin Grandore
      content_markdown: |
        Trates introducte un defí interessant quande noi intente plazzar les in un altri struct. Trates obfusca li original struct
        e pro to obfusta anc li grandore original. In Rust on plazza valores sin grandore in structs secun li metodes a sequer:

        * `génerics` - Usante tipes parametrisat on crea conosset tipes de structs/functiones (e pro to con un grandore conosset) con efectivitá.
        * `data sur li heap` - Plazzante instanties sur li heap da nos un nivelle de índirection con quel noi ne deve suciar pri li grandore del ver tip - on plazza un puntator e li afere es liquidat.
  - en:
      title: Generic Functions
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise%3CT%3E(creature%3A%20%26T)%0Awhere%0A%20%20%20%20T%3A%20NoiseMaker%2C%0A%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%20at%20compile-time%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
      content_markdown: |
        Generics in Rust work hand in hand with traits. When we describe a parameterized type `T` we can constrain what types 
        can be used as an argument by listing what required traits the argument must implement.

        In this example type `T` must implement trait `Foo`:
        ```rust
        fn my_function<T>(foo: T)
        where
            T:Foo
        {
            ...
        }
        ```

        By using generics we create static typed functions at compile time that will have known types and sizes, allowing us to
        perform static dispatch and store as a sized value.

    fr:
      title: Fonctions géneriques
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise%3CT%3E(creature%3A%20%26T)%0Awhere%0A%20%20%20%20T%3A%20NoiseMaker%2C%0A%7B%0A%20%20%20%20%2F%2F%20Le%20type%20est%20connu%20%C3%A0%20la%20compilation%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
      content_markdown: |
        Avec Rust les génériques vont de pair avec les traits. Lorsqu'un paramètre
        de fonction est un type paramétré `T`, le compilateur contraint les types qui
        peuvent être utilisés comme argument de la fonction. Le mot-clé `where` permet
        de lister les traits que l'argument doit implémenter.

        Dans cet exemple, le type `T` doit implémenter le trait` Foo`:
        ```rust
        fn my_function<T>(foo: T)
        where
            T:Foo
        {
            ...
        }
        ```

        En utilisant des génériques, nous créons des fonctions statiquement typées
        au moment de la compilation dont le type et la taille seront connus. Cela
        nous permet d'effectuer un dispatch statique et de stocker des valeurs dont
        la taille est connue.

    ie:
      title: Functiones Géneric
      content_markdown: |
        Génerics in Rust labora manu a manu con trates. Quande noi descri un parametrisat tip `T` noi posse limitar li tipes queles
        posse esser usat quam argument per un inlistation del trates queles li argument deve implementar.

        In ti-ci exemple, li tip `T` deve implementar li trate `Foo`:
        ```rust
        fn mi_function<T>(foo: T)
        where
            T:Foo
        {
            ...
        }
        ```

        Usante génerics noi posse crear functiones static tipat durant li compilation con conosset tipes e grandores, con quel noi posse
        usar dispatch static e plazzar les quam valores con grandores conosset.
  - en:
      title: Generic Function Shorthand
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise(creature%3A%20%26impl%20NoiseMaker)%0A%7B%0A%20%20%20%20%2F%2F%20we%20know%20the%20real%20type%20at%20compile-time%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
      content_markdown: |
        Rust has a shorthand for expressing generics constrained by a trait:
        
        ```rust
        fn my_function(foo: impl Foo) {
            ...
        }
        ```

        This is equivalent to writing:

        ```rust
        fn my_function<T>(foo: T)
        where
            T:Foo
        {
            ...
        }
        ```

    fr:
      title: Fonctions génériques condensées
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise(creature%3A%20%26impl%20NoiseMaker)%0A%7B%0A%20%20%20%20%2F%2F%20Le%20type%20est%20connu%20%C3%A0%20la%20compilation.%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
      content_markdown: |
        Rust possède un raccourci pour exprimer les génériques contraintes par
        un trait:
        
        ```rust
        fn my_function(foo: impl Foo) {
            ...
        }
        ```

        Cela équivaut à écrire:

        ```rust
        fn my_function<T>(foo: T)
        where
            T:Foo
        {
            ...
        }
        ```

    ie:
      title: Abreviation de Functiones Géneric
      content_markdown: |
        In Rust on posse abreviar li expression de génerics limitat per un trate:

        ```rust
        fn mi_function(foo: impl Foo) {
            ...
        }
        ```

        equivale scrir:

        ```rust
        fn miFunction<T>(foo: T)
        where
            T: Foo
        {
            ...
        }
        ```
  - en:
      title: Box
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Ocean%20%7B%0A%20%20%20%20animals%3A%20Vec%3CBox%3Cdyn%20NoiseMaker%3E%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22swish%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20ocean%20%3D%20Ocean%20%7B%0A%20%20%20%20%20%20%20%20animals%3A%20vec!%5BBox%3A%3Anew(ferris)%2C%20Box%3A%3Anew(sarah)%5D%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20for%20a%20in%20ocean.animals.iter()%20%7B%0A%20%20%20%20%20%20%20%20a.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A
      content_markdown: |
        `Box` is a data structure that allows us to move our data from the stack to the heap.

        `Box` is a struct known as a *smart pointer* that holds the pointer to our data on the heap.

        Because `Box` is a struct with a known size (because it just holds a pointer), it is 
        often used as a way to store a reference to something in a struct that must know the size 
        of its fields.

        `Box` is so common it can be used from anywhere:

        ```rust
        Box::new(Foo { ... })
        ```

    fr:
      title: Box
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Ocean%20%7B%0A%20%20%20%20animals%3A%20Vec%3CBox%3Cdyn%20NoiseMaker%3E%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22chante%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20ocean%20%3D%20Ocean%20%7B%0A%20%20%20%20%20%20%20%20animals%3A%20vec!%5BBox%3A%3Anew(ferris)%2C%20Box%3A%3Anew(sarah)%5D%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20for%20a%20in%20ocean.animals.iter()%20%7B%0A%20%20%20%20%20%20%20%20a.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A
      content_markdown: |
        `Box` est une structure de données qui permet de déplacer les données
        de la pile vers le tas.

        `Box` est également appelé *pointeur intelligent* (en anglais smart
        pointer) qui contient un pointeur vers des données sur le tas.

        `Box` étant de taille connue (la taille du pointeur), on l'utilise
        souvent comme un moyen de stocker une référence dans une structure
        lorsque cette dernière doit connaître la taille de certains éléments.

        `Box` est très souvent utilisé et on le fait de cette manière:

        ```rust
        Box::new(Foo { ... })
        ```

    ie:
      title: Buxe
      content_markdown: |
        Un buxe (`Box`) es un structura de data quel auxilia nos transferer nor data del stack al heap.

        `Box` es un struct conosset quam un *smart pointer* (puntator inteligent) quel tene li puntator a nor data sur li heap.

        Nam `Box` es un struct con grandore conosset (nam it tene solmen un puntator), on usa it sovente
        por plazzar un referentie a alquo in un struct quel deve conosser li grandore de su campes.

        `Box` es tam frequentmen usat que on posse usar it omniloc:

        ```rust
        Box::new(Foo { ...})
        ```
  - en:
      title: Generic Structs Revisited
      content_markdown: |
        Generic structs can also have their parameterized types constrained by traits.

        ```rust
        struct MyStruct<T>
        where
            T: MyTrait
        {
            foo: T
            ...
        }
        ```

        Generic structs have their parameterized type in their implementation blocks:

        ```rust
        impl<T> MyStruct<T> {
            ...
        }
        ```
    fr:
      title: Structures génériques revisitées
      content_markdown: |
        Les types d'une structure générique peuvent également être contraints par des
        traits.

        ```rust
        struct MyStruct<T>
        where
            T: MyTrait
        {
            foo: T
            ...
        }
        ```
        Quant à la définition des méthodes d'une structure paramétrée, celle-ci
        est faite de la manière suivante (le type paramétré peut être utilisé
        dans le bloc d'implémentation):

        ```rust
        impl<T> MyStruct<T> {
            ...
        }
        ```
    ie:
      title: Un Revisitation al Structs Géneric
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Ocean%3CT%3E%0Awhere%0A%20%20%20%20T%3A%20NoiseMaker%2C%0A%7B%0A%20%20%20%20animals%3A%20Vec%3CT%3E%2C%0A%7D%0A%0Aimpl%3CT%3E%20NoiseMaker%20for%20Ocean%3CT%3E%0Awhere%0A%20%20%20%20T%3A%20NoiseMaker%2C%0A%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20for%20a%20in%20self.animals.iter()%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20a.make_noise()%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22swish%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20ocean%20%3D%20Ocean%20%7B%0A%20%20%20%20%20%20%20%20animals%3A%20vec!%5Bferris%2C%20sarah%5D%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ocean.make_noise()%0A%7D%0A
      content_markdown: |
        Anc structs géneric posse usar trates por limitar lor tipes parametrisat.

        ```rust
        struct MiStruct<T>
        where
            T: MiTrate
        {
            foo: T
            ...
        }
        ```

        Struct-metodes e implementat trate-metodes por géneric structs have li parametrisat tip del struct sur li clave-parol `impl`:

        ```rust
        impl<T> MiStruct<T> {
            ...
        }
        ```

  - en:
      title: Chapter 7 - Conclusion
      content_markdown: |
        We now have more language features at hand to represent our ideas clearly! 
        Rust abstractions might be simple but they are powerful enough to make
        working with code a joy. In this chapter, we caught a glimpse of smart pointers
        with `Box`. In the next chapter we'll learn about how smart pointers can help us with other
        specialized memory situations.

        Resources:
        * [Video - Object-oriented Programming in 7 minutes](https://www.youtube.com/watch?v=pTB0EiLXUC8)
        * [Article - "The faster you unlearn OOP, the better for you and your software"](https://dpc.pw/the-faster-you-unlearn-oop-the-better-for-you-and-your-software)
    fr:
      title: Chapitre 7 - Conclusion
      content_markdown: |
        Nous en savons désormais beaucoup pour pouvoir représenter clairement
        nos idées avec Rust! Les abstractions peuvent sembler simples mais elles
        sont suffisamment puissantes pour faire en sorte qu'écrire un programme
        Rust devienne une partie de plaisir. Dans ce chapitre, nous avons vu très
        brièvement les pointeurs intelligents avec `Box`. Dans le chapitre suivant,
        nous découvrirons comment les pointeurs intelligents peuvent nous aider
        dans d'autre cas où une gestion spéciale de la mémoire est requise.

        Bien que les ressources suivantes soient en anglais, nous vous recommendons
        celles-ci. Car de toute façon il faudra bien se mettre à l'anglais,
        pas vrai <span class=\"emoji\">\U0001F604</span>?
        * [Video - La programmation orientée objet en 7 minutes](https://www.youtube.com/watch?v=pTB0EiLXUC8)
        * [Article - Le plus rapidement vous oublierez la POO, le mieux cela sera pour vous et votre logiciel](https://dpc.pw/the-faster-you-unlearn-oop-the-better-for-you-and-your-software)
    ie:
      title: Capitul 7 - Conclusion
      content_markdown: |
        Noi ja conosse plu caractersticas del lingue por auxilia nos clarmen representar nor idés!
        Benque abstractiones in Rust es simplic, ili es tam potent que ili da nos joya quande noi
        scri nor code. In ti-ci capitul noi brevmen videt puntatores inteligent con `Box`.
        In li capitul a sequer noi va aprender pri qualmen puntatores inteligent posse auxiliar nos
        in altri situationes specialisat in li gerentie de memorie.
  - chapter: 8
    en:
      title: Chapter 8 - Smart Pointers
      content_markdown: |
        In this chapter we will demystify smart pointers. Let's explore into
        these data structures that let us interact with the lowest level of 
        memory.
        
        Ferris says: "Don't feel overwhelmed by this chapter if you don't feel 
        you can write your own low level memory management code in one short read. This chapter 
        is mostly to introduce you to some useful tools and give a glimpse at how they work!"
    fr:
      title: Chapitre 8 - Pointeurs intelligents (smart pointers)
      content_markdown: |
        Dans ce chapitre, nous allons démystifier les pointeurs intelligents
        (en anglais Smart Pointers). Explorons ces structures de données qui
        nous permettent d'interagir au plus bas niveau de la Mémoire.
      
        Ferris dit: "Ne te sens pas submergé par ce chapitre, je n'attends pas de
        toi que tu sois capable d'écrire ton propre code de gestion de la mémoire
        bas niveau après une première lecture. Ce chapitre est surtout là pour te
        présenter quelques outils utiles et te donner un aperçu de leur
        fonctionnement!"
    ie:
      title: Capitul 8 - Smart Pointers
      content_markdown: |
        In ti-ci capitul noi va remover li misterie de smart pointers (puntatores inteligent).
        On va explorar pri qualmen ti data-structuras possibilisa li interaction con memorie
        sur li nivelles max bass.

        Ferris di: "Ne esse aplastat per li desfacilitás in ti-ci capitul si tu ne es strax pret
        a scrir tui propri code por gerer memorie ye bass nivelles. It mey servir solmen por
        conossentar te con quelc util utensiles e qualmen ili functiona!" 

  - en:
      title: References Revisited
      content_markdown: |
        A reference is fundamentally just a number that is the start position
        of some bytes in memory, it's only purpose is to represent the concept of 
        where data of a specific type exists. What makes a reference different from a just a number is that Rust
        will validate the lifetime of references doesn't last longer than what
        it refers to (otherwise we'd get an error when we used it!).
        
    fr:
      title: Références revisitées
      content_markdown: |
        Une référence est fondamentalement juste un nombre qui donne la position
        de départ d'octets en mémoire, son seul but est d'indiquer où des données
        d'un type spécifique sont situés en mémoire. Une référence n'est pas juste
        qu'un nombre, Rust va valider la durée de vie de la référence pour qu'elle ne
        dépasse par celle de l'objet qu'elle réfère (sinon nous obtiendrions une
        erreur dès que nous essayerions de l'utiliser!).
        
    ie:
      title: Denov pri Referenties
      content_markdown: |
          Li concepte de un referentie es quam seque: it es solmen un numeró quel 
          monstra li position de comensa de quelc bytes in memorie; it servi solmen por representar 
          li concepte de ú existe li data de un cert tip. To quo fa un referentie diferent de un 
          simplic numeró es que Rust va far cert que li viv-témpore de un referentie ne dura plu 
          long quam li cose a quel it refere (altrimen noi vell incontrar un errore in su usation!).

  - en:
      title: Raw Pointers
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20memory_location%20%3D%20%26a%20as%20*const%20i32%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20is%20here%20%7B%7D%22%2C%20memory_location)%3B%0A%7D%0A
      content_markdown: |
        References can be converted into a more primitive type called a *raw pointer*. Much like a number, it
        can be copied and moved around with little restriction. Rust
        makes no assurances of the validity of the memory location it points to.

        Two kinds of raw pointers exist:

        * `*const T` - A raw pointer to data of type T that should never change.
        * `*mut T` - A raw pointer to data of type T that can change.

        Raw pointers can be converted to and from numbers (e.g. `usize`).

        Raw pointers can access data with *unsafe* code (more on this later).

        Memory Details:
        * A reference in Rust is very similar to a pointer in C in terms of usage, but with much more compile time restrictions on
          how it can be stored and moved around to other functions.
        * A raw pointer in Rust is similar to a pointer in C that it represents a number that can be copied 
          passed around, and even turned into numerical types where it can be modifed as a number to do pointer math.
    fr:
      title: Pointeurs bruts (en anglais raw pointers)
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20memory_location%20%3D%20%26a%20as%20*const%20i32%20as%20usize%3B%0A%20%20%20%20println!(%22La%20donn%C3%A9e%20se%20trouve%20%C3%A0%20l%27adresse%20m%C3%A9moire%20%7B%7D%22%2C%20memory_location)%3B%0A%7D%0A
      content_markdown: |
        Les références peuvent être converties en un type plus primitif appelé
        *pointeurs bruts* (en anglais raw pointers). Ce type de pointeur peut
        être copié et déplacé avec peu de restrictions. Cependant, Rust ne garantit
        pas la validité de l'emplacement de mémoire vers lequel il pointe.

        Il existe deux types de pointeurs bruts:

        * `*const T` - Un pointeur brut vers des données de type T qui ne devraient
        jamais changer.
        * `*mut T` - Un pointeur brut vers des données de type T qui peuvent
        changer.

        Les pointeurs bruts peuvent être convertis en et à partir de nombres
        (par exemple `usize`).

        Les pointeurs bruts peuvent accéder aux données avec un code *unsafe*
        (plus d'informations à ce sujet plus tard).

        Détails de la mémoire:
        * En termes d'utilisation, une référence en Rust est très similaire
        à un pointeur en C mais avec beaucoup plus de restrictions lors de la
        compilation (notamment sur la manière dont la référence peut être stockée
        et déplacée vers d'autres fonctions).
        * Un pointeur brut en Rust est similaire à un pointeur en C du fait qu'ils
        représentent tous les deux un nombre qui peut être copié, passé en argument
        de fonction ou même transformé en un type numérique avec lequel on pourra
        faire certaines opérations arithmétiques (i.e. arithmétique des pointeurs).
    ie:
      title: Raw (crud) Puntatores
      content_markdown: |
        On posse converter referenties a un tip plu primitiv nominat un *raw pointer*. Just quam un numeró, on
        posse copiar e mover it sin grand restrictiones. Rust da nos null certitá pri li validitá del loc 
        de memorie a quel it punta.
        
        Hay du tipes de crud puntatores:
        * `*const T` - Un crud puntator a data del tip T quel deve ne changear se.
        * `*mut T` - Un crud puntator a data del tip T quel posse changear se.
        On posse converter crud puntatores ad-in e ex ciffres (p.ex. `usize`).
        Crud puntatores posse accesser data usante code *unsafe* (on parla pri to plu tard).
        
        Detallies de memorie:
        * Un referentie in Rust es tre simil a un puntator in C in su usada, ma con mult plu restrictiones ye
        témpor de compilation pri qualmen on posse plazzar e mover it ad altri functiones.
        * Un crud puntator in Rust es simil a un puntator in C nam it representa un numeró quel on posse copiar
        e mover, e mem converter a tipes numeric quel on posse modificar it por far matematica puntatori.
  
  - en:
      title: Dereferencing
      content_markdown: |
        The process of accessing/manipulating data that is being referred to
        by a *reference* (i.e. `&i32`) is called *dereferencing*. 
        
        References are used to access/manipulate data in two ways:
        * Access to the referred data during assignment of variables.
        * Access to fields or methods of the referred data.

        Rust has some powerful operators that allow us to do this.
        
    fr:
      title: Déréférencement
      content_markdown: |
        Le fait d'accéder ou de manipuler des données à partir d'une *référence*
        (i.e. un `&i32`) est appelé *déréférencement* (en anglais dereferencing).
      
        Les références sont utilisées pour accéder ou manipuler des données de deux
        manières:
        * Accéder à la donnée référencée lors de l'affectation d'une variable.
        * Accéder aux champs ou méthodes de la donnée référencée.

        Pour cela, Rust met à notre disposition des opérateurs très puissants.
    ie:
      title: Dereferentiation
      content_markdown: |
        Li processe de accesser/manipular data a quel on referer se con un *referentie*
        (p.ex. `&i32`) es nominat *dereferentiation* (dereferencing).

        Con du metodes on accesse/manipular data con un referentie:
        * Accesse al data referet durant li assignation de variabiles.
        * Accesse a campes o metodes del data referet.
        Rust possede quelc potent operatores queles fa to possibil por nos.
  
  - en:
      title: The * Operator
      content_markdown: |
        The `*` operator is an explicit way to dereference a reference. 

        ```rust
        let a: i32 = 42;
        let ref_ref_ref_a: &&&i32 = &&&a;
        let ref_a: &i32 = **ref_ref_ref_a;
        let b: i32 = *ref_a;
        ```

        Memory detail:
        - Because i32 is a primitive type that implements the Copy trait, 
        the bytes of variable `a` on stack are copied into the bytes of variable `b`.
        
    fr:
      title: L'opérateur *
      content_markdown: |
        L'opérateur `*` est un moyen explicite de déréférencer une référence. 

        ```rust
        let a: i32 = 42;
        let ref_ref_ref_a: &&&i32 = &&&a;
        let ref_a: &i32 = **ref_ref_ref_a;
        let b: i32 = *ref_a;
        ```

        Détail de la mémoire:
        - Parce que i32 est un type primitif qui implémente le trait Copy,
        les octets de la variable `a` sur la pile sont copiés dans les octets
        de la variable `b`.
        
    ie:
      title: Li Operator *
      content_markdown: |
        Li operator `*` es un metode explicit por dereferentiar un referentie.
        ```rust
        let a: i32 = 42;
        let ref_ref_ref_a: &&&i32 = &&&a;
        let ref_a: &i32 = **ref_ref_ref_a;
        let b: i32 = *ref_a;
        ```
        Detallies pri memorie:
        - Nam i32 es un tip primitiv quel implementa li trate Copy, li bytes del variabil `a`
        sur li stack es copiat ad-in li bytes de variabil `b`.
        
  - en:
      title: The . Operator
      content_markdown: |
        The `.` operator is used in accessing fields and methods of a reference. It works a bit more subtly.

        ```rust
        let f = Foo { value: 42 };
        let ref_ref_ref_f = &&&f;
        println!("{}", ref_ref_ref_f.value);
        ```
        Whoa, why didn't we need to add `***` before `ref_ref_ref_f`? This is because the `.` operator automatically dereferences 
        a sequence of references. That last line is turned into the following by the compiler automatically.

        ```rust
        println!("{}", (***ref_ref_ref_f).value);
        ```
        
    fr:
      title: L'opérateur .
      content_markdown: |
        L'opérateur `.` est utilisé pour accéder aux champs et aux méthodes d'une
        référence. Cela fonctionne un peu plus subtilement que l'opérateur `*`.

        ```rust
        let f = Foo { value: 42 };
        let ref_ref_ref_f = &&&f;
        println!("{}", ref_ref_ref_f.value);
        ```
        Whoa, pourquoi n'avons-nous pas dû ajouter `***` avant `ref_ref_ref_f`?
        La raison est que l'opérateur `.` déréférence automatiquement une
        séquence de références. La dernière instruction du bloc ci-dessus est
        automatiquement transformée par le compilateur en:

        ```rust
        println!("{}", (***ref_ref_ref_f).value);
        ```
        
    ie:
      title: Li Operator .
      content_markdown: |
        On usa li operator `.` por accesser li campes e metodes de un referentie. It efectua se con un poc plu subtilitá.
        ```rust
        let f = Foo { valore: 42 };
        let ref_ref_ref_f = &&&f;
        println!("{}", ref_ref_ref_f.valore);
        ````
        Ma atende, pro quo noi ne besonat adjunter `***` avan `ref_ref_ref_f`? To es pro que li operator `.` dereferentia
        automaticmen un sequentie de referenties. Ti ultim linea changea se automaticmen per li compilator quam seque:
        ```rust
        println!("{}", (***ref_ref_ref_f).value);
        ```
        
  - en:
      title: Smart Pointers
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aops%3A%3ADeref%3B%0Astruct%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0Aimpl%3CT%3E%20Deref%20for%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20was%20used!%22%2C%20std%3A%3Aany%3A%3Atype_name%3A%3A%3CT%3E())%3B%0A%20%20%20%20%20%20%20%20%26self.value%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20TattleTell%20%7B%0A%20%20%20%20%20%20%20%20value%3A%20%22secret%20message%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%2F%2F%20dereference%20occurs%20here%20immediately%20%0A%20%20%20%20%2F%2F%20after%20foo%20is%20auto-referenced%20for%20the%0A%20%20%20%20%2F%2F%20function%20%60len%60%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.len())%3B%0A%7D%0A
      content_markdown: |
        In addition to the ability to create references to existing typed data using the `&` operator. Rust gives us the ability
        to create *reference-like* structs called **smart pointers**. 
        
        We can think of references at a high level as a type that give us access to another type.  Smart pointers are different in their 
        behavior from normal references in that they operate based on internal logic that a programmer writes. You — the programmer —
        are the *smart* part.

        Typically smart pointers implement `Deref`,`DerefMut`,`Drop` traits to specify the logic of what should happen when
        the structure is dereferenced with `*` and `.` operators.
        
    fr:
      title: Pointeurs intelligents
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aops%3A%3ADeref%3B%0Astruct%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0Aimpl%3CT%3E%20Deref%20for%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20was%20used!%22%2C%20std%3A%3Aany%3A%3Atype_name%3A%3A%3CT%3E())%3B%0A%20%20%20%20%20%20%20%20%26self.value%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20TattleTell%20%7B%0A%20%20%20%20%20%20%20%20value%3A%20%22secret%20message%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%2F%2F%20Un%20d%C3%A9r%C3%A9f%C3%A9rencement%20est%20fait%20par%20l%27appel%0A%20%20%20%20%2F%2F%20de%20la%20fonction%20%60len%60.%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.len())%3B%0A%7D%0A
      content_markdown: |
        En plus de la possibilité de créer des références de données typées à
        l'aide de l'opérateur `&`, Rust nous donne la possibilité de créer des
        structures similaires aux références (en anglais reference-like) appelées
        **pointeurs intelligents**.
      
        Les références peuvent être vues comme un type qui nous donne accès à un
        autre type. Les pointeurs intelligents peuvent faire la même chose que les
        références et plus encore, c'est au programmeur de définir la logique interne
        d'un pointeur intelligent. La partie *intelligente* est le programmeur.

        Les pointeurs intelligents implémentent généralement les traits Deref,
        DerefMut et Drop pour spécifier le comportement du pointeur lorsque la
        structure est déréférencée avec les opérateurs `*` et `.`.
        
    ie:
      title: Puntatores Inteligent
      content_markdown: |
        In plu al possibilitá de crear referenties a existent tipat data con li operator `&`, Rust da nos li habilitá de crear
        *referentiesc* structs nominat **smart pointers** (puntatores inteligent).

        Noi posse conceptualisar referenties simplicmen quam un tip quel da accesse a un altri tip. Smart pointers es diferent de normal
        puntatores in quant que ili functiona basat sur li logic intern scrit del programmator. Tu - li programmator - es li parte
        quel es *inteligent*.
        Por li pluparte smart puntatores implementa li trates `Deref`, `DerefMut` e `Drop` por specificar li logica pri quo mey evenir
        quande on dereferentia li structura con li operatores `*` e `.`.
        
  - en:
      title: Smart Unsafe Code
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%5Bu8%3B%204%5D%20%3D%20%5B86%2C%2014%2C%2073%2C%2064%5D%3B%0A%20%20%20%20%2F%2F%20this%20is%20a%20raw%20pointer.%20Getting%20the%20memory%20address%0A%20%20%20%20%2F%2F%20of%20something%20as%20a%20number%20is%20totally%20safe%0A%20%20%20%20let%20pointer_a%20%3D%20%26a%20as%20*const%20u8%20as%20usize%3B%0A%20%20%20%20println!(%22Data%20memory%20location%3A%20%7B%7D%22%2C%20pointer_a)%3B%0A%20%20%20%20%2F%2F%20Turning%20our%20number%20into%20a%20raw%20pointer%20to%20a%20f32%20is%0A%20%20%20%20%2F%2F%20also%20safe%20to%20do.%0A%20%20%20%20let%20pointer_b%20%3D%20pointer_a%20as%20*const%20f32%3B%0A%20%20%20%20let%20b%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20This%20is%20unsafe%20because%20we%20are%20telling%20the%20compiler%0A%20%20%20%20%20%20%20%20%2F%2F%20to%20assume%20our%20pointer%20is%20a%20valid%20f32%20and%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it's%20value%20into%20the%20variable%20b.%0A%20%20%20%20%20%20%20%20%2F%2F%20Rust%20has%20no%20way%20to%20verify%20this%20assumption%20is%20true.%0A%20%20%20%20%20%20%20%20*pointer_b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22I%20swear%20this%20is%20a%20pie!%20%7B%7D%22%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Smart pointers tend to use *unsafe* code fairly often. As mentioned earlier, 
        they are common tools for interacting with the lowest levels of memory in Rust.

        What is unsafe code? Unsafe code behaves exactly like normal Rust with the exception of a few abilities that
        the Rust compiler is unable to make gaurantees about.

        A primary ability of unsafe code is *dereferencing a raw pointer*. That means taking a *raw pointer* 
        to a position in memory and declaring "a data structure exists here!" and turning it into a representation of data you can use (i.e. `*const u8` into `u8`). 
        Rust has no way to keep track of the meaning of every byte that gets written to memory. Because Rust can't make 
        gaurantees about what exists at an arbitrary number used as a *raw pointer*, it puts the dereference in an `unsafe { ... }` block. 

        Smart pointers *dereference raw pointers* extensively, but they are well proven in what they do.
        
    fr:
      title: Code intelligents mais dangereux
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%5Bu8%3B%204%5D%20%3D%20%5B86%2C%2014%2C%2073%2C%2064%5D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20C%27est%20un%20pointeur%20brut.%20Obtenir%20l%27adresse%20m%C3%A9moire%0A%20%20%20%20%2F%2F%20d%27un%20nombre%20est%20totalement%20s%C3%BBr.%0A%20%20%20%20let%20pointer_a%20%3D%20%26a%20as%20*const%20u8%20as%20usize%3B%0A%20%20%20%20%20%20%20%20println!(%22Adresse%20m%C3%A9moire%3A%20%7B%7D%22%2C%20pointer_a)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Transformer%20notre%20nombre%20en%20un%20pointeur%20brut%20vers%20un%0A%20%20%20%20%2F%2F%20f32%20est%20%C3%A9galement%20s%C3%BBr.%0A%20%20%20%20let%20pointer_b%20%3D%20pointer_a%20as%20*const%20f32%3B%0A%20%20%20%20%0A%20%20%20%20let%20b%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20C%27est%20dangereux%20car%20nous%20demandons%20au%20compilateur%0A%20%20%20%20%20%20%20%20%2F%2F%20de%20supposer%20que%20notre%20pointeur%20est%20un%20f32%20valide%0A%20%20%20%20%20%20%20%20%2F%2F%20et%20de%20d%C3%A9r%C3%A9f%C3%A9rencer%20sa%20valeur%20dans%20la%20variable%20b.%0A%20%20%20%20%20%20%20%20%2F%2F%20Rust%20n%27a%20aucun%20moyen%20de%20v%C3%A9rifier%20que%20cette%20hypoth%C3%A8se%0A%20%20%20%20%20%20%20%20%2F%2F%20soit%20vraie.%0A%20%20%20%20%20%20%20%20*pointer_b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Je%20jure%20que%20c%27est%20une%20tarte!%20%7B%7D%22%2C%20b)%3B%0A%7D%0A
      content_markdown: |
        Les pointeurs intelligents ont tendance à utiliser assez souvent du code
        *dangereux* (en anglais unsafe). Comme mentionné précédemment, ce sont des
        outils courants pour interagir au plus bas niveau de la mémoire.

        Qu'est-ce qu'un code dangereux? Un code dangereux se comporte exactement
        comme un code normal à l'exception que le compilateur Rust ne garantie pas
        la validité du programme.

        La première cause d'un code dangereux est lorsqu'on essaye de
        *déréférencer un pointeur brut*. Cela signifie prendre un *pointeur brut*
        correspondant à une adresse mémoire, déclarer "une structure de données existe ici!"
        et transformer les octets de cet emplacement mémoire dans une représentation
        de données que l'on pourra utiliser (par exemple `*const u8` en `u8`).
        Puisque Rust ne garantie pas la signification des octets (il ne garde
        pas de traces), il place le déréférencement dans un bloc `unsafe {...}`.
        
    ie:
      title: Code Inteligent e Ínsecur
      content_markdown: |
        Smart pointers frequentmen usa code *unsafe* (ínsecur). Quam mentionat in supra, ili es utensiles frequentmen
        usat por interacter con li nivelles de memorie max bass in Rust.
        Quo es code unsafe? Unsafe code es just quam Rust normal except que it have quelc habilitás pri queles li
        compilator ne posse confirmar ca ili es secur o ne.
        Li habilitá primari de code unsafe es li *dereferentiation de un puntator crud*. To vole dir mover un *raw pointer*
        a un loc in memorie e declerar "ti-ci hay un data structura!" e changear it ad-in un representation de usabil data (p.ex.
        ex un `*const u8` ad-in un `u8`). Rust nullmen posse memorar li significantie de omni byte inscrit in memorie, e pro to,
        ne posse garantir quo existe in un loc arbitrari usat quam un *raw pointer*, e pro to on plazza li dereferentie in un bloc
        `unsafe { ... }`.
        Smart pointers *dereferentia puntatores crud* extensivmen, ma fa it tre habilmen.  
        
  - en:
      title: Familiar Friends
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20let's%20ask%20for%204%20bytes%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20allocate%20and%20save%20the%20memory%20location%20as%20a%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20use%20pointer%20math%20and%20write%20a%20few%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20u8%20values%20to%20memory%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20interpret%20secret_recipe%20pointer%20as%20a%20f32%20raw%20pointer%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20dereference%20it%20into%20a%20return%20value%20%26f32%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20%22make%20a%20pie%22%20by%20dereferencing%20our%20%0A%20%20%20%20%2F%2F%20Pie%20struct%20smart%20pointer%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A
      content_markdown: |
        Consider some smart pointers we've already seen like `Vec<T>` and `String`.

        `Vec<T>` is a smart pointer that just owns some memory region of bytes. The Rust compiler has no idea what 
        exists in these bytes. The smart pointer interprets what it means to grab items from the region of memory it manages,
        keeps track of where data structures within those bytes begin and end, and then finally dereference a raw pointer
        into data structures into a nice clean ergonomic interface for us to use (e.g. `my_vec[3]`).

        Similarly, `String` keeps track of a memory region of bytes, and programatically restricts content written to it to always
        be valid `utf-8` and helps dereference that memory region into a type `&str`.

        Both these datastructures use unsafe dereferencing of raw pointers to do their job.

        Memory details:
        * Rust has an equivalent of C's `malloc` using [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) and [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html ) for getting ahold of your own memory regions to manage.
        
    fr:
      title: Amis familiers
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20On%20d%C3%A9finit%20l'agencement%20que%20doit%20avoir%20la%20m%C3%A9moire%0A%20%20%20%20%20%20%20%20%2F%2F%20pour%20pouvoir%20allouer%204%20octets.%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20Alloue%20nos%204%20octets%20en%20m%C3%A9moire%20et%20sauvegarde%20la%20position%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20de%20d%C3%A9but%20en%20tant%20qu'entier.%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20On%20%C3%A9crit%20quelques%20valeurs%20u8%20en%20m%C3%A9moire%20avec%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20un%20peu%20d'arithm%C3%A9tique%20des%20pointeurs.%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Interpr%C3%A8te%20le%20pointeur%20secret_recipe%20en%20tant%20que%0A%20%20%20%20%20%20%20%20%2F%2F%20pointeur%20brut%20f32.%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20D%C3%A9r%C3%A9f%C3%A9rence%20le%20pointeur%20brut%20et%20retourne%20une%0A%20%20%20%20%20%20%20%20%2F%2F%20valeur%20%26f32.%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20On%20d%C3%A9r%C3%A9f%C3%A9rence%20le%20pointeur%20intelligent%20de%20notre%0A%20%20%20%20%2F%2F%20structure%20Pie.%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A
      content_markdown: |
        Revenons sur quelques pointeurs intelligents que tu connais déjà: `Vec<T>` et `String`.

        `Vec <T>` est un pointeur intelligent vers des octets en mémoire. Le
        compilateur Rust n'a aucune idée de la manière dont il faut interpréter ces octets.
        Le pointeur intelligent est capable d'interpréter ces octets en gardant
        une trace de l'endroit dans ces octets où une structures de données commence
        et se termine. Le pointeur intelligent déréférence un pointeur brut pour
        exposer la structure de données dans une belle interface ergonomique propre
        que nous d'utiliser (par exemple `my_vec [3]`).

        De même, `String` garde une trace des octets en mémoire et restreint par
        programmation le contenu qui y est écrit à toujours être de l'`utf-8`
        valide. Il déréférence cette région de mémoire dans un type` &str`.

        Ces deux structures de données doivent procéder à un déréférencement
        dangereux de pointeurs bruts.

        Détails de la mémoire:
        * Rust possède l'équivalent de `malloc` du langage C avec
        [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) et
        [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html)
        pour allouer soi-même une région de la mémoire.
        
    ie:
      title: Amics Bon Conosset
      content_markdown: |
        Ples considerar quelc inteligent puntatores ja videt quam `Vec<T>` e `String`.
        `Vec<T>` es un puntator intilegent quel simplicmen possede un region de memorie de bytes. Li compilator Rust have null idé
        pri quo existe in li bytes. Li puntator inteligent interpreta li significantie de prender bytes del region de memorie quel
        it gere, it nota ex u comensa e fini se li data-structuras ta, e in fine dereferentia un raw pointer ad-in data-structuras
        con un interfacie clar e ergonomic quel noi posse utilisar (p.ex. `my_vec[3]`).
        Similmen, `String` nota u trova se un region de memorie de bytes, e programmaticmen da restrictiones al contenete inscrit ta
        por que it mey esser valid `utf-8`, poy auxilia dereferentiar ti region de memorie ad-in un tip `&str`.
        Ti ambi data-structuras usa ínsecur dereferentiation de puntatores crud por acompleer li tache.
        Detallies pri memorie:
        * Por alquo equivoc a `malloc` usat in C, rust usa [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) e [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html ) por gerer tui propri regiones de memorie.
        
  - en:
      title: Heap Allocated Memory
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A
      content_markdown: |
        `Box` is a smart pointer that lets us move data from the stack to the heap.

        Dereferencing it lets us use the heap allocated data ergonomically as if it were the original type.
        
    fr:
      title: Mémoire allouée sur le tas
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22C%27est%20bien%20meilleur%20sur%20le%20tas!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A
      content_markdown: |
        `Box` est un pointeur intelligent qui nous permet de déplacer des données
        de la pile vers le tas.

        Le déréférencement nous permet d'utiliser les données allouées sur le tas
        de manière ergonomique comme s'il s'agissait du type d'origine.
        
    ie:
      title: Memorie Alocat sur li Heap
      content_markdown: |
        `Box` es un puntator inteligent con quel noi posse transferer data del stack til li heap.
        Con un dereferentiation de it noi posse ergonomicmen usar li data sur li heap just quam si it esset li tip original.
        
  - en:
      title: Failable Main Revisited
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20core%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C'_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22This%20pie%20is%20not%20fresh!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A
      content_markdown: |
        Rust code may have a plethora of representations of errors, but the standard library has
        a universial trait `std::error::Error` for describing errors.

        Using a smart pointer `Box` we can use the type `Box<dyn std::error::Error>` as a common type for returning errors because it allows us to
        propogate up an error on the heap and interact with it at a high level without having to know a specific type.

        Early in Tour of Rust we learned that `main` can return an error. We can now return
        a type capable of describing almost any kind of error that might occur in our program 
        so long as the error's data structure implements Rust's common `Error` trait.

        ```rust
        fn main() -> Result<(), Box<dyn std::error:Error>>
        ```
    fr:
      title: Renvoi d'erreurs dans le main revisité
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20core%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C%27_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22La%20tarte%20n%27est%20pas%20fra%C3%AEche!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A
      content_markdown: |
        Rust possède une pléthore de représentations d'erreurs, mais la bibliothèque
        standard met à disposition un trait universel `std::error::Error` pour
        décrire les erreurs.

        En utilisant le pointeur intelligent `Box`, nous pouvons utiliser le type
        `Box<dyn std::error::Error>` comme type courant pour renvoyer des erreurs
        car celui-ci nous permet de propager une erreur sur le tas et d'interagir
        avec elle sans avoir à connaître le type spécifique.

        Au début du Tour de Rust, nous avons appris que `main` pouvait renvoyer une
        erreur. Avec `Box`, nous pouvons maintenant retourner un type capable de
        décrire presque tout type d'erreur qui pourrait se produire dans notre
        programme à condition que la structure de données de l'erreur implémente
        le trait `Error` de Rust.

        ```rust
        fn main() -> Result<(), Box<dyn std::error:Error>>
        ```
    ie:
      title: Denov pri li Main Fallibil
      content_markdown: |
        In li code de Rust trova se multissim metodes por representar errores, ma li biblioteca standard possede ya
        un trate universal `std::error::Error` por descrir les.
        Con li puntator inteligent `Box` noi posse usar li tip `Box<dyn std::error::Error>` quam un tip comun por retornar 
        errores pro que con it noi posse propagar un errore sur li heap e interacter con it sur un alt nivelle sin dever
        conosser un tip specific. Tost in li Tur de Rust noi aprendet que `main` posse retornar un errore. Nu noi posse 
        retornar un tip quel es capabil descrir presc qualcunc errore quel posse evenir in nor programma, si solmen li
        data-structura del errore implementa li trate comun de Rust `Error`.
        ```rust
        fn main() -> Result<(), Box<dyn std::error::Error>>
        ```
        
  - en:
      title: Referencing Counting
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Rc%3A%3Anew(Pie)%3B%0A%20%20%20%20let%20heap_pie2%20%3D%20heap_pie.clone()%3B%0A%20%20%20%20let%20heap_pie3%20%3D%20heap_pie2.clone()%3B%0A%0A%20%20%20%20heap_pie3.eat()%3B%0A%20%20%20%20heap_pie2.eat()%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%0A%20%20%20%20%2F%2F%20all%20reference%20count%20smart%20pointers%20are%20dropped%20now%0A%20%20%20%20%2F%2F%20the%20heap%20data%20Pie%20finally%20deallocates%0A%7D%0A
      content_markdown: |
        `Rc` is a smart pointer that moves data from the stack onto the heap. It allows us to 
        clone other `Rc` smart pointers that all have the ability to immutably borrow the data 
        that was put on the heap.

        Only when the last smart pointer is dropped does the data on the heap become deallocated.
        
    fr:
      title: Multi-propriétaire
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22C%27est%20bien%20meilleur%20sur%20le%20tas!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Rc%3A%3Anew(Pie)%3B%0A%20%20%20%20let%20heap_pie2%20%3D%20heap_pie.clone()%3B%0A%20%20%20%20let%20heap_pie3%20%3D%20heap_pie2.clone()%3B%0A%0A%20%20%20%20heap_pie3.eat()%3B%0A%20%20%20%20heap_pie2.eat()%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%0A%20%20%20%20%2F%2F%20Les%20donn%C3%A9es%20de%20Pie%20se%20trouvant%20sur%20le%20tas%20sont%0A%20%20%20%20%2F%2F%20d%C3%A9sallou%C3%A9es%20ici.%0A%7D%0A
      content_markdown: |
        `Rc` (en anglais Reference Counting) est un pointeur intelligent qui
        déplace les données de la pile vers le tas. Celui-ci peut être cloné
        et permet d'emprunter immuablement les données se trouvant sur le tas.

        Ce n'est que lorsque le dernier pointeur intelligent est déalloué que les
        données du tas sont désallouées.
        
    ie:
      title: Numerotar Referenties
      content_markdown: |
        `Rc` es un puntator inteligent quel move data del stack til li heap. Con it noi posse clonar altri
        puntatores `Rc` queles possede li habilitá de ínmutabilmen pruntar li data plazzar sur li heap.
        Li dealocation del data sur li heap eveni solmen pos que li ultim puntator inteligent cade.
        
  - en:
      title: Sharing Access
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22tastes%20better%20on%20the%20heap!%22)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20RefCell%20validates%20memory%20safety%20at%20runtime%0A%20%20%20%20%2F%2F%20notice%3A%20pie_cell%20is%20not%20mut!%0A%20%20%20%20let%20pie_cell%20%3D%20RefCell%3A%3Anew(Pie%7Bslices%3A8%7D)%3B%0A%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20but%20we%20can%20borrow%20mutable%20references!%0A%20%20%20%20%20%20%20%20let%20mut%20mut_ref_pie%20%3D%20pie_cell.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20mut_ref_pie%20is%20dropped%20at%20end%20of%20scope%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20now%20we%20can%20borrow%20immutably%20once%20our%20mutable%20reference%20drops%0A%20%20%20%20%20let%20ref_pie%20%3D%20pie_cell.borrow()%3B%0A%20%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2Cref_pie.slices)%3B%0A%7D%0A
      content_markdown: |
        `RefCell` is a container data structure commonly held by smart pointers that takes in data and lets us
        borrow mutable and immutable references to what's inside. It prevents borrowing from
        being abused by enforcing Rust's memory safety rules at runtime when you ask to borrow
        the data within:

        **Only one mutable reference OR multiple immutable references, but not both!**

        If you violate these rules `RefCell` will panic.
        
    fr:
      title: Partage d'accès
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22C%27est%20bien%20meilleur%20sur%20le%20tas!%22)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20RefCell%20valide%20les%20r%C3%A8gles%20de%20s%C3%A9curit%C3%A9%20li%C3%A9es%0A%20%20%20%20%2F%2F%20%C3%A0%20la%20m%C3%A9moire%20lors%20de%20l%27ex%C3%A9cution.%0A%20%20%20%20%2F%2F%20Note%3A%20pie_cell%20n%27est%20pas%20mutable!%0A%20%20%20%20let%20pie_cell%20%3D%20RefCell%3A%3Anew(Pie%7Bslices%3A8%7D)%3B%0A%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Mais%20rien%20n%27emp%C3%AAche%20d%27emprunter%20une%20r%C3%A9f%C3%A9rence%20mutable!%0A%20%20%20%20%20%20%20%20let%20mut%20mut_ref_pie%20%3D%20pie_cell.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20mut_ref_pie%20est%20d%C3%A9sallou%C3%A9%20ici.%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Nous%20pouvons%20emprunter%20une%20r%C3%A9f%C3%A9rence%20immuable%20car%0A%20%20%20%20%2F%2F%20la%20r%C3%A9f%C3%A9rence%20mutable%20vient%20d%27%C3%AAtre%20d%C3%A9sallou%C3%A9e.%0A%20%20%20%20%20let%20ref_pie%20%3D%20pie_cell.borrow()%3B%0A%20%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2Cref_pie.slices)%3B%0A%7D%0A
      content_markdown: |
        `RefCell` est une structure de données couramment détenue par des pointeurs
        intelligents et qui contient des données. `RefCell`nous permet d'emprunter
        des références mutables et immuables vers ces données. Il empêche d'abuser
        de la fonctionnalité d'emprunt (en anglais borrowing) de Rust en appliquant
        des règles de sécurité liées à la mémoire lors de l'exécution:

        **Une seule référence mutable OU plusieurs références immuables, mais pas les deux!**

        Si vous violez ces règles, `RefCell` paniquera.
        
    ie:
      title: Accesse Junt
      content_markdown: |
        `RefCell` es un data-structura scatullesc quel es tenet per puntatores inteligent e prende data por que noi mey
        pruntar referenties mutabil e ínmutabil al contenete intern. Ti-ci puntator inteligent preveni pruntation abuset
        per li validation del regules de Rust pri securitá de memorie durant li functionament del programma quande tu
        peti pruntar li data intern.
        **Sive un mutabil referentie sive multiplic ínmutabil referenties, ma ne ambi!**
        Con un violation de ti regules `RefCell` va far un panic.
        
  - en:
      title: Sharing Across Threads
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22only%20I%20eat%20the%20pie%20right%20now!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%2F%2F%20let's%20borrow%20a%20locked%20immutable%20reference%20of%20pie%0A%20%20%20%20%2F%2F%20we%20have%20to%20unwrap%20the%20result%20of%20a%20lock%0A%20%20%20%20%2F%2F%20because%20it%20might%20fail%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%2F%2F%20locked%20reference%20drops%20here%2C%20and%20mutex%20protected%20value%20can%20be%20used%20by%20someone%20else%0A%7D%0A
      content_markdown: |
        `Mutex` is a container data structure commonly held by smart pointers that takes in data and lets us borrow mutable
        and immutable references to the data within. This prevents borrowing from being abused by 
        having the operating system restrict only one CPU thread at time to have access to the data, 
        blocking other threads until that original thread is done with it's locked borrow.

        Multithreading is beyond the scope of Tour of Rust, but `Mutex` is a fundamental part of orchestrating
        multiple CPUs threads accessing the same data.

        There is a special smart pointer `Arc` which is identical to `Rc` except uses thread-safe incrementing of reference counts. 
        It's often used to have many references to the same `Mutex`.
        
    fr:
      title: Partage entre threads
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22Je%20suis%20le%20seul%20%C3%A0%20pouvoir%20manger%20la%20tarte!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20On%20emprunte%20une%20r%C3%A9f%C3%A9rence%20immuable.%20Celle-ci%20doit%20%C3%AAtre%0A%20%20%20%20%2F%2F%20verrouill%C3%A9e%20(en%20anglais%20locked).%20On%20doit%20%C3%A9galement%20faire%0A%20%20%20%20%2F%2F%20appel%20%C3%A0%20'unwrap'%20car%20l'appel%20%C3%A0%20'lock'%20peut%20%C3%A9chouer.%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20La%20r%C3%A9f%C3%A9rence%20ref_pie%20est%20d%C3%A9sallou%C3%A9e%20ici.%20mutex_pie%0A%20%20%20%20%2F%2F%20pourrait%20de%20nouveau%20%C3%AAtre%20utilis%C3%A9%20ici.%0A%20%20%20%20%0A%7D%0A
      content_markdown: |
        `Mutex` est une structure de données (couramment détenue par des pointeurs
        intelligents) pouvant contenir des données et nous permet d'emprunter des
        références mutable ou immuables vers les données qu'elle contient. `Mutex`
        restreint l'accès aux données à un seul thread CPU, bloquant les autres
        threads jusqu'à ce que le thread d'origine ait terminé et déverrouillé les
        données.

        Le multithreading dépasse le cadre de Tour of Rust, mais `Mutex` est un
        élément fondamental de la programmation concurrentielle avec Rust.

        Il existe un pointeur intelligent spécial `Arc` qui est identique à `Rc`
        mais pour les threads. La particularité de `Arc` est qu'il est thread-safe,
        Rust gardera en mémoire le nombre de références existantes vers une donnée
        même dans une application utilisant plusieurs threads. Il est souvent utilisé
        pour avoir plusieurs références vers un même `Mutex`.
        
    ie:
      title: Partiprender trans Files (Threads)
      content_markdown: |
        `Mutex` es un data-structura scatullesc quel es frequentmen tenet per puntatores inteligent e prende data por que noi
        mey pruntar mutabil e ínmutabil al contenete intern. Con to li pruntation ne es abuset per restrictiones del OS quande
        solmen un fil posse accesser li data, bloccante li altri files til quande li fil original ha finit con li pruntation
        original. Multifilation es plu complex por nor libre, ma `Mutex` es un parte fundamental del gerentie de multiplic
        CPU-files por accesse al sam data.
        Hay un puntator inteligent special nominat `Arc` quel es identic a `Rc` except in qualmen it usa fil-secur incrementation
        del númere de referenties. Con it on posse haver mult referenties al sam `Mutex`.
        
  - en:
      title: Combining Smart Pointers
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20took%20a%20slice!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20use%20smart%20pointer%20to%20pie%20for%20a%20mutable%20borrow%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20take%20a%20bite!%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%2F%2F%20ferris%20and%20sarah%20are%20given%20clones%20of%20smart%20pointer%20to%20pie%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22sarah%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20slices%20left%22%2C%20p.slices)%3B%0A%7D%0A
      content_markdown: |
        Smart pointers might seem limited, but they can make some very powerful combinations.

        `Rc<Vec<Foo>>` - Allow the cloning of multiple smart pointers that can borrow the same vector of immutable data structures on the heap.

        `Rc<RefCell<Foo>>` - Allow multiple smart pointers the ability to borrow mutably/immutably the same struct `Foo`

        `Arc<Mutex<Foo>>` - Allow multiple smart pointers the ability to lock temporary mutable/immutable borrows in a CPU thread exclusive manner.

        Memory detail:
        * You'll notice a theme with many of these combinations. The use of a immutable data type (possibly owned by multiple smart pointers) to modify internal data. This 
          is referred to as the "interior mutability" pattern in Rust. It is a pattern that lets us bend the rules of memory usage at runtime with the same level of safety as Rust's
          compile-time checks.
          
    fr:
      title: Utilisation avancée des pointeurs intelligents
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20a%20pris%20une%20part!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Utilise%20un%20pointeur%20intelligent%20vers%20Pie%20pour%0A%20%20%20%20%20%20%20%20%2F%2F%20effectuer%20un%20emprunt%20mutable.%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20On%20modifie%20la%20donn%C3%A9e.%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Ferris%20et%20Sarah%20sont%20cr%C3%A9%C3%A9s%20avec%20des%20clones%20de%0A%20%20%20%20%2F%2F%20pointeurs%20intelligents%20vers%20Pie.%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%2)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20parts%20restantes.%22%2C%20p.slices)%3B%0A%7D%0A
      content_markdown: |
        Les pointeurs intelligents peuvent sembler limités, mais ils peuvent
        être utilisés de manière très puissante avec les structures que nous
        venons de voir.

        `Rc<Vec<Foo>>` - Permet de cloner plusieurs pointeurs intelligents pouvant
        emprunter le même vecteur de données immuables. Pour rappel `Rc` place les
        données sur le tas.

        `Rc<RefCell<Foo>>` - Permet à plusieurs pointeurs intelligents d'emprunter
        mutuellement ou immuablement la même structure `Foo`.

        `Arc<Mutex<Foo>>` - Permet à un pointeur intelligent de verrouiller
        temporairement une donnée (celle-ci ne pourra plus être emprunté mutablement
        ou immuablement) de manière exclusive à un thread du CPU (les autres threads
        n'y auront pas accès).

        Détail de la mémoire:
        * Vous remarquerez un thème commun avec plusieurs de ces utilisations:
          l'utilisation d'un type de données immuable (possiblement emprunté par
          plusieurs pointeurs intelligents) pour modifier les données internes.
          C'est ce qu'on appelle la "mutabilité intérieure" (en anglais interior
          mutability) de Rust. C'est un modèle qui nous permet de contourner les
          règles d'utilisation de la mémoire à l'exécution mais en gardant le même
          niveau de sécurité que Rust nous offre lors de la compilation.
    ie:
      title: Combinar Puntatores Inteligent
      content_markdown: |
        Smart pointers sembla liminat, ma junt ili crea combinationes tre potent.
        `Rc<Vec<Foo>>` - Clonada de multiplic smart pointers queles posse pruntar li sam vector de ínmutabil data-structuras sur li heap.
        `Rc<RefCell<Foo>>` - Multiplic smart pointers possent pruntar mutabilmen/ínmutabilmen li sam struct `Foo`
        `Arc<Mutex<Foo>>` - Multiplic smart pointers possent cluder temporari mutabil/ínmutabil pruntas in un maniere exclusiv in un fil del CPU.
        Detallies pri memorie:
        * Tu va har remarcat un tema comun con ti-ci combinationes, a saver li usation de un data-tip ínmutabil (fórsan possedet per multiplic puntatores inteligent) por modificar
        data intern. On nomina it li mustre de "mutabilitá intern" in Rust. Con ti mustre noi posse circumear li regules pri usation de memorie durant li execution del programma
        con un nivelle de securitá tam secur quam ti durant li compilation.
          
  - en:
      title: Chapter 8 - Conclusion
      content_markdown: |
        Smart pointers are the idioms of Rust programming and let us not have to re-create the 
        very common patterns of memory usage. With them you are ready to tackle the toughest of
        challenges! Now that we have the foundations of Rust, let's talk a bit about how we make 
        larger projects. In chapter 9 we break free of single page
        lines of code.
        
    fr:
      title: Chapitre 8 - Conclusion
      content_markdown: |
        Les pointeurs intelligents sont très utilisés avec Rust car cela nous
        évite de recréer nous-même ces schémas très courants d'utilisation de
        la mémoire. Avec eux, tu sera prêt à affronter tous les défis! Maintenant
        que nous avons vu les fondations de Rust, nous verrons dans le prochain
        chapitre comment se structure un projet Rust au-delà d'un simple fichier.
        
    ie:
      title: Capitul 8 - Conclusion
      content_markdown: |
        Puntatores inteligent es li idiotismes de programmation in Rust con queles noi ne es fortiat recrear
        li defís comun in li mustres de usation de memorie. Con ili on es pret a soluer mem li defís max dur!
        Armat con li fundamentes de Rust, noi nu va parlar plu pri qualmen crear projectes con un grandore
        plu ampli. In Capitul 9 noi va liberar nos de lineas de code scrit sur un singul págine.
  - chapter: 9
    en:
      title: Chapter 9 - Project Organization and Structure
      content_markdown: |
        So far all of our code examples have been a single file. Let's discuss how our code be better organized and shared by others!
    fr:
      title: Chapitre 9 - Organisation et structure d'un projet
      content_markdown: |
      Jusqu'à présent, tous nos exemples de code n'on guère dépassé le simple
      fichier. Voyons comment un projet plus complexe s'organise et quels outils
      l'écosystème Rust met à notre disposition pour pouvoir travailler à
      plusieurs sur un même projet!
    ie:
      title: Capitul 9 - Organisation e Structura de un Projecte
      content_markdown: |
        Til nu nor exemples de code ha esset scrit in singul archives. Lass nos discusser pri qualmen plu bon organisar e partiprender it!
        
  - en:
      title: Modules
      content_markdown: |
        Every Rust program or library is a *crate*.

        Every crate is made of a hierarchy of *modules*.

        Every crate has a root module.

        A module holds global variables, functions, structs, traits, and other modules!
    fr:
      title: Modules
      content_markdown: |
        Chaque programme ou bibliothèque Rust est appelé une *crate*
        (littéralement une caisse).

        Chaque crate est constituée d'une hiérarchie de *modules*.

        Chaque crate possède un module racine.

        Un module peut contenir des variables globales, des fonctions, des
        structures, des traits ou même d'autres modules!
    ie:
      title: Modules
      content_markdown: |
        Chascun programma o biblioteca in Rust es un *crate*.
        Chascun crate es creat ex un hierarchie de *modules*.
        Chascun crate possede un root (radical) modul.
        Un model possede variabiles global, functiones, structs, traits, e altri modules!
        
  - en:
      title: Writing a Program
      content_markdown: |
        A program has a root module in a file called `main.rs`.
    fr:
      title: Ecrire un programme
      content_markdown: |
        Un programme possède un module racine dans un fichier appelé `main.rs`.
    ie:
      title: Scrir un Programma
      content_markdown: |
        Un programma have un modul root in un archive nominat `main.rs`.

  - en:
      title: Writing a Library
      content_markdown: |
        A library has a root module in a file called `lib.rs`.
    fr:
      title: Ecrire une bibliothèque
      content_markdown: |
        Un bibliothèque possède un module racine dans un fichier appelé `lib.rs`.
    ie:
      title: Scrir un Biblioteca
      content_markdown: |
        Un biblioteca have un modul root in un archive nominat `lib.rs`.

  - en:
      title: Referencing Other Modules and Crates
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Welcome%20to%20the%20playground!%22)%3B%0A%20%20%20%20println!(%22I%20would%20love%20a%20slice%20of%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
      content_markdown: |
        Items in modules can be referenced with their full module path `std::f64::consts::PI`.
        
        A simpler way is the **use** keyword. It allows us to specify particular items from modules we want
        to use throughout our code without a full path. For instance `use std::f64::consts::PI`
        allows me to just use the identifier `PI` in my main function.

        **std** is the crate of the **standard library** of Rust which is full of useful data
        structures and functions for interacting with your operating system.

        A searchable directory of crates created by the community can be found at [https://crates.io](https://crates.io/)
    fr:
      title: Référencement de modules et de crates
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Bienvenue%20au%20terrain%20de%20jeu%20Rust!%22)%3B%0A%20%20%20%20println!(%22Chuck%20Norris%20connait%20la%20derni%C3%A8re%20%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20d%C3%A9cimale%20de%20%7B%7D...!%22%2C%20PI)%3B%0A%7D%0A
      content_markdown: |
        Les composants d'un module peuvent être référencés avec leur chemin
        complet `std::f64::consts::PI`.
          
        Un moyen plus simple est d'utiliser le mot-clé **use**. Il nous permet
        de spécifier des éléments particuliers des modules que nous souhaitons
        utiliser sans avoir à spécifier le chemin complet à chaque fois. Par
        exemple `use std::f64::consts::PI` permettra d'utiliser simplement
        l'identifiant `PI` là où on en a besoin.

        **std** est la **bibliothèque standard** de Rust. Celle-ci met à
        disposition de nombreuses structures de données et fonction pour
        intéragir plus facilement avec le système d'exploitation.

        Un répertoire des crates créées par la communauté peut être consulté à
        l'adresse [https://crates.io](https://crates.io/)
  - en:
      title: Referencing Multiple Items
      content_markdown: |
        Multiple items can be referenced in a single module path as so:

        ```rust
        use std::f64::consts::{PI,TAU}
        ```

        Ferris doesn't eat TAU, he only eats PI.
    fr:
      title: Référencement de plusieurs composants d'un modules
      content_markdown: |
        Plusieurs composants peuvent être référencés dans un seul chemin de module:

        ```rust
        use std::f64::consts::{PI,TAU}
        ```
    ie:
      title: Referentiar Coses Multiplic
      content_markdown: |
        On posse referentiar coses multiplic in un sol modul quam seque:
        ```rust
        use std::f64::consts::{PI, TAU}
        ```
        Ferris ne manja TAU, solmen PI.
        
  - en:
      title: Module Heirarchy
      content_markdown: |
        When we think of code, we usually imagine a heirarchy of files organized in directories. 
        
        Rust can have a module `foo` represented as:
          * a file named `foo.rs`
          * a directory named `foo` with a file `mod.rs` inside

        In order to establish a relationship between a module and it's sub-module, you must write in the parent module:

        ```rust
        mod foo;
        ```
    fr:
      title: Hiérarchie des modules
      content_markdown: |
        Lorsqu'un développeur écrit un programme, il se retrouve généralement
        avec une hiéarchie de fichiers organisés en répertoire. Il est souvent
        commode d'organiser son code sous forme de modules.

        Avec Rust, il y a deux manière de créer un module. Par exemple, si nous
        souhaitons créer le module `foo`, nous pouvons créer au choix:
          * un fichier nommé `foo.rs`
          * un répertoire nommé `foo` avec un fichier `mod.rs` à l'intérieur

        Un module peut dépendre d'un autre. Afin d'établir une relation entre
        un module et son sous-module, vous devez écrire dans le module parent:

        ```rust
        // Cette déclaration recherchera un fichier nommé `foo.rs` ou `foo/mod.rs`
        // et insérera son contenu dans un module nommé `foo` qu'on pourra ensuite
        // utiliser.
        mod foo;
        ```
    ie:
      title: Hierarchie de un Modul
        Quande on pensa pri code, on imagina por li pluparte un hierarchie de archives organisat in archivieres.
        
        Rust posse posseder un modul `foo` representat quam
          * un archive nominat `foo.rs`
          * un archiviere nominat `foo` in quel sta un archive `mod.rs`
        Por etablisser un relation inter un model e su sub-modul, on deve scrir quam seque in li modul genitori.
        ```rust
        mod foo;
        ```
        
  - en:
      title: Inline Module
      content_markdown: |
        A sub-module can be directly inlined within a module's code.

        One very common use for inline modules is creating unit tests. We create an inline module that only exists when Rust is used for testing!

        ```
        // This macro removes this inline module when Rust 
        // is not in test mode.
        #[cfg(test)]
        mod tests {
            // Notice that we don't immediately get access to the 
            // parent module. We must be explicit.
            use super::*;

            ... tests go here ...
        }
        ```
        
      ie:
        title: Modul Inlineari
        content_markdown: |
          On posse 'inlinear' un sub-modul directmen in li code de un model.
          On fa talmen tre frequentmen por crear provas unitic (unit tests).
          ```
          // Ti-ci macro remove li modul inlineari quande Rust
          // ne sta in prova-mode.
          #[cfg(test)]
          mod tests {
            // A notar que a nos ne es ínmediatmen dat accesse al
            // modul genitori. Noi deve esser explicit.
            use super::*;
            ... li provas sta ci ...
          }
          ```
        
  - en:
      title: Internal Module Referencing
      content_markdown: |
        Rust has several keywords you can use in your `use` path to quickly get ahold of the module you want:
          
        * `crate` - the root module of your crate
        * `super` - the parent module of your current module
        * `self` - the current module
        
    ie:
      title: Referenties Intern a Modules
      content_markdown: |
        Rust possede mult clave-paroles queles tu posse usar in tui `use`-path por rapidmen trovar li modul desirat:

        * `crate` - li root modul de tui crate
        * `super` - li modul genitori del modul quel tu usa actualmen
        * `self` - li modul in quel on nu sta
        
  - en:
      title: Exporting
      content_markdown: |
        By default members of a *module* are not accessible from outside of the module (not even to it's child modules!). We make members 
        of a module accessible using the `pub` keyword.

        By default members of a *crate* are not accessible outside of the crate. We make members of
        a crate accessible by marking them as `pub` in the *root module* of your crate (`lib.rs` or `main.rs`).
    de:
      title: Export
      content_markdown: |
        Die Inhalte eines Moduls sind außerhalb des Moduls nicht automatisch zugänglich.
        Stattdessen müssen die Teile, die im Modul erreichbar sein sollen, durch das `pub` Schlüsselwort *exportiert* werden.

        Die Inhalte einer Kiste (crate) sind ebenfalls außerhalb des Crates nicht automatisch zugänglich.
        Die zu exportierenden Teile werden im *root Modul* (`lib.rs` oder `main.rs`) durch das `pub` Schlüsselwort exportiert.

        Mehr dazu später, für jetzt reicht es zu wissen, dass durch `pub` die Sichtbarkeit
        von Funktionen und Attributen gesteuert werden kann.
    ie:
      title: Exportation
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=mod%20mi_sub_module%20%7B%0A%20%20fn%20far_alquo()%20%7B%0A%20%20%20%20println!(%22fant%20alquo%22)%0A%20%20%7D%0A%0A%20%20pub%20fn%20far_alquo_in_plu()%20%7B%0A%20%20%20%20println!(%22fant%20alquo%20in%20plu%22)%0A%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20mi_sub_module%3A%3Afar_alquo()%3B%0A%20%20mi_sub_module%3A%3Afar_alquo_in_plu()%3B%0A%7D%0A
      content_html:
        "<p>In Rust, noi exporta membres de un module usante li clave-parol
        <b>pub</b>.</p><p>Quande on usa un module, sive in su propri code sive in un crate
        extern, on posse solmen aluder a membres possedent li marcation public.</p><p>Li
        code in ti-ci exemple es ruptet; ples adjunter li clave-parol <b>pub</b> in li
        loc necessi por reparar it.</p>"
    ru:
      title: Экспорт
      content_markdown: |
        По умолчанию элементы модуля недоступны вне этого модуля. Их можно сделать "видимыми" или 
        доступными, используя ключевое слово `pub`.

        Также элементы крейта(crate) недоступны по умолчанию вне этого крейта. Но их можно 
        сделать доступными ключевым словом `pub` в **корневом модуле** крейта (`lib.rs` или `main.rs`).

        Мы поговорим о модулях в деталях позже, сейчас знайте, что `pub` контролирует видимость
        функций или структур данных.
    es:
      title: Exportar
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=mod%20mi_sub_modulo%20%7B%0A%20%20%20%20fn%20haz_algo()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22haciendo%20algo%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20pub%20fn%20haz_algo_mas()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22haciendo%20algo%20m%C3%A1s%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20mi_sub_modulo%3A%3Ahaz_algo()%3B%0A%20%20%20%20mi_sub_modulo%3A%3Ahaz_algo_mas()%3B%0A%7D%0A
      content_html:
        "<p>En Rust, exportamos elementos de un módulo usando la palabra reservada <b>pub</b>.</p><p>Cuando
        se utiliza un módulo dentro de su propio código o en un crate externo, sólo se
        permiten referencias a aquellos elementos que hayan sido marcados como públicos.</p><p>El código en este ejemplo
        da error, añade la palabra reservada <b>pub</b> en el lugar apropiado para arreglarlo.</p>"
  - en:
      title: Structure Visibility
      content_markdown: |
        Just like functions, structures can declare what they want exposed outside of their module using `pub`.

      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20SeaCreature%20struct%20will%20be%20usable%20outside%20of%20our%20module%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20let's%20keep%20our%20weapon%20private%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
    de:
      title: Struktursichtbarkeit
      content_markdown: |
        Genau wie bei Funktionen kann in Strukturen angegeben werden, welche Felder nach außen hin sichtbar sein sollen.
        Diese sind wieder mit dem Schlüsselwort `pub` versehen.
    ie:
      title: Visibilitá de Structuras
      content_markdown: |
        Just quam functiones, structuras posse usar `pub` por declarar to quo ili desira esser exposit éxter su modul.
      code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Li%20struct%20CreaturaMarin%20va%20esser%20usabil%20%C3%A9xter%20nor%20modul%0Apub%20struct%20CreaturaMarin%20%7B%0A%20%20%20%20%2F%2F%20String%20es%20un%20struct%0A%20%20%20%20pub%20tip_de_animale%3A%20String%2C%0A%20%20%20%20pub%20nomine%3A%20String%2C%0A%20%20%20%20pub%20brasses%3A%20i32%2C%0A%20%20%20%20pub%20jambes%3A%20i32%2C%0A%20%20%20%20%2F%2F%20ma%20noi%20vole%20que%20li%20arme%20mey%20esser%20privat%0A%20%20%20%20arme%3A%20String%2C%0A%7D
    ru:
      title: Область видимости структур
      content_markdown: |
        Структуры могут объявлять поля ключевым словом `pub`, открывая к ним доступ для внешних модулей.
  - en:
      title: Prelude
      content_markdown: |
        You might by wondering in Rust, how we have access to `Vec`,`Box`, etc. everywhere without a `use`. In the Rust standard 
        library anything that is exported in `std::prelude::*` is automatically available to every part of Rust.
  - en:
      title: Your Own Prelude
      content_markdown: |
        Because of standard library's prelude, it's common for your libary to have it's own prelude module as a starting point for 
        where users should import all of the most common data structures for using your library (e.g `use my_library::prelude::*`).
        It doesn't automatically get used in programs/libraries that use your crate, but it's a good convention to follow so people
        know where to start.

        Ferris says, "Be a good rustacean and help a fellow crab out with a good prelude!"
  - en:
      title: Chapter 9 - Conclusion
      content_markdown: |
        You now have a few tricks up your sleeve when it comes to creating Rust applications and libraries ready for the world. Don't
        worry about remembering it all. As your library grows and is used by other people, you'll find what works best at each milestone.

        Resources:
        - [Guidelines For Writing Rust APIs](https://rust-lang.github.io/api-guidelines/)
  - chapter: 10
    en:
      title: The End
      content_markdown: |
        It's been a joy to have you on the Tour of Rust. Ferris and the Tour of Rust team sincerely hope you enjoy the journey ahead! If you 
        have feel comfortable this far, we strongly recommend diving deeper with these resources:
        * [The Official Rust Programming Book](https://doc.rust-lang.org/stable/book/)
    es:
      title: Fin
      content_markdown: |
        Esto es todo por ahora, pero aún quedan más capítulos, así que ¡muy atento! Esperamos que disfrutes del viaje.
    fr:
      title: Fin
      content_markdown: |
        Ce fut une joie de t'avoir sur le Tour de Rust. Ferris et l'équipe du
        Tour de Rust espèrent sincèrement que tu apprécieras le voyage à venir!
        Si tu te sens à l'aise avec Rust, nous te conseillons fortement de
        continuer à approfondir tes connaissances avec ces ressources (attention
        celles-ci sont en anglais):
        * [Le livre officiel du langage de programmation Rust](https://doc.rust-lang.org/stable/book/)
    ie:
      title: Fine
      content_markdown: |
        To es omnicos por nu. Plu tard va venir nov contenete. Yo espera que tu va juir li viage a sequer!
    pt-br:
      title: Fim
      content_markdown: |
        Isso é tudo por enquanto. Fique ligado para novos conteúdos. Espero que
        se divirta nesta jornada!
