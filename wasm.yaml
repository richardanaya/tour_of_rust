---
common_words:
  en:
    chapter: Chapter
    tor: Tour of WebAssembly
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
  en_c:
    chapter: Chapter
    tor: Tour of WebAssembly
    next: Next
    previous: Previous
    toc: Table of Contents
    lessons: Lessons
    untranslated: Untranslated
  fr:
    chapter: Chapitre
    tor: Tour de WebAssembly
    next: Suivant
    previous: Précédant
    toc: Table des Matières
    lessons: Leçons
    untranslated: Non traduit
  fr_c:
    chapter: Chapitre
    tor: Tour de WebAssembly
    next: Suivant
    previous: Précédant
    toc: Table des Matières
    lessons: Lessons
    untranslated: Untranslated
  de:
    tor: Tour zu WebAssembly
    next: Weiter
    previous: Zurück
    toc: Inhaltsverzeichnis
    lessons: Kapitel
    chapter: Kapitel
    untranslated: Untranslated
  ie:
    tor: Tur de Rust
    next: Sequent
    previous: Precedent
    toc: Tabelle de contenete
    lessons: Lectiones
    chapter: Capitul
    untranslated: Untranslated
  ru:
    chapter: Глава
    tor: Тур по WebAssembly
    next: Далее
    previous: Назад
    toc: Содержание
    lessons: Занятия
    untranslated: Untranslated
  es:
    chapter: Capítulo
    tor: Tour de WebAssembly
    next: Siguiente
    previous: Anterior
    toc: Tabla de Contenidos
    lessons: Lecciones
    untranslated: Untranslated
  pt-br:
    chapter: Capítulo
    tor: Um tour por WebAssembly
    next: Próximo
    previous: Anterior
    toc: Índice
    lessons: Unidades
    untranslated: Untranslated
pages:
  - en:
      title: Hello, WebAssembly
      content_markdown: |
        Welcome to the *Tour of WebAssembly*. This is meant to be a introduction to the technology 
        and how Rust can be used to power the web.  If you are completely new to Rust, you might 
        appreciate the [Tour of Rust](https://tourofrust.com/)! Most of our examples will be easy
        enough to follow along by anyone though. This tour is also available in C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [Rust (Español)] (index_es.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        If you have suggestions on content or would like to contribute to translations, 
        checkout out Tour of WebAssembly's [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with keyboard <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>
    en_c:
      title: Hello, WebAssembly
      content_markdown: |
        Welcome to the *Tour of WebAssembly*. This is meant to be a introduction to the technology 
        and how C can be used to power the web. This tour is also available in Rust.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [Rust (Español)] (index_es.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        If you have suggestions on content or would like to contribute to translations, 
        checkout out Tour of WebAssembly's [github repository](https://github.com/richardanaya/tour_of_rust).

        You can navigate through the tour with keyboard <span class="emoji">⬅️</span> and <span class="emoji">➡️</span>

    fr:
      title: Salut, WebAssembly
      content_markdown: |
        Bienvenue au * Tour de WebAssembly *. Celui-ci a pour but d'être une introduction à la technologie
        et comment Rust peut être utilisé pour alimenter le Web. Si tu n'es pas à l'aise avec Rust,
        je te conseilles le [Tour de Rust] (https://tourofrust.com/)! La plupart de nos exemples seront
        suffisamment simples pour pouvoir être suivis par n'importe qui, même les débutants.
        Cette visite est également disponible en C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [Rust (Español)] (index_es.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Si tu as des suggestions sur le contenu ou souhaite contribuer aux traductions,
        consultes le [dépôt github](https://github.com/richardanaya/tour_of_rust) du Tour de WebAssembly.

        Tu peux parcourir la visite avec les touches <span class="emoji">⬅️</span> et <span class="emoji">➡️</span> du clavier.
    fr_c:
      title: Salut, WebAssembly
      content_markdown: |
        Bienvenue au *Tour de WebAssembly*. Celui-ci a pour but d'être une introduction à la technologie
        et comment Rust peut être utilisé pour alimenter le Web. Cette visite est également disponible en Rust.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [Rust (Español)] (index_es.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Si tu as des suggestions sur le contenu ou souhaite contribuer aux traductions,
        consultes le [dépôt github](https://github.com/richardanaya/tour_of_rust) du Tour de WebAssembly.

        Tu peux parcourir la visite avec les touches <span class="emoji">⬅️</span> et <span class="emoji">➡️</span> du clavier.
    ie:
      title: Salute, WebAssembly
      content_markdown: |
        Benevenit al *Tur de WebAssembly*, un tur quel intente esser un introduction al tecnologie
        e qualmen on posse usar Rust por dar plu fortie al web. Si tu es un novon a Rust, noi recomanda li
        [Tour of Rust](https://tourofrust.com/)! Malgré to, li pluparte de nor exemples va esser facil
        a sequer por quicunc. Li tur es anc disponibil in C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [Rust (Español)] (index_es.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Si tu have suggestiones pri contenete o vole contribuer al traductiones,
        ples vider li [repositoria github](https://github.com/richardanaya/tour_of_rust) del Tur.

        Tu posse navigar tra li tur con li claves <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>

    pt-br:
      title: Olá, WebAssembly
      content_markdown: |
        Bem-vindo ao *Tour por WebAssembly*. Pretendemos ser uma introdução a esta tecnologia e de
        como o Rust pode ser usado para dar mais força à web. Se você é completamente novo no Rust pode
        apreciar o [Tour por Rust](https://tourofrust.com/)! A maioria dos nossos exemplos será fácil
        o suficiente para qualquer pessoa acompanhar. Este tour também está disponível para a
        linguagem C.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [Rust (Español)] (index_es.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        Caso tenha alguma sugestão a respeito do conteúdo ou queira contribuir com as
        traduções, veja o repositório do Tour do WebAssembly [github repository](https://github.com/richardanaya/tour_of_rust).

        Você pode navegar pelo tour usando <span class="emoji">⬅️</span> e <span class="emoji">➡️</span>
  es:
      title: Hola, WebAssembly
      content_markdown: |
        Bienvenido al *Tour de WebAssembly*. Este tutorial pretende introducirte a la tecnología y
        a cómo Rust puede ser usado para mejorar la web.  Si eres completamente nuevo en Rust, quizá te 
        interese el [Tour de Rust](https://tourofrust.com/)! La mayoría de nuestros ejemplos serán lo
        suficientemente fáciles para cualquier persona que quiera seguirlos.

        * [Rust (english)] (index.html)
        * [Rust (français)] (index_fr.html)
        * [Rust (Interlingue)] (index_ie.html)
        * [Rust (Português Brasileiro)] (index_pt-br.html)
        * [Rust (Español)] (index_es.html)
        * [C (english)] (index_en_c.html)
        * [C (français)] (index_fr_c.html)

        En el caso de que tengas sugerencias respecto al contenido o quieras contribuir con traducciones,
        vaya al repositorio del Tour de WebAssembly [github repository](https://github.com/richardanaya/tour_of_rust).

        Puedes navegar por el tour usando el teclado <span class="emoji">⬅️</span> y <span class="emoji">➡️</span>
  - chapter: 1
    en:
      title: Chapter 1 - What Is WebAssembly?
      content_markdown: |
        WebAssembly is a binary format for representating isolated executable code.  It was developed for web
        browsers as an alternative to JavaScript with some distinct advantages:

        * Because its a low level bytecode, it's able to perform math quickly and manage memory more concisely.
        * WebAssembly was built with existing compilers in mind, allowing native languages like C/C++ and Rust to compile to it as a target.
        * Built with isolation in mind, allowing fine grain access control.
        * WebAssembly was built rather host agnostic, allowing some people to use WebAssembly [outside of browsers](https://wasmer.io/) too!

        WebAssembly is often called **WASM**
    en_c:
      clone: en
      
    fr:
      title: Chapitre 1 - Qu'est-ce que WebAssembly?
      content_markdown: |
        WebAssembly est un format binaire pour représenter un code exécutable dans
        un environement isolé. Il a été développé pour être exécuté par les navigateurs
        web et propose une alternative au langage Javascript avec plusieurs avantages
        distincts:

        * Étant du bytecode de bas niveau, cela permet d'effectuer des calculs
        plus rapidement que le JavaScript et d'avoir plus de contrôle sur la gestion
        de la mémoire.
        * WebAssembly a été créé en s'inspirant des compilateurs existants, permettant
        ainsi aux langages natifs comme C / C ++ et Rust de produire ce bytecode.
        * Le bytecode étant exécuté dans un environement isolé, cela permet de
        contrôler son exécution.
        * WebAssembly a été construit indépendamment de l'hôte, rendant possible
        son utilisation [en dehors des navigateurs](https://wasmer.io/)!
 
        WebAssembly est souvent racourci en ** WASM **.
    fr_c:
      clone: fr
      
    ie:
      title: Chapter 1 - Quo es WebAssembly?
      content_markdown: |
        WebAssembly es un formate binari por representar code executabil isolat. On developat it por navigatores web
        quam un alternative a JavaScript con quelc avantages distint:

        * Essente bytecode de bass nivelle, it posse far matematica rapidmen e gerer memorie con plu concisitá.
        * On constructet WebAssembly pensante pri compilatores existent, por que lingues nativ quam C/C++ e Rust mey compilar con it quam cible.
        * It esset constructet sur li principie de isolation, possibilisante control de accesse rafinat.
        * On constructet WebAssembly sin egard al hósped, con quel alcunes posse usar it anc [éxter navigatores web](https://wasmer.io/)!

        On nomina WebAssembly sovente **WASM**
    pt-br:
      title: Capítulo 1 - O Que É WebAssembly?
      content_markdown: |
        O WebAssembly é um formato binário para representar um código executável isolado. Foi
        projetado para ser executado nos navegadores de internet como uma alternativa ao 
        JavaScript com algumas vantagens nítidas:

        * Por ser um bytecode de baixo nível, é capaz de executar cálculos rapidamente e gerenciar
          a memória de forma mais concisa.
        * O WebAssembly foi projetado tendo os compiladores existentes em mente, permitindo que seja 
          compilado a partir de linguagens nativas como C/C++ e Rust.
        * Projetado com o isolamento em mente, permitindo um controle de acesso detalhado.
        * O WebAssembly foi projetado para ser bem agnóstico, permitindo que as pessoas usem o web 
          assembly [fora dos navegadores](https://wasmer.io/) também!

        O WebAssembly é frequentemente chamado de **WASM**.
    es:
      title: Capítulo 1 - Qué es WebAssembly?
      content_markdown: |
        WebAssembly es un formato binario para representar un código ejecutable de forma aislada. Foi
        Fue creado para para ser executado en los navegadores como una alternativa a 
        JavaScript con las siguientes ventajas:

        * Por ser un bytecode de bajo nivel, capaz de ejecutar cálculos rápidamente y acceder a la memoria
          de una forma más directa.
        * WebAssembly fue creado teniendo a los compiladores existentes en mente, haciendo posible que fuera
          compilado a partir de lenguajes nativos como C/C++ y Rust.
        * Creado con seguridad e isolación en mente, permitiendo un control de acesso detallado.
        * WebAssembly fue creado para ser agnóstico, permitiendo que los usuarios usaran WebAssembly 
          [fuera de los navegadores](https://wasmer.io/) también!

        WebAssembly es frecuentemente mencionado como **WASM**.
  - en:
      title: Inside A Module
      content_markdown: |
        When you compile to a WebAssembly target your compiler should create a file ending in `.wasm` called a **module**.

        The module is a [binary format](https://webassembly.github.io/spec/core/index.html) full of information on how a 
        wasm program and its memory should be setup and interacted with:
        * a list of functions
        * what functions should be exported/imported
        * what data should initially be in the wasm modules memory
    en_c:
      clone: en
    fr:
      title: À l'Intérieur d'un Module
      content_markdown: |
        Lorsque tu compiles vers du bytecode WebAssembly, le compilateur
        crée un fichier `.wasm` qu'on appele un **module**.

        Un module est un [format binaire](https://webassembly.github.io/spec/core/index.html)
        contenant des informations sur le programme wasm et sur la mémoire qu'il
        utilise. Un module contient:
        * une liste de fonctions
        * quelles fonctions doivent être exportées/importées
        * quelles données doivent se trouver initialement dans la mémoire des modules wasm
    fr_c:
      clone: fr
    ie:
      title: Quo Sta in un Modul
      content_markdown: |
        Quande on compila a un cible de WebAssembly, li compilator deve crear un archive quel fini se con `.wasm` nominat un **modul**.

        Li modul es in [formate binari](https://webassembly.github.io/spec/core/index.html) e plen de information pri qualmen
        on mey crear e interacter con un programma wasm program e su memorie:
        * un liste de functiones
        * quel functiones mey esser exportat/importat
        * quel data mey esser in prim in li memorie del modules wasm
    pt-br:
      title: Por Dentro de um Módulo
      content_markdown: |
        Quando você compila para WebAssembly, seu compilador deve criar um arquivo terminado em 
        `.wasm` chamado de **módulo**.

        O módulo é um [formato binário](https://webassembly.github.io/spec/core/index.html) com 
        todas as informações para que um programa wasm e a sua memória sejam configurados 
        e interajam com:
        * uma lista de funções.
        * quais funções devem ser exportadas/importadas.
        * quais dados devem inicialmente estar na memória dos módulos wasm.
    es:
      title: Dentro de un Módulo
      content_markdown: |
        Cuando compilas a WebAssembly, su compilador debe crear un archivo acabado en 
        `.wasm` llamado **módulo**.

        El módulo es un [formato binario](https://webassembly.github.io/spec/core/index.html) con 
        toda la información necesaria para que un programa wasm y su memoria sean configurados e interaccionen
        con:
        * una lista de funciones.
        * qué funciones deben de ser exportadas/importadas.
        * qué datos tienen que estar inicialmente en la memoria de los módulos wasm.
  - en:
      title: Loading A Module
      content_markdown: |
        Since a WebAssembly module is just a file of bytes. We first need to load those bytes in our browser.

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    en_c:
      clone: en
    fr:
      title: Charger un Module
      content_markdown: |
        Puisqu'un module WebAssembly n'est qu'un fichier d'octets (en anglais bytes),
        nous devons d'abord charger ces octets dans notre navigateur.

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    fr_c:
      clone: fr
    ie:
      title: Cargar un Modul
      content_markdown: |
        Nam un modul WebAssembly es solmen un archive de bytes, noi va in prim cargar ti-ci bytes in nor navigator

        ```
        let file = await fetch('my_file.wasm');
        let bytes = await file.arrayBuffer();
        ```
    pt-br:
      title: Carregando um Módulo
      content_markdown: |
        Como um módulo de WebAssembly é apenas um arquivo de bytes, precisamos primeiro carregar esses
        bytes em nosso navegador.

        ```
        let file = await fetch('meu_arquivo.wasm');
        let bytes = await file.arrayBuffer();
        ```
    es:
      title: Cargando un Módulo
      content_markdown: |
        Como un módulo de WebAssembly es apenas un conjunto de bytes, necesitamos primero cargar esos bytes
        en nuestro navegador.

        ```
        let file = await fetch('mi_modulo.wasm');
        let bytes = await file.arrayBuffer();
        ```
  - en:
      title: Creating a Module
      content_markdown: |
        Modules are created from bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        During this phase we can **import** JavaScript functions we want our module to have access to. 
        We'll show an example of this next chapter.
    en_c:
      clone: en
    fr:
      title: Créer d'un Module
      content_markdown: |
        Les modules sont créés à partir d'octets.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Au cours de cette phase, nous pouvons également définir les fonctions à
        **importer** et qui seront utilisées par notre module. Ne t'inquiète pas
        si ce n'est pas clair, nous verrons un exemple d'import de fonction par
        la suite.
    fr_c:
      clone: fr
    ie:
      title: Crear un Modul
      content_markdown: |
        Modules es creat de bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Durant ti-ci fase noi posse **importar** li functiones de JavaScript a quel noi vole que nor modul mey posser accesser. 
        Noi va dar un exemple de to in li capitul a sequer.
    pt-br:
      title: Criando um Módulo
      content_markdown: |
        Módulos são criados a partir de bytes.

        ```
        let module = await WebAssembly.instantiate(bytes);
        ```

        Durante esta fase podemos **importar** funções JavaScript que desejamos que nosso módulo
        tenha acesso. Mostraremos um exemplo no próximo capítulo.
  - en:
      title: Using a Module
      content_markdown: |
        A module will have one or more **export** functions that are accessible to JavaScript. Typically
        there is some export function to call in order to start a wasm program (e.g. `main`, `start`).

        ```
        module.instance.main();
        ```
    en_c:
      clone: en
    fr:
      title: Utiliser un Module
      content_markdown: |
        Un module peut **exporter** une ou plusieurs fonctions qui
        seront utilisables par le code JavaScript. Typiquement
        il existe une fonction à appeler pour démarrer
        un programme wasm (par exemple `main`,` start`).

        ```
        module.instance.main();
        ```
    fr_c:
      clone: fr
    ie:
      title: Usar un Modul
      content_markdown: |
        Un modul va haver un o pluri functiones **export** queles es accessibil a JavaScript. Tipicmen
        hay alquel function de export a vocar por comensar un programma de wasm (p.ex. `main`, `start`).

        ```
        module.instance.main();
        ```
    pt-br:
      title: Usando um Módulo
      content_markdown: |
        Um módulo tem uma ou mais funções **exportadas** que estarão acessíveis ao JavaScript.
        Tipicamente há uma função exportada que será chamada para iniciar um programa wasm
        (por exemplo: `main`, `start`).

        ```
        module.instance.main();
        ```
  - en:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Let's put our knowledge all together and make a WebAssembly
        module with a single **export** function `add` for adding two numbers, and put the
        results in HTML.

        `#[no_mangle]` tells our compiler to keep our function name human readable.
    en_c:
      title: 1+1
      code: https://webassembly.studio/?embed&f=glwzquv2gh8
      content_markdown: |
        Let's put our knowledge all together and make a WebAssembly
        module with a single **export** function `add` for adding two numbers, and put the
        results in HTML.

        `__attribute__((visibility("default")))` tells our compiler to keep our function name human readable to JavaScript.
    fr:
      title: 1+1
      code: https://webassembly.studio/?embed&f=ays6dkowzyk
      content_markdown: |
        Nous en savons suffisamment pour écrire notre premier module WebAssembly:
        l'addition de deux nombre! Le résultat sera affiché dans l'html.

        `#[no_mangle]` est un attribut disant au compilateur de conserver
        le nom de la fonction pour qu'on puisse l'appeler depuis le JavaScript.
    fr_c:
      title: 1+1
      code: https://webassembly.studio/?embed&f=sxf9utkxgbo
      content_markdown: |
        Nous en savons suffisamment pour écrire notre premier module WebAssembly:
        l'addition de deux nombre! Le résultat sera affiché dans l'html.

        `__attribute __ ((visibility ("default")))` est une directive disant au compilateur
        de conserver le nom de la fonction pour qu'on puisse l'appeler depuis le JavaScript.
    ie:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Lass nos combinar nor conossenties por crear un module de WebAssembly
        con un sol **export**-function nominat `add` por addir du ciffres, e plazzar li 
        resultates in HTML.

        Con `#[no_mangle]` noi instructe li compilator mantener li nómine de nor function leibil por entes homan.
    pt-br:
      title: 1+1
      code: https://webassembly.studio/?embed&f=jg96xg1ovj
      content_markdown: |
        Vamos juntar nossos conhecimentos e criar um módulo WebAssembly com uma única função `add` **exportada** para somar dois números e colocar o resultado em HTML.

        `#[no_mangle]` diz ao nosso compilador para manter o nome da nossa função legível para seres humanos.

  - en:
      title: Chapter 1 Conclusion
      content_markdown: |
        I hope it's clear that WebAssembly is not that complex fundamentally! In our next chapter we will 
        start looking into the details of how JavaScript and WebAssembly can talk about the same data.
    en_c:
      clone: en
    fr:
      title: Chapitre 1 - Conclusion
      content_markdown: |
        J'espère t'avoir convaincu que, fondamentalement, WebAssembly
        n'est pas si compliqué que ça! Dans notre prochain chapitre, nous allons
        commencer à examiner en détail comment JavaScript et WebAssembly peuvent
        échanger des données.
    fr_c:
      clone: fr
    pt-br:
      title: Capítulo 1 - Conclusão
      content_markdown: |
        Espero que fique claro que o WebAssembly não é tão complexo fundamentalmente! No próximo capítulo começaremos a examinar os detalhes de como o JavaScript e p WebAssembly podem falar dos mesmos dados.
  - chapter: 2
    en:
      title: Chapter 2 - Sharing Data Structures
      content_markdown: |
        JavaScript and your WebAssembly program have very different representations of data at the memory level.
        To make matters more complex, interacting with the host environment from WebAssembly is very limited.
        In this chapter we will explore the strategies used to move data back and forth.
    en_c:
      clone: en
    fr:
      title: Chapitre 2 - Partage de structures de données
      content_markdown: |
        JavaScript et ton programme WebAssembly ont des représentations très différentes des données au niveau de la mémoire.
        Pour rendre les choses plus complexes, l'interaction avec l'environnement hôte de WebAssembly est très limité.
        Dans ce chapitre, nous explorerons les stratégies utilisées pour échanger les données entre JavaScript et WebAssembly.
    fr_c:
      clone: fr
    pt-br:
      title: Capítulo 2 - Compartilhando Estruturas de dados
      content_markdown: |
        JavaScript e seu WebAssembly têm representações de dados muito diferentes no nível da memória.
        Para tornar as coisas mais complexas, a interação com o ambiente host do WebAssembly é muito limitada.
        Neste capítulo exploraremos as estratégias usadas para o vai-e-vem dos dados.
  - en:
      title: Importing Functions
      code: https://webassembly.studio/?embed&f=pp20eedhka
      content_markdown: |
        WebAssembly modules can only call functions that have been explicitly imported.

        Rust uses `extern "C" { ... }` to list the function signatures of those imported functions.

        Notice that calling an imported function is considered `unsafe` in Rust because the compiler
        can make no gaurantees about what happens within it's implementation.
    en_c:
      title: Importing Functions
      code: https://webassembly.studio/?embed&f=bah3p4wjere
      content_markdown: |
        WebAssembly modules can only call functions that have been explicitly imported.

        C uses the `extern` keyword to define signatures of the imported functions.
    fr:
      title: Import de Fonctions
      code: https://webassembly.studio/?embed&f=wy84hvb1mec
      content_markdown: |
        Les modules WebAssembly ne peuvent appeler que des fonctions JavaScript qui ont été explicitement importées.

        Rust utilise `extern" C "{...}` pour répertorier les signatures des fonctions importées.

        Note que l'appel d'une fonction importée est considéré comme `unsafe` (dangereux) par Rust car le compilateur
        ne peut faire aucune garantie sur ce qui se passe dans son implémentation.
    fr_c:
      title: Import de Fonctions
      code: https://webassembly.studio/?embed&f=24dhd9oyxo4
      content_markdown: |
        Les modules WebAssembly ne peuvent appeler que des fonctions JavaScript qui ont été explicitement importées.

        C utilise le mot-clé `extern` pour définir les signatures des fonctions importées.
    pt-br:
      title: Importando Funções
      code: https://webassembly.studio/?embed&f=pp20eedhka
      content_markdown: |
        Os módulos WebAssembly podem chamar apenas funçõesque foram importadas explicitamente.

        O Rust usa `extern "C" { ... }` para listar as assinaturas dessas funções importadas.

        Observe que chamar uma função importada é considerado `não seguro` no Rust porque o compilador não pode dar garantias sobre o que acontece dentro da sua implementação.
  - en:
      title: Limitations of Functions
      content_markdown: |
        Parameter and return types of functions are limited to:

        * i32/i64
        * f32/f64

        So in order to communicate between JavaScript and WebAssembly we will have to get clever with the meaning of numbers!

        Rust is fairly good at converting it's primitive types to WebAssembly's numerical equivalents.
    en_c:
      title: Limitations of Functions
      content_markdown: |
        Parameter and return types of functions are limited to:

        * int/long
        * float/double

        So in order to communicate between JavaScript and WebAssembly we will have to get clever with the meaning of numbers!

        C is fairly good at converting it's primitive types to WebAssembly's numerical equivalents.

    fr:
      title: Limitations des Fonctions
      content_markdown: |
        Les types des paramètres et retours d'une fonction sont limités à:

        * i32/i64
        * f32/f64

        Donc, pour communiquer entre JavaScript et WebAssembly, nous devrons ruser sur les types à utiliser!

        Rust permet facilement de convertir ces types primitifs en équivalents numériques de WebAssembly.
    fr_c:
      title: Limitations des Fonctions
      content_markdown: |
        Les types de paramètres et de fonctions de retour sont limités à:

        * int/long
        * float/double

        Donc, pour communiquer entre JavaScript et WebAssembly, nous devrons ruser sur les types à utiliser!

        C permet facilement de convertir ces types primitifs en équivalents numériques de WebAssembly.

    pt-br:
      title: Limitações das Funções
      content_markdown: |
        Os parâmetros e tipos retornados pelas funções são limitados a:

        * i32/i64
        * f32/f64

        Portanto, para se comunicar entre JavaScript e WebAssembly, teremos que ficar espertos com o significado dos números!

        Rust e C são bastante bons em converter seus tipos primitivos nos equivalentes numéricos do WebAssembly.
  - en:
      title: Exporting Memory
      content_markdown: |
        WebAssembly programs export their memory as a long array of bytes (up to 4GB!). 

        The host can interpret from these bytes the data structures created by the program's code.

        Arrays of bytes can also be written directly into a program's memory from the host.

        Writing/reading bytes to/from a WebAssembly programs memory is
        the primary means of input and output of non-primitive types.
    en_c:
      clone: en
    fr:
      title: Exportation de la Mémoire
      content_markdown: |
        Les programmes WebAssembly exportent leur mémoire sous forme d'un long tableau d'octets (jusqu'à 4 Go!).

        L'environnement hôte peut interpréter à partir de ces octets les structures de données créées par le code du programme.

        Des tableaux d'octets peuvent également être écrits directement dans la mémoire d'un programme par
        l'environnement hôte.

        L' écriture et la lecture d'octets vers (ou depuis) la mémoire d'un programme WebAssembly sont
        les principaux moyens d'entrée et de sortie des types non primitifs.
    fr_c:
      clone: fr
    pt-br:
      title: Exportando Memória
      content_markdown: |
        Os programas WebAssembly exportam sua memória como uma longa matriz de bytes (até 4 GB!). 

        O host pode interpretar a partir desses bytes as estruturas de dados criadas pelo código do programa.

        Matrizes de bytes também podem ser gravadas diretamente na memória de um programa a partir do host e vice-versa.

        Ler e gravar bytes na memória de programas do WebAssembly é o principal meio de entrada e saída de tipos não primitivos.
  - en:
      title: ArrayBuffer
      content_markdown: |
        JavaScript represents a long array of bytes as an `ArrayBuffer`

        You can get a typed view of this buffer that is very efficient to
        interact with.

        ```JavaScript
        // create an array of 8 bytes
        let bytes = new ArrayBuffer(8);
        // view those 8 bytes as 8-bit unsigned integers
        let u8_bytes = new Uint8Array(bytes);
        // modify the array buffer
        u8_bytes[0] = 16; // 00010000
        u8_bytes[1] = 1;  // 00000001
        // re-interpret the u8_bytes's array buffer as 
        // little endian 32-bit signed integers
        let i32_bytes = new Int32Array(u8_bytes.buffer);
        console.log(i32_bytes[0]); 
        ///272 or 00010000000000010000000000000000
        ```
    en_c:
      clone: en
    fr:
      title: ArrayBuffer
      content_markdown: |
        JavaScript représente le long tableau d'octets avec un `ArrayBuffer`.

        Vous pouvez obtenir une vue typée de ce buffer avec laquelle on peut
        intéragir efficacement.

        `` `JavaScript
        // Crée un tableau de 8 octets.
        let bytes = new ArrayBuffer(8);
        // Affiche ces 8 octets comme des entiers non signés 8 bits.
        let u8_bytes = new Uint8Array(bytes);
        // Modification du tableau d'octets.
        u8_bytes[0] = 16; // 00010000
        u8_bytes[1] = 1; // 00000001
        // Réinterprète les bytes u8_bytes de l'ArrayBuffer comme
        // des entiers signés 32 bits petits-boutiste (little endian).
        let i32_bytes = new Int32Array(u8_bytes.buffer);
        console.log(i32_bytes[0]);
        /// 272 ou 00010000000000010000000000000000
        ```
    fr_c:
      clone: fr
    pt-br:
      title: ArrayBuffer
      content_markdown: |
        JavaScript representa uma longa matriz de bytes como um `ArrayBuffer`.

        Você pode obter uma visualização tipada desse buffer de uma maneira muito eficiente para interagir.

        ```JavaScript
        // cria uma matriz de 8 bytes
        let bytes = new ArrayBuffer(8);
        // exibe estes 8 bytes como inteiros sem sinal de 8-bit
        let u8_bytes = new Uint8Array(bytes);
        // modifica o buffer da matriz
        u8_bytes[0] = 16; // 00010000
        u8_bytes[1] = 1;  // 00000001
        // reinterpreta o buffer da matriz de u8_bytes como
        // 32-bit little endian inteiros com sinal
        let i32_bytes = new Int32Array(u8_bytes.buffer);
        console.log(i32_bytes[0]); 
        ///272 or 00010000000000010000000000000000
        ```
  - en:
      title: UTF-8 Encoding/Decoding
      content_markdown: |
        JavaScript provides utility functions for writing/reading UTF-8 strings to/from
        bytes inside of `ArrayBuffer` objects.

        ```JavaScript
        let bytes = new ArrayBuffer(8);
        const data = new Uint8Array(bytes);
        data[0] = 72;  // H
        data[1] = 105; // i
        data[2] = 33;  // !
        let str_len = 3;
        const utf8dec = new TextDecoder("utf-8");
        // sub array takes start and end index
        let text = utf8dec.decode(data.subarray(0,str_len));
        console.log(text) // Hi!

        const utf8enc = new TextEncoder("utf-8");
        let text_bytes = utf8enc.encode(text);
        console.log(text_bytes) 
        // Uint8Array(3) [72, 105, 33]
        ```
    en_c:
      clone: en
    fr:
      title: Encodage/Décodage UTF-8
      content_markdown: |
        JavaScript fournit des fonctions utilitaires pour écrire/lire des chaînes UTF-8 vers/depuis
        les octets à l'intérieur des objets `ArrayBuffer`.

        ```JavaScript
        let bytes = new ArrayBuffer(8);
        const data = new Uint8Array(bytes);
        data[0] = 83; // S
        data[1] = 65; // A
        data[2] = 76; // L
        data[3] = 85; // U
        data[4] = 84; // T
        data[5] = 33; // !
        let str_len = 6;
        const utf8dec = new TextDecoder("utf-8");
        // Le 'sous-tableau' (en anglais subarray) prend l'index de début et de fin.
        let text = utf8dec.decode(data.subarray(0,str_len));
        console.log(text) // Salut!

        const utf8enc = new TextEncoder("utf-8");
        let text_bytes = utf8enc.encode(text);
        console.log(text_bytes) 
        // Uint8Array(6) [ 83, 65, 76, 85, 84, 33 ]
        ```
    fr_c:
      clone: fr
    pt-br:
      title: UTF-8 Encoding/Decoding
      content_markdown: |
        O JavaScript fornece funções utilitárias para ler e escrever strings UTF-8 para bytes dentro de objetos `ArrayBuffer` e vice-versa.

        ```JavaScript
        let bytes = new ArrayBuffer(8);
        const data = new Uint8Array(bytes);
        data[0] = 79;  // O
        data[1] = 105; // i
        data[2] = 33;  // !
        let str_len = 3;
        const utf8dec = new TextDecoder("utf-8");
        // subarray() pega o primeiro e último índice
        let text = utf8dec.decode(data.subarray(0,str_len));
        console.log(text) // Oi!

        const utf8enc = new TextEncoder("utf-8");
        let text_bytes = utf8enc.encode(text);
        console.log(text_bytes) 
        // Uint8Array(3) [72, 105, 33]
        ```
  - en:
      title: Logging Text
      code: https://webassembly.studio/?embed&f=1gxcr004p3x
      content_markdown: |
        Let's explore a simple example of logging some text from a WebAssembly program.

        We must:
        1. Create some utf-8 compliant text in our program's memory
        2. Determine the length of our text's bytes
        3. Somehow send the starting byte start index and length in bytes of that text data to the host browser so it can call `console.log`.

        Here's an example of what that receiving JavaScript function would look like:

        ```JavaScript
        wasm_log(start,len) {
          // extract text from memory location and length
          const utf8dec = new TextDecoder("utf-8");
          let buffer = module.instance.exports.memory.buffer;
          let memory = new Uint8Array(buffer);
          let text = utf8dec.decode(memory.subarray(start,start+len));
          console.log(text);
        }
        ```
    en_c:
      clone: en
      code: https://webassembly.studio/?embed&f=vh15t7nok4p
    fr:
      title: Affichage de texte depuis WebAssembly
      code: https://webassembly.studio/?embed&f=o2u0e8p0lpi
      content_markdown: |
        Explorons un exemple simple d'affichage de texte à partir d'un programme WebAssembly.

        Nous devons:
        1. Créer du texte compatible utf-8 dans la mémoire de notre programme.
        2. Déterminer la longueur des octets de notre texte.
        3. Envoyer d'une manière ou d'une autre l'index de début du premier octet
        et la longueur en octets du texte au navigateur hôte afin qu'il
        puisse appeler `console.log`.

        Voici un exemple de ce à quoi ressemblerait la réception de la fonction JavaScript:

        ```JavaScript
        wasm_log(start,len) {
          // Extrait le texte de l'emplacement mémoire.
          const utf8dec = new TextDecoder("utf-8");
          let buffer = module.instance.exports.memory.buffer;
          let memory = new Uint8Array(buffer);
          let text = utf8dec.decode(memory.subarray(start,start+len));
          console.log(text);
        }
        ```
    fr_c:
      clone: fr
      code: https://webassembly.studio/?embed&f=1k8ag8em8q9
    pt-br:
      title: Logando Texto
      code: https://webassembly.studio/?embed&f=1gxcr004p3x
      content_markdown: |
        Vamos explorar um exemplo simples de logar um texto de um programa WebAssembly.

        Nós devemos:
        1. Criar um texto compatível com utf-8 na memória do nosso programa.
        2. Determinar o comprimento em bytes do nosso texto.
        3. De alguma forma, enviar o índice do byte inicial e o comprimento em bytes desses dados do texto para o navegador host, e então chamar o `console.log`.

        Aqui está um exemplo de como seria essa função de recebimento em JavaScript:

        ```JavaScript
        wasm_log(start,len) {
          // extrai o texto de um lugar da memória e seu comprimento
          const utf8dec = new TextDecoder("utf-8");
          let buffer = module.instance.exports.memory.buffer;
          let memory = new Uint8Array(buffer);
          let text = utf8dec.decode(memory.subarray(start,start+len));
          console.log(text);
        }
        ```
  - en:
      title: Reading Text
      code: https://webassembly.studio/?embed&f=ubmxmavgf2
      content_markdown: |
        Let's explore the opposite idea. Imagine we want to give some text to a WebAssembly program.

        We must:
        1. Determine the length in bytes of the text we want to pass in.
        1. Allocate some space in our memory of that byte length.
        2. Copy bytes into our program's memory at the start of the space we allocated.
        3. Let the WebAssembly program know we have put some data in it's memory at a specific index and lenth in bytes. 

        Here's an example of what that initialization looks like:

        ```JavaScript
        // Turn "Ferris" into bytes
        const utf8enc = new TextEncoder("utf-8");
        let text = "Ferris";
        let text_bytes = utf8enc.encode(text);

        // Allocate enough space for the text
        let len = text_bytes.length;
        let start = module.instance.exports.wasm_malloc(len);

        // Put the text in WebAssembly program's memory
        let buffer = module.instance.exports.memory.buffer;
        let memory = new Uint8Array(buffer);
        memory.set(text_bytes, start);

        // Run the program
        module.instance.exports.main(start,len);
        ```
    en_c:
      clone: en
      code: https://webassembly.studio/?embed&f=0wwbpbvt4kwk
    fr:
      title: Envoi de Texte vers un Programme WebAssembly
      code: https://webassembly.studio/?embed&f=rasfcwobpv
      content_markdown: |
        Explorons l'idée opposée. Imagine que nous voulons envoyer du texte vers notre
        programme WebAssembly.

        Nous devons:
        1. Déterminer la longueur en octets du texte que nous souhaitons transmettre.
        2. Allouer suffisamment d'espace dans notre mémoire pour ces octets.
        3. Copier les octets dans la mémoire de notre programme à la position que nous
        venons d'allouer.
        4. Informer au programme WebAssembly que nous avons mis ces octets dans sa mémoire
        en lui indiquant l'index et la taille.

        Voici un exemple de ce à quoi ressemble cette initialisation:

        ```JavaScript
        // Transforme "Ferris" en octets.
        const utf8enc = new TextEncoder("utf-8");
        let text = "Ferris";
        let text_bytes = utf8enc.encode(text);

        // Alloue de l'espace mémoire pour le texte.
        let len = text_bytes.length;
        let start = module.instance.exports.wasm_malloc(len);

        // Met le texte dans la mémoire du programme WebAssembly.
        let buffer = module.instance.exports.memory.buffer;
        let memory = new Uint8Array(buffer);
        memory.set(text_bytes, start);

        // Exécute le programme.
        module.instance.exports.main(start,len);
        ```
    fr_c:
      clone: fr
      code: https://webassembly.studio/?embed&f=etabmws7uru
    pt-br:
      title: Lendo Texto
      code: https://webassembly.studio/?embed&f=ubmxmavgf2
      content_markdown: |
        Vamos explorar a ideia oposta. Imagine que queremos passar um texto para um programa WebAssembly.

        Nós devemos:
        1. Determinar o comprimento em bytes do texto que queremos passar.
        1. Alocar algum espaço em nossa memória com esse comprimento em bytes.
        2. Copiar os bytes para a memória do nosso programa no início do espaço que alocamos.
        3. Informar o programa WebAssembly que colocamos alguns dados na memória em uma posição e com um comprimento específicos em bytes.

        Aqui está um exemplo de como é essa inicialização:

        ```JavaScript
        // Transforma "Ferris" em bytes
        const utf8enc = new TextEncoder("utf-8");
        let text = "Ferris";
        let text_bytes = utf8enc.encode(text);

        // Aloca espaço suficiente para o texto
        let len = text_bytes.length;
        let start = module.instance.exports.wasm_malloc(len);

        // Coloca o texto na memória do programa WebAssembly
        let buffer = module.instance.exports.memory.buffer;
        let memory = new Uint8Array(buffer);
        memory.set(text_bytes, start);

        // Executa o programa
        module.instance.exports.main(start,len);
        ```
  - en:
      title: Discovering Representations
      content_markdown: |
        You might find it annoying to pass around the length along with the start index of text.

        Consider this an opportunity to reflect upon useful conventions of the past like *C strings*
        that declare the end of text is a 0 value character `\0`.

        Don't want to pass around a byte packed data structure? Consider passing around json.

        You are in control of your representations in memory and what they mean and if they
        are appropriate for your use cases!
    en_c:
      clone: en
    fr:
      title: Découverte des représentations
      content_markdown: |
        Il est possible que tu trouves cela pénible de devoir passer la taille des données
        en mémoire ainsi que l'index de début de celles-ci.
      
        Ne pourrions-nous pas ruser pour échanger une structure donnée de manière simple
        sans devoir passer chaque champs un à un? Pense au chaînes de caractères du C
        (en anglais * C strings *) qui déclare la fin du texte avec le caractère `\0`.

        Tu l'as peut-être déjà à l'esprit, mais nous pouvons utiliser le json! Ce n'est ni plus ni
        moins qu'une chaîne de caractères et tu sais déjà comment échanger ce type de donnée! 

        N'oublie pas que tu as le contrôle sur la représentation mémoire des données et
        c'est donc à toi de choisir celle qui te simplifie le travail.
    fr_c:
      clone: fr
    pt-br:
      title: Descobrindo Representações
      content_markdown: |
        Você pode achar irritante passar pelo comprimento junto com o índice inicial do texto.

        Considere isso uma oportunidade para refletir sobre as convenções úteis do passado, tais como as *C strings* que declaram que o final do texto é um caractere de valor `\0`.

        Não quer passar uma estrutura de dados formatada em bytes? Considere passar um json.

        Você está no controle de suas representações na memória, o que elas significam e se são apropriadas para seus casos de uso!
  - en:
      title: Chapter 2 Conclusion
      content_markdown: |
        Crossing the boundry between host and WebAssembly program is cumbersome, but with it can come great performance. 
        It's important to remind ourselves that WebAssembly is a low -level executable byte code with concerns about memory
        structures that are much fine-grained than JavaScript. Check out your programming language's
        library support for tools that help make this an easier task! For Rust, [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) is a popular option.

        In our next chapter we will talk about a technique for dynamically calling JavaScript functions and garbage collection!
    en_c:
      title: Chapter 2 Conclusion
      content_markdown: |
        Crossing the boundry between host and WebAssembly program is cumbersome, but with it can come great performance. 
        It's important to remind ourselves that WebAssembly is a low -level executable byte code with concerns about memory
        structures that are much fine-grained than JavaScript. Check out your programming language's
        library support for tools that help make this an easier task!

        In our next chapter we will talk about a technique for dynamically calling JavaScript functions and garbage collection!
    fr:
      title: Chapitre 2 - Conclusion
      content_markdown: |
        Echanger des données entre l'hôte et un programme WebAssembly est fastidieux,
        mais cela peut entraîner de grands gains en performances.
        Il est important de se rappeler que WebAssembly exécute du bytecode bas-niveau et
        nous donne un contrôle sur la mémoire beaucoup plus fin que JavaScript.
        N'hésite pas non plus à regarder s'il n'existe pas de librairies Rust pour te
        simplifier la tâche.
        Par exemple, [wasm-bindgen](https://github.com/rustwasm/wasm-bindgen) est une
        option populaire.

        Dans le prochain chapitre, nous parlerons d'une technique pour appeler
        dynamiquement les fonctions JavaScript et nous aborderons
        le ramasse-miettes (garbage collector)!
    fr_c:
      title: Chapitre 2 - Conclusion
      content_markdown: |
        Echanger des données entre l'hôte et un programme WebAssembly est fastidieux,
        mais cela peut entraîner de grands gains en performances.
        Il est important de se rappeler que WebAssembly exécute du bytecode bas-niveau et
        nous donne un contrôle sur la mémoire beaucoup plus fin que JavaScript.
        N'hésite pas non plus à regarder s'il n'existe pas de librairies C pour te
        simplifier la tâche.

        Dans le prochain chapitre, nous parlerons d'une technique pour appeler
        dynamiquement les fonctions JavaScript et nous aborderons le
        ramasse-miettes (garbage collector)!
    pt-br:
      title: Capítulo 2 - Conclusão
      content_markdown: |
        Atravessar a fronteira entre o host e o programa WebAssembly é complicado, mas com ele podemos ter um ótimo desempenho.
        É importante lembrar que o WebAssembly é um byte-code executável de baixo nível com preocupações a respeito de estruturas de memória que são muito mais refinadas que o JavaScript. Confira o suporte da biblioteca da sua linguagem de programação para ferramentas que ajudam a tornar essa tarefa mais fácil! Para o Rust, o [wasm-bindgen] (https://github.com/rustwasm/wasm-bindgen) é uma opção popular.

        No próximo capítulo falaremos sobre uma técnica para chamar dinamicamente funções JavaScript e garbage collection!
  - chapter: 3
    en:
      title: Chapter 3 - Dynamic Invocation
      content_markdown: |
        In this chapter we will talk about how we can create our own dynamic functions at runtime to call from WebAssembly.
    fr:
      title: Chapitre 3 - Invocation dynamique
      content_markdown: |
        Dans ce chapitre, nous expliquerons comment créer nos propres fonctions
        dynamiques (créées lors de l'exécution) et les appeler depuis WebAssembly.
  - en:
      title: Why Dynamic Invocation?
      content_markdown: |
        We saw in the first chapters that we could easily write our own JavaScript functions by hand in our `.js` files, so why
        dynamically create functions?

        * Most people come to WebAssembly to escape JavaScript. Dynamic creation of JavaScript functions allow us to use
          libraries in our native language that do the hard part of dynamically creating their bindings without everyone having
          to recreate the wheel.
        * Simplifies our setup and bootstrapping of our WebAssembly module to a bare minimum. We only need the ability to register 
          new functions and call those new functions instead of specifying a litany of hand written JavaScript functions.
        * It's difficult for JavaScript to know what dependencies your module needs, by allowing the WebAssembly program to create its own functions
          it creates only exactly what it needs.
    fr:
      title: Pourquoi l'invocation dynamique?
      content_markdown: |
        Nous avons vu dans les premiers chapitres que nous pouvions facilement
        écrire nos propres fonctions JavaScript à la main dans nos fichiers `.js`,
        alors pourquoi vouloir créer dynamiquement ces fonctions?

        * Un certain nombre de développeurs sont attirés par WebAssembly pour échapper
          à JavaScript. On pourrait imaginer des librairies natives Rust qui facilitent
          la liaison avec JavaScript et nous évite tout simplement d'écrire du code
          JavaScript.
        * Cela simplifie la configuration et l'amorçage d'un module WebAssembly.
          Nous avons seulement besoin de donner à WebAssembly un moyen de pouvoir
          déclarer et exécuter nos fonctions JavaScript. Nous n'avons dès lors plus
          besoin de spécifier une pléthore de fonctions dans notre code JavaScript.
        * Il est difficile pour JavaScript de savoir quelles dépendances le module
          a besoin et en donnant la possibilité au programme WebAssembly de créer
          ses propres fonctions, ce dernier crée lui-même ce dont il a besoin.
  - en:
      title: Logging Revisited
      content_markdown: |
        In our first chapter we manually wrote our log functions to do logging with `console.log`.  Let's consider how we would do this dynamically.

        * We need some way to register a function at runtime.
        * We need some way to call that function.
        * We'll need some way for that dynamic function to have access to memory (e.g. for extracting utf-8 bytes.)

    fr:
      title: Affichage de texte depuis WebAssembly revisité
      content_markdown: |
        Dans le premier chapitre, nous avons écrit nous même une fonction JavaScript
        qui affichait un texte en appelant `console.log`. Voyons comment procéder de
        manière dynamique (e.g. l'instruction `console.log` se trouvera dans le code
        Rust!):

        * Nous avons besoin d'un moyen de déclarer notre fonction dynamique lors de
        l'exécution.
        * Nous avons besoin d'un moyen d'appeler cette fonction.
        * Nous devons faire en sorte que cette fonction ait accès à la mémoire (e.g.
        pour extraire les octets utf-8.)

  - en:
      title: Registering Functions
      content_markdown: |
        In order to register a function we need two things:

        * we need to pass body of function we want to create in JavaScript as a string
        * we need to get back a handle so we can call that function later with parameters

        ```rust
        register_function(js:&str) -> usize
        ``` 

        Since WebAssembly can only pass back and forth numbers, and since all numbers in JavaScript are 64-bit floats, 
        what this will look like ultimately is an imported function:

        ```
        register_function(js_start:f64,js_len:f64) -> f64
        ```

        Underneath the covers we take advantage of JavaScript's `eval` function to make these functions real.
    fr:
      title: Déclaration de fonctions
      content_markdown: |
        Pour déclarer une fonction, nous avons besoin de deux choses:

        * Nous devons passer le corps de la fonction JavaScript que nous voulons créer
        sous la forme d'une chaîne de caractères.
        * Nous devons avoir un moyen d'appeler cette fonction plus tard. Pour
        cela, les fonctions sont stockées dans un tableau.
        
        La signature Rust de cette fonction est:

        ```rust
        register_function(js:&str) -> usize
        ``` 

        Cependant, étant donné que WebAssembly et JavaScript ne peuvent échanger que
        des nombres et que tous les nombres en JavaScript sont des float 64 bits,
        la signature de cette fonction côté JavaScript sera:

        ```
        register_function(js_start:f64,js_len:f64) -> f64
        ```

        Nous profitons de la fonction `eval` de JavaScript permettant d'évaluer du code
        JavaScript représenté sous forme d'une chaîne de caractères.

  - en:
      title: Calling Functions
      content_markdown: |
        When we later want to call our dynamic function, we'll need some sort of invocation function that can take 
        in our function handle and arguments.

        Again, since WebAssembly can only pass back and forth numbers, and since all numbers in JavaScript are 64-bit floats, 
        what this will look like ultimately is an imported function:

        ```
        js_invoke_with_2_params(fn_handle:f64, a:f64, b:f64) -> f64
        ``` 

        Putting it all together we

        ```rust
        let log_handle = register_function("
          (param_a, param_b) => {
            // somehow call console_log  
          }");

        let msg = "hello world";

        js_invoke_with_2_params( log_handle,msg.as_ptr() as f64, 
            msg.len() as f64 );
        ```

        You'll notice there is a problem with our JavaScript function though. It has the start and end of our utf-8 but not memory!
    fr:
      title: Appel de fonctions
      content_markdown: |
        Lorsque nous voulons appeler une fonction dynamique, nous avons besoin
        de connaître sa position (fn_handle dans le code) dans le tableau contenant
        les fonctions dynamiques ainsi que ses arguments.
        
        Encore une fois, étant donné que WebAssembly ne peut transmettre que des
        nombres et que tous les nombres en JavaScript sont des flottants 64 bits,
        la signature de la fonction pour l'appel des fonctions dynamiques est donc:

        ```
        js_invoke_with_2_params(fn_handle:f64, a:f64, b:f64) -> f64
        ``` 

        Notre code Rust devient:

        ```rust
        let log_handle = register_function("
          (param_a, param_b) => {
            // appel de console_log ici
          }");

        let msg = "hello world";

        js_invoke_with_2_params( log_handle,msg.as_ptr() as f64, 
            msg.len() as f64 );
        ```

        Il y a cependant un problème. En effet, notre fonction JavaScript à appeler
        (celle affichant le console log) doit récupérer le message à afficher depuis
        la mémoire. Elle connait la postition du message dans la mémoire ainsi que sa
        taille, mais comment récupérer le message? Nous utiliserons pour cela un
        contexte!
  - en:
      title: Context Of Dynamic Invocation
      code: https://webassembly.studio/?embed&f=70lhg7nwda9
      content_markdown: |
        When our dynamically invoked functions are called, the functions need to have access to the module's memory. We can place
        important resources on a context object so our function has all the available tools to do it's job.

        ```rust
        let log_handle = register_function("
          (context, msgStart, msgEnd) => {
            let msg = context.getUtf8FromMemory(msgStart,msgEnd);
            console.log(msg); 
          }");

        let msg = "hello world";

        js_invoke_with_2_params( log_handle,msg.as_ptr() as f64, 
          msg.len() as f64);
        ```

        Look at the example for the complete implementation.
    fr:
      title: Contexte d'invocation dynamique
      code: https://webassembly.studio/?f=8z21oi4ptfd
      content_markdown: |
        Lorsque nos fonctions invoquées dynamiquement sont appelées, celles-ci
        doivent avoir accès à la mémoire du module. Pour cela, nous pouvons créer
        une fonction ayant pour but de décoder les octets de cette mémoire et
        passer cette fonction de décodage à chacune des fonctions dynamiques à
        l'aide d'un objet contexte.

        ```rust
        let log_handle = register_function("
          (context, msgStart, msgEnd) => {
            let msg = context.getUtf8FromMemory(msgStart,msgEnd);
            console.log(msg); 
          }");

        let msg = "hello world";

        js_invoke_with_2_params( log_handle,msg.as_ptr() as f64, 
          msg.len() as f64);
        ```

        Nous donnons un exemple avec l'implémentation complète.
  - en:
      title: Returning References
      content_markdown: |
        We run into an issue with dynamic functions when we want to return a reference to an object. WebAssembly can only pass
        around numbers! To break past this challenge, we must establish a convention of using a numerical handle to represent
        a reference to our object in JavaScript.

        ```rust
        let query_selector_handle = register_function("
          (context, selectorStart, selectorEnd) => {
            let selector = context.getUtf8FromMemory(
              selectorStart,selectorEnd);
            let domEl = document.querySelector(selector);
            let objHandle = context.storeObject(domEl);
            return objHandle;
          }");

        let selector = "#fancy-button";

        let dom_element_handle = js_invoke_with_2_params(
            log_handle,selector.as_ptr() as f64, 
            selector.len() as f64 );
        ```
  - en:
      title: Allocators
      code: https://webassembly.studio/?embed&f=mz2gu9y29tn
      content_markdown: |
        As we can see to properly communicate objects, we need to have some kind of storage mechanism for objects:

          * `storeObject(object) -> f64` - Stores an object and returns a numerical handle.
        * `getObject(f64) -> object` - Get a reference to an object by it's numerical handle.
        * `releaseObject(f64) -> object` - Release a reference to an object from storage, allowing it's memory to be freed.

        The implementation of something like this is called an *allocator*. This is beyond the scope of this tutorial. We
        could imagine a very naive implementation of this which is essentially just an ever growing vector where 
        when an object is stored in the vector and it's index is returned as the handle.

        ```
        let storage = [];

        function storeObject(obj){
          let index = storage.length;
          storage.push(obj);
          return index;
        }

        function getObject(handle){
          return storage[handle];
        }

        function releaseObject(handle){
          return storage[handle] = null;
        }
        ```

        There are many issues for you to consider with your implementation.

  - en:
      title: Drawing To The Screen
      code: https://webassembly.studio/?embed&f=bdhga9zwlem
      content_markdown: |
        Let's put it all together with a an example by drawing a red square to the screen. Let's think about the functions we'll need
        to register:

        ```rust
        let get_2d_context = register_function("
          (context, selectorStart, selectorEnd) => {
            let selector = context.getUtf8FromMemory(
              selectorStart,selectorEnd);
            let domEl = document.querySelector(selector);
            let ctx = domEl.getContext("2d");
            let objHandle = context.storeObject(ctx);
            return objHandle;
          }");

        let set_context_color = register_function("
          (context, ctxHandle, colorStart, colorEnd) => {
            let color = context.getUtf8FromMemory(
              colorStart,colorEnd);
            let ctx = context.getObject(ctxHandle);
            ctx.fillStyle = color;
          }");

        let draw_rect = register_function("
          (context, ctxHandle, x, y, width, height) => {
            let ctx = context.getObject(ctxHandle);
            ctx.fillRect(x,y,width,height);
          }");
        ```
  - en:
      title: Chapter 3 Conclusion
      content_markdown: |
        We now have the ability to invoke any kind of JavaScript! How cool is that? Using eval obviously is not that ideal,
        but WebAssembly is an evolving technology that will one day have better ways to access any aspect of the 
        browser. Until then we do our best! The next chapter is on asynchronous programming!

  - beta: true
    chapter: 4
    en:
      title: Chapter 4 - Asynchronous Programming
      content_markdown: |
        Promises, etc.

  - chapter: 5
    en:
      title: The End
      content_markdown: |
        That's all for now. Stay tuned for new content. I hope you enjoy the journey ahead!
    en_c:
      clone: en
    ie:
      title: Fine
      content_markdown: |
        To es omnicos por nu. Plu tard va venir nov contenete. Yo espera que tu va juir li viage a sequer!
    pt-br:
      title: Fim
      content_markdown: |
        Isso é tudo por enquanto. Fique ligado para novos conteúdos. Espero que
        se divirta nesta jornada!
    es:
      title: Fin
      content_markdown: |
        Esto es todo por ahora, pero aún quedan más capítulos, así que ¡muy atento! Esperamos que disfrutes del viaje.
